{"id": 3519, "formal_statement": "theorem dummy [MeasurableSpace Œ≤] {f : Œ± ‚Üí Œ≤} : Measurable[‚ä§] f :=", "nl_statement": "The statement is about a theorem concerning measurability in the context of measurable spaces. It asserts that any function `f` from an arbitrary type `Œ±` to a measurable space `Œ≤`, equipped with the largest possible œÉ-algebra (denoted by `‚ä§` for the \"top\" or the \"largest\" œÉ-algebra), is measurable. This œÉ-algebra makes all subsets of `Œ≤` measurable."}
{"id": 11089, "formal_statement": "theorem dummy (f : Œπ ‚Üí Set Œ±) : lowerClosure (‚ãÉ i, f i) = ‚®Ü i, lowerClosure (f i) :=", "nl_statement": "The statement we are considering is about the lower closure of a union of sets in some context involving a type `Œ±`. Specifically, it asserts that the lower closure of the union of a family of sets `(f : Œπ ‚Üí Set Œ±)` is equal to the supremum (or least upper bound) of the lower closures of each set in the family."}
{"id": 5113, "formal_statement": "theorem dummy : eval i '' pi univ t ‚äÜ t i :=", "nl_statement": "The statement concerns a function `eval i` applied to a set resulting from a product operation `pi univ t` and asserts that the image of this operation under `eval i` is a subset of the set `t i`. In more intuitive terms, consider a collection of sets indexed by some set (let's call this index set \"universe\"), and `pi univ t` represents the Cartesian product of these sets across the entire universe. The `eval i` function then picks elements from the Cartesian product specific to the index `i`. The statement claims that when you take the image of the entire Cartesian product through this evaluation at `i`, you'll end up with a set that is contained within (or equal to) the original set at that index `i`."}
{"id": 469, "formal_statement": "theorem dummy {q‚ÇÅ q‚ÇÇ : Stmt‚ÇÇ} : q‚ÇÅ ‚àà stmts‚ÇÅ q‚ÇÇ ‚Üí stmts‚ÇÅ q‚ÇÅ ‚äÜ stmts‚ÇÅ q‚ÇÇ :=", "nl_statement": "The theorem `stmts‚ÇÅ_trans` states a property about a transition relation within a collection of statements `stmts‚ÇÅ` related to some formal system, possibly a programming language or a machine model like a Turing machine. Specifically, it asserts that if a statement `q‚ÇÅ` is within the set of statements `stmts‚ÇÅ` of another statement `q‚ÇÇ`, then the set of statements `stmts‚ÇÅ` of `q‚ÇÅ` is a subset of the set of statements `stmts‚ÇÅ` of `q‚ÇÇ`. This is a form of transitivity on the containment of statements within these sets."}
{"id": 10513, "formal_statement": "theorem dummy (x : E) : StarConvex ùïú x {x} :=", "nl_statement": "The problem states that given a point \\(x\\) in a vector space \\(E\\) over a field \\(\\mathbb{K}\\), the set containing only \\(x\\) is star-convex with respect to \\(x\\)."}
{"id": 3532, "formal_statement": "theorem dummy (z w : ‚ÑÇ) : (z + w).re = z.re + w.re :=", "nl_statement": "The theorem states that for any two complex numbers \\(z\\) and \\(w\\), the real part of their sum (\\(z + w\\)) is equal to the sum of their real parts. In other words, if you add two complex numbers together, the real component of the result is the same as if you had just added the real components of the original two numbers."}
{"id": 8066, "formal_statement": "theorem dummy {a b : Œ±} : a ‚àÜ b ‚â§ a ‚äî b :=", "nl_statement": "The theorem states that for any two elements `a` and `b` of a certain type `Œ±`, the symmetric difference between `a` and `b` (denoted as `a ‚àÜ b`) is less than or equal to the supremum (least upper bound) of `a` and `b` (denoted as `a ‚äî b`)."}
{"id": 7006, "formal_statement": "theorem dummy : a ‚àÜ c ‚â§ a ‚àÜ b ‚äî b ‚àÜ c :=", "nl_statement": "The statement is about the symmetric difference between sets, a fundamental concept in set theory. The symmetric difference between two sets, \\(A\\) and \\(B\\), denoted \\(A \\Delta B\\), is defined as the set of elements that are in either of the sets \\(A\\) or \\(B\\) but not in their intersection. In symbols, \\(A \\Delta B = (A \\backslash B) \\cup (B \\backslash A)\\), where \\(\\backslash\\) denotes the set difference, and \\(\\cup\\) denotes the union of sets.\n\nThe theorem, named `symmDiff_triangle`, can be stated in natural language as follows:\n\nGiven any three sets \\(a\\), \\(b\\), and \\(c\\), the symmetric difference between the sets \\(a\\) and \\(c\\) is a subset of the union of the symmetric differences between \\(a\\) and \\(b\\), and \\(b\\) and \\(c\\). In formula terms, this is: \\(a \\Delta c \\leq (a \\Delta b) \\cup (b \\Delta c)\\)."}
{"id": 10149, "formal_statement": "theorem dummy [Preorder Œ±] (a b : Œ±) : Bounded (¬∑ < ¬∑) (Ioo a b) :=", "nl_statement": "The statement to be discussed asserts that within a preorder setting (a mathematical structure where relations between elements can be compared but are not necessarily strictly ordered or equivalent), for any two elements `a` and `b`, the open interval between `a` and `b` (denoted as `Ioo a b`, where `Ioo` stands for the interval `(a, b)` that includes all elements greater than `a` and less than `b`) is bounded with respect to the less-than relation (`<`). This means there exists an upper and a lower bound within the set that confines all the elements of the interval in terms of the less-than relation."}
{"id": 8235, "formal_statement": "theorem dummy : ‚àÄ x y, v (x + y) ‚â§ v x ‚à® v (x + y) ‚â§ v y :=", "nl_statement": "The theorem `map_add'` states that for any elements `x` and `y`, the valuation of the sum `x + y` is less than or equal to the valuation of `x` or the valuation of `y`."}
{"id": 866, "formal_statement": "theorem dummy : (K.toLieSubmodule : Submodule R L) = K :=", "nl_statement": "The given statement is about a mathematical construct within the context of Lie algebras, specifically focusing on the relationship between a Lie subalgebra and its associated Lie submodule when considered as a submodule of a larger Lie algebra, `L`, over a ring, `R`. The theorem states that if you take a Lie subalgebra `K` of a Lie algebra `L` and view it as a Lie submodule, then this view (or interpretation) is identical to considering it directly as a submodule `K` of `L`."}
{"id": 12133, "formal_statement": "theorem dummy [Inhabited Œ±] : Primrec (@List.headI Œ± _) :=", "nl_statement": "The theorem states that the function to obtain the head (first element) of a list, with a type that has a default value (i.e., is `Inhabited`), is primitive recursive. In simpler terms, this theorem is about proving that there's a systematic, step-by-step method (a recursive function) to get the first item of a list for types of elements that have a default value if the list is empty."}
{"id": 6970, "formal_statement": "theorem dummy {a : Œ±} {b : Œ≤} : swap (a, b) = (b, a) :=", "nl_statement": "The statement given is about the `swap` function applied to a pair of elements. Specifically, if you have a pair where the first element is of type Œ± and the second is of type Œ≤, swapping the elements of the pair will result in the second element coming first and the first element coming second."}
{"id": 7124, "formal_statement": "theorem dummy (e : Œ± ‚âÉo Œ≤) : Tendsto e atTop atTop :=", "nl_statement": "The statement to be translated is about a mathematical property regarding functions and limits, specifically in the context of order theory. The theorem `tendsto_atTop` involves an order isomorphism `e` between two ordered sets `Œ±` and `Œ≤`. It asserts that if you have an order-preserving bijection (an isomorphism that respects the order of elements) between two ordered sets, then the function represented by this isomorphism tends to infinity in the domain if and only if it tends to infinity in the codomain."}
{"id": 3382, "formal_statement": "theorem dummy : (pullbackConeOfLeftIso f g).œÄ.app none = g :=", "nl_statement": "The theorem named `pullbackConeOfLeftIso_œÄ_app_none` asserts that when we apply the projection (denoted by `.œÄ.app none`) to the pullback cone constructed from a left isomorphism in a category (denoted by `pullbackConeOfLeftIso f g`), the result is equal to `g`. In simpler terms, this theorem is about a specific construction in category theory related to pullback cones, and it specifies what happens when you project this construction along a certain morphism."}
{"id": 13873, "formal_statement": "theorem dummy {i : Set Œ±} (hi : MeasurableSet i) (h : v ‚â§[i] w) : -w ‚â§[i] -v :=", "nl_statement": "This problem concerns a theorem related to vector measures in measure theory, a branch of mathematics. The theorem states that for any measurable set \\(i\\) in a set \\(\\alpha\\), if a vector measure \\(v\\) is less than or equal to another vector measure \\(w\\) on the set \\(i\\) (denoted as \\(v \\leq[i] w\\)), then the negation of \\(w\\) is less than or equal to the negation of \\(v\\) on the set \\(i\\) (denoted as \\(-w \\leq[i] -v\\))."}
{"id": 5545, "formal_statement": "theorem dummy : a ‚â† ‚àû ‚Üí (b + a ‚â§ c + a ‚Üî b ‚â§ c) :=", "nl_statement": "This theorem is about the addition of extended non-negative real numbers (\\(\\overline{\\mathbb{R}}_+\\)), specifically \"ennreal\" in Lean4, which includes all non-negative real numbers along with infinity (\\(\\infty\\)). The theorem states that adding the same non-infinite element to both sides of a comparison does not affect the inequality. In more formal terms, if \\(a\\) is not infinity, then \\(b + a \\leq c + a\\) if and only if \\(b \\leq c\\)."}
{"id": 3640, "formal_statement": "theorem dummy (h : a = c * b) : a / b = c :=", "nl_statement": "The statement asserts that if the variable \\(a\\) equals the product of \\(c\\) and \\(b\\) (\\(a = c \\times b\\)), then dividing \\(a\\) by \\(b\\) yields \\(c\\) (\\(a / b = c\\))."}
{"id": 6870, "formal_statement": "theorem dummy : ‚àÄ l n, List.Chain (¬∑ ‚â§ ¬∑) n (raise l n) | [], _ => List.Chain.nil | _ :: _, _ => List.Chain.cons (Nat.le_add_left _ _) (raise_chain _ _) :=", "nl_statement": "The statement at hand describes a theorem concerning a function named `raise` that operates on a list of natural numbers and a natural number `n`. The theorem asserts that for any list `l` and any natural number `n`, if you apply the `raise` function to `l` and `n`, the resulting list will form a chain of elements where each element is less than or equal to the next, starting with `n`."}
{"id": 4664, "formal_statement": "theorem dummy (i : Œî' ‚ü∂ Œî) [Mono i] (hi : IsŒ¥‚ÇÄ i) : mapMono K i = K.d Œî.len Œî'.len :=", "nl_statement": "The theorem `mapMono_Œ¥‚ÇÄ'` is about a specific scenario in algebraic topology, particularly in the context of Dold-Kan correspondence. It states that for a certain kind of morphism `i` (from `Œî'` to `Œî`), which is mono (meaning it's a monomorphism, a kind of function that preserves the distinctness of elements), and satisfies the condition `IsŒ¥‚ÇÄ` (a specific property related to `i`), the result of applying the function `mapMono` with arguments `K` (a given object or structure) and `i` is equal to `K.d Œî.len Œî'.len`. Essentially, it's about equating a mapped mono object to another specific object structure within the context of algebraic topology."}
{"id": 8977, "formal_statement": "theorem dummy (f : Œ± ‚Üí‚ÇÄ M) : (linearEquivFunOnFinite R M Œ±).symm f = f :=", "nl_statement": "The theorem states that for a given finite-dimensional vector space \\(M\\) over a ring \\(R\\) and a finite set \\(Œ±\\), the inverse (\\(\\text{symm}\\)) of the linear equivalence (\\(\\text{linearEquivFunOnFinite}\\)) applied to a function \\(f\\) from \\(Œ±\\) to \\(M\\) (\\(f : Œ± ‚Üí‚ÇÄ M\\)), when applied to \\(f\\), yields \\(f\\) itself."}
{"id": 2719, "formal_statement": "theorem dummy (v : V) (x y : P) : nndist (v +·µ• x) (v +·µ• y) = nndist x y :=", "nl_statement": "The statement concerns the non-negative distance (denoted as `nndist`) between two points, after a vector has been added to both points. Specifically, it states that if you take any vector `v` and two points `x` and `y`, then the non-negative distance between `x` and `y` after adding `v` to both of them (`v +·µ• x` and `v +·µ• y`) is the same as the non-negative distance between `x` and `y` before adding the vector."}
{"id": 2162, "formal_statement": "theorem dummy {a : Œ±} {s‚ÇÅ s‚ÇÇ : AList Œ≤} (p : s‚ÇÅ.entries ~ s‚ÇÇ.entries) : a ‚àà s‚ÇÅ ‚Üî a ‚àà s‚ÇÇ :=", "nl_statement": "The theorem states that if two associative lists, `s‚ÇÅ` and `s‚ÇÇ`, of type `AList Œ≤` (where `Œ≤` represents the type of elements in the lists and `Œ±` represents the type of keys), have entries that are permutations of each other (`s‚ÇÅ.entries ~ s‚ÇÇ.entries`), then an element `a` (of type `Œ±`) is a member of the first list `s‚ÇÅ` if and only if it is a member of the second list `s‚ÇÇ`."}
{"id": 11549, "formal_statement": "theorem dummy : upperCentralSeries G 0 = ‚ä• :=", "nl_statement": "The theorem named `upperCentralSeries_zero` states that the zeroth term of the upper central series of a group \\( G \\) is the trivial subgroup \\( \\bot \\)."}
{"id": 8081, "formal_statement": "theorem dummy (h : l ~r l') : l ~ l' :=", "nl_statement": "The theorem states that if a list `l` is rotated to form another list `l'`, then `l` is a permutation of `l'`. In other words, if `l` can be transformed into `l'` by a series of rotations (circular shifts), then the elements of `l` can be rearranged to get `l'`, without adding or removing any elements."}
{"id": 14185, "formal_statement": "theorem dummy (ha : ¬¨IsMin b) : Icc a (pred b) = Ico a b :=", "nl_statement": "If \\( b \\) is not the smallest element in a set, then the closed interval from \\( a \\) to the predecessor of \\( b \\) is equal to the half-open interval from \\( a \\) to \\( b \\)."}
{"id": 1462, "formal_statement": "theorem dummy : Function.Injective ((‚Üë) : AffineSubspace k P ‚Üí Set P) :=", "nl_statement": "The theorem named `coe_injective` asserts that the coercion function from `AffineSubspace k P` to `Set P` is injective. In other words, when affine subspaces of a given type `P` over a field `k` are converted to sets of points in `P`, this process does not merge different subspaces into the same set of points."}
{"id": 13832, "formal_statement": "theorem dummy (s : WSeq Œ±) (m) : ‚àÄ n, drop s (m + n) = drop (drop s m) n | 0 => rfl | n + 1 => congr_arg tail (dropn_add s m n) :=", "nl_statement": "The theorem states that for any weak sequence `s` of elements of type `Œ±` and any non-negative integers `m` and `n`, dropping the first `m + n` elements from `s` yields the same sequence as first dropping `m` elements from `s` and then dropping `n` elements from the resulting sequence. In other words, the operation of dropping elements from a sequence is associative with respect to addition of the number of elements to be dropped."}
{"id": 1401, "formal_statement": "theorem dummy {x : A} : x ‚àà (‚ä§ : Subalgebra R A) :=", "nl_statement": "The theorem states that for any element \\( x \\) of type \\( A \\), \\( x \\) is an element of the top subalgebra of \\( A \\) over the ring \\( R \\). In simpler terms, it asserts that every element of \\( A \\) belongs to the largest possible subalgebra of \\( A \\) with respect to \\( R \\)."}
{"id": 11939, "formal_statement": "theorem dummy : c \\ a ‚àÜ b = c ‚äì a ‚äì b ‚äî c \\ a ‚äì c \\ b :=", "nl_statement": "The theorem named `sdiff_symmDiff` states that for any sets `c`, `a`, and `b`, the symmetric difference of `c \\ a` and `b` (`c \\ a ‚àÜ b`) is equal to the intersection of `c`, `a`, and `b` (`c ‚äì a ‚äì b`) combined with the union of the set difference of `c \\ a` and `c \\ b` (`c \\ a ‚äì c \\ b`)."}
{"id": 13572, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (s : Set Œ±) (t : Set Œ≤) : image2 f s t = seq (f '' s) t :=", "nl_statement": "The statement to be translated concerns the equivalence of two set operations involving a function \\(f : \\alpha \\rightarrow \\beta \\rightarrow \\gamma\\), and sets \\(s\\) of type \\(\\alpha\\) and \\(t\\) of type \\(\\beta\\). Specifically, it asserts that the image of the Cartesian product of \\(s\\) and \\(t\\) under \\(f\\), denoted as `image2 f s t`, is equal to the sequential application of \\(f\\) to the image of \\(s\\) under \\(f\\), followed by \\(t\\), denoted as `seq (f '' s) t`."}
{"id": 12468, "formal_statement": "theorem dummy (s : Multiset Œ±) (a : Œ±) : s ‚â§ a ::‚Çò s :=", "nl_statement": "The theorem presented states that for any multiset `s` of type `Œ±` and any element `a` of the same type, the multiset `s` is less than or equal to the multiset formed by adding the element `a` to `s`. In the context of multisets, \"less than or equal to\" (`‚â§`) typically means that one multiset is a sub-multiset of another, meaning all elements of the former are contained within the latter, possibly with fewer occurrences."}
{"id": 1679, "formal_statement": "theorem dummy {s t : Set Œ±} : s·∂ú =·µê[Œº] t·∂ú ‚Üî s =·µê[Œº] t :=", "nl_statement": "The theorem states that for any two sets \\(s\\) and \\(t\\) within a given set \\(\\alpha\\), the measure-theoretic complement of \\(s\\) is almost everywhere equal to the measure-theoretic complement of \\(t\\) if and only if \\(s\\) is almost everywhere equal to \\(t\\). In the context of measure theory, \"almost everywhere\" (\\(=\\mu\\)) means that the property holds except for a set of measure zero."}
{"id": 10458, "formal_statement": "theorem dummy : cosh x ‚â§ cosh y ‚Üî |x| ‚â§ |y| :=", "nl_statement": "The statement to be proved is that the hyperbolic cosine of \\(x\\) is less than or equal to the hyperbolic cosine of \\(y\\) if and only if the absolute value of \\(x\\) is less than or equal to the absolute value of \\(y\\). This is a mathematical statement about the properties of the hyperbolic cosine function."}
{"id": 9749, "formal_statement": "theorem dummy : ContinuousOn (f.extend I).symm (f.extend I).target :=", "nl_statement": "The statement declares that the inverse (denoted as `.symm`) of the extended function `f` (notated as `f.extend I`) is continuous on its target domain. In other words, for a function that has been extended in some manner (the specifics of which are encapsulated by `I`), its inverse maintains continuity over the area where it is defined."}
{"id": 3861, "formal_statement": "theorem dummy : StrictMono (update f i) :=", "nl_statement": "The statement is about a function `update` and its property of being strictly monotonic. In simpler terms, this theorem asserts that if you apply the `update` function to another function `f` at a specific point `i`, the result is a new function that is strictly monotonic. A function is considered strictly monotonic if, for any two distinct inputs, the output always changes in the same direction (either always increases or always decreases)."}
{"id": 8370, "formal_statement": "theorem dummy (ha : Differentiable ùïú a) (n : ‚Ñï) : Differentiable ùïú fun x => a x ^ n :=", "nl_statement": "The theorem states that if a function \\(a(x)\\) is differentiable over a field \\(\\mathbb{K}\\) (which can be the real numbers \\(\\mathbb{R}\\) or the complex numbers \\(\\mathbb{C}\\), for example), then the function \\(a(x)^n\\), where \\(n\\) is a natural number, is also differentiable over \\(\\mathbb{K}\\). In other words, taking the \\(n\\)th power of a differentiable function results in another function that is also differentiable."}
{"id": 10028, "formal_statement": "theorem dummy [h : ValuationRing R] (x y : R) : x ‚à£ y ‚à® y ‚à£ x :=", "nl_statement": "The theorem presented deals with elements of a valuation ring. Specifically, it states that for any two elements \\(x\\) and \\(y\\) in a valuation ring \\(R\\), either \\(x\\) divides \\(y\\) or \\(y\\) divides \\(x\\)."}
{"id": 8189, "formal_statement": "theorem dummy (f : Œ± ‚Üí FreeGroup Œ≤) (x : FreeGroup Œ±) : x‚Åª¬π >>= f = (x >>= f)‚Åª¬π :=", "nl_statement": "The theorem states that for any function `f` from type `Œ±` to the free group of type `Œ≤`, and any element `x` in the free group of type `Œ±`, the inverse of `x` binded to `f` is equal to the bind of `x` to `f` and then taking the inverse of the result. In simpler terms, if you apply the function `f` to each element of the inverse of `x` and then combine the results, it's the same as applying `f` to each element of `x`, combining those results, and then taking the inverse.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 9930, "formal_statement": "theorem dummy [RelHomClass F r s] (f : F) (a : Œ±) : Acc s (f a) ‚Üí Acc r a :=", "nl_statement": "The theorem concerns a situation in a mathematical structure where we have two relations, `r` and `s`, on potentially different sets and a function `f` that respects these relations, meaning if `a` is related to `b` by `r`, then `f(a)` is related to `f(b)` by `s`. Given this setup, the theorem asserts that if `f(a)` is \"accessible\" under `s` (in the sense of accessibility used in well-founded relations), then `a` is accessible under `r`.\n\nAccessibility, in this context, refers to a concept in well-founded relations where an element is accessible if every chain descending from it eventually terminates. This is a crucial property for proving that certain types of recursive definitions or proofs are well-defined."}
{"id": 77, "formal_statement": "theorem dummy {p q : P} : p -·µ• q ‚â† (0 : G) ‚Üî p ‚â† q :=", "nl_statement": "The theorem states that for any two points \\(p\\) and \\(q\\) in a geometric space \\(P\\), the vector subtraction of \\(q\\) from \\(p\\) (denoted as \\(p -·µ• q\\)) is not equal to the zero vector in the vector space \\(G\\) if and only if \\(p\\) is not equal to \\(q\\)."}
{"id": 3140, "formal_statement": "theorem dummy {s : Set (Œ± √ó Œ±)} (hs : s ‚àà ùì§ Œ±) : interior s ‚àà ùì§ Œ± :=", "nl_statement": "The theorem named `interior_mem_uniformity` is concerned with the mathematical field of topology, specifically within the context of uniform spaces. The statement can be expressed as follows: Given a set `s` which is a subset of the product space `Œ± √ó Œ±` and belongs to the uniformity `ùì§ Œ±` of a uniform space `Œ±`, the interior of `s` also belongs to the uniformity `ùì§ Œ±`."}
{"id": 13932, "formal_statement": "theorem dummy : H ‚â§ H.normalizer :=", "nl_statement": "The statement to be proven is that a certain subgroup \\(H\\) is contained within (or equal to) its normalizer in the context of Lie algebras. In more intuitive terms, the normalizer of \\(H\\) is the set of elements in the larger algebra that, when combined with any element of \\(H\\), yields results that are still within \\(H\\). The claim here asserts that \\(H\\) itself is a subset of this normalizer."}
{"id": 12092, "formal_statement": "theorem dummy : ‚àÄ {a : ‚Ñù‚â•0‚àû}, ‚Üëa.toNNReal ‚â§ a | ofNNReal r => by rw [toNNReal_coe] | ‚ä§ => le_top :=", "nl_statement": "The theorem named `coe_toNNReal_le_self` states that for any non-negative extended real number `a` (notated as `‚Ñù‚â•0‚àû`), the real number obtained by converting `a` to a non-negative real number (notated as `toNNReal`) and then converting it back to a non-negative extended real number is less than or equal to the original number `a`."}
{"id": 14276, "formal_statement": "theorem dummy [PartialOrder Œ±] {a b : Œ±} : a ‚â§ b ‚Üî a = b ‚à® a < b :=", "nl_statement": "The statement concerns the relationship between two elements, \\(a\\) and \\(b\\), within a partially ordered set (where each pair of elements is comparable in a certain way, though not necessarily all pairs). It claims that \\(a\\) is less than or equal to \\(b\\) if and only if \\(a\\) is equal to \\(b\\) or \\(a\\) is less than \\(b\\)."}
{"id": 4773, "formal_statement": "theorem dummy {o : Ordinal} (ho : 0 < o) (f : ‚àÄ a < o, Ordinal) : 0 < blsub o f :=", "nl_statement": "The statement concerns a mathematical property related to ordinals, specifically focusing on the concept of \"blsub\" (a function related to ordinals). The theorem states that for any ordinal `o` greater than 0, and for any function `f` that assigns an ordinal to each element less than `o`, the result of applying `blsub` to `o` and `f` is also greater than 0."}
{"id": 6602, "formal_statement": "theorem dummy : algebraMap K[X] (RatFunc K) Polynomial.X = X :=", "nl_statement": "The statement is about the mapping from polynomials over a field \\(K\\) to the field of rational functions over \\(K\\). Specifically, it asserts that when you map the polynomial \\(X\\) (which is just the variable \\(X\\) considered as a polynomial of degree one) using the algebraic map from the ring of polynomials \\(K[X]\\) to the field of rational functions \\(\\text{RatFunc} K\\), the result is the rational function \\(X\\), which is understood as the rational function whose numerator is the polynomial \\(X\\) and whose denominator is 1.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 13701, "formal_statement": "theorem dummy : Function.Surjective (trop : R ‚Üí Tropical R) :=", "nl_statement": "The theorem being discussed states that the function \\( trop : R \\rightarrow Tropical\\ R \\) is surjective. This means that for every element in the target space \\(Tropical\\ R\\), there exists at least one element in the source space \\(R\\) that maps to it."}
{"id": 14469, "formal_statement": "theorem dummy [Module R‚ÇÅ M‚ÇÇ] (x : M‚ÇÅ) : inl R‚ÇÅ M‚ÇÅ M‚ÇÇ x = (x, 0) :=", "nl_statement": "The given statement is a theorem about linear maps in the context of modules, specifically when using the operation \"inl\" (injection from the left) in a setting involving modules over a ring \\(R_1\\) and two modules \\(M_1\\) and \\(M_2\\). The theorem states that for any element \\(x\\) from module \\(M_1\\), when \"inl\" is applied to \\(x\\), the result is a pair \\((x, 0)\\), where \\(0\\) is the zero element of module \\(M_2\\)."}
{"id": 10561, "formal_statement": "theorem dummy : f.neLocus g = (f - g).support :=", "nl_statement": "The theorem named `neLocus_eq_support_sub` states that the locus of points where two functions `f` and `g` are not equal is identical to the support of the function obtained by subtracting `g` from `f`."}
