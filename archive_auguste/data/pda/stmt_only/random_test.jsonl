{"id": 0, "formal_statement": "theorem dummy {n : ‚Ñï} : (n : ZMod 2) = 0 ‚Üî Even n :=", "nl_statement": "The statement to be proven is that for any natural number \\(n\\), the equivalence of \\(n\\) being congruent to \\(0\\) modulo \\(2\\) (i.e., \\(n \\mod 2 = 0\\)) is equivalent to \\(n\\) being an even number."}
{"id": 1, "formal_statement": "theorem dummy (a b : Œ±) {p : Œ± ‚Üí Prop} (ha : p a) (hb : p b) : p (a ‚äî b) :=", "nl_statement": "The theorem `sup_ind` concerns an abstract setting with a type `Œ±`, which is equipped with a binary operation `‚äî` (read as \"sup\" for supremum, indicating some kind of maximum or least upper bound operation between two elements of `Œ±`). Given two elements `a` and `b` of type `Œ±`, and a property `p` that can be applied to elements of `Œ±`, the theorem states that if `p` holds for both `a` and `b`, then `p` also holds for `a ‚äî b`."}
{"id": 2, "formal_statement": "theorem dummy (h : n ‚â§ m) : Odd (m - n) ‚Üî (Odd m ‚Üî Even n) :=", "nl_statement": "The statement addresses the parity (odd or even status) of the difference between two natural numbers, `m` and `n`, under the condition that `n` is less than or equal to `m`. It asserts that the difference `m - n` is odd if and only if `m` is odd and `n` is even, or vice versa (if `m` is even and `n` is odd)."}
{"id": 3, "formal_statement": "theorem dummy (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √ó‚ÑÇ t) :=", "nl_statement": "The statement concerns the openness of the Cartesian product of two sets, \\(s\\) and \\(t\\), in the complex plane. Specifically, it asserts that if \\(s\\) and \\(t\\) are both open sets, then their Cartesian product, denoted \\(s √ó‚ÑÇ t\\), is also an open set."}
{"id": 4, "formal_statement": "theorem dummy {b : Œ≤} : comap m (pure b) = ùìü (m ‚Åª¬π' {b}) :=", "nl_statement": "The theorem named `comap_pure` is about the relationship between the `comap` (preimage filter) of a function `m` applied to the `pure` (principal filter generated by a single element) of an element `b` in the codomain, and the principal filter generated by the preimage of the set containing just `b` under the function `m`.\n\nIn more intuitive terms, it states that if you take a single element `b` and look at all the elements in the domain of `m` that map to `b` (i.e., the preimage of `{b}`), and then generate a filter from this set, it is the same as first generating a filter from `b` and then taking the preimage filter of this through `m`."}
{"id": 5, "formal_statement": "theorem dummy (x : Completion Œ±) : dist x x = 0 :=", "nl_statement": "The problem statement is about proving a specific property of distance within the context of a completion of a uniform space. The statement to prove is that the distance between any element \\(x\\) in the completed space and itself is equal to zero. In more formal terms, for any element \\(x\\) in the completion of a uniform space \\(\\alpha\\), the distance from \\(x\\) to \\(x\\) is 0."}
{"id": 6, "formal_statement": "theorem dummy : Ico a.succ b = Ioo a b :=", "nl_statement": "The theorem named `Ico_succ_left` states that the half-open interval from `a+1` to `b` (denoted as `Ico a.succ b` in Lean4, where `Ico` stands for Interval Closed-Open) is equal to the open interval from `a` to `b` (denoted as `Ioo a b` in Lean4, where `Ioo` stands for Interval Open-Open). In simpler terms, it claims that the set of integers greater than `a` and less than `b` is the same as the set of integers greater than or equal to `a+1` and less than `b`."}
{"id": 7, "formal_statement": "theorem dummy {X : C} (f : X ‚ü∂ 0) : f = 0 :=", "nl_statement": "This theorem states that for any object \\(X\\) in a category \\(C\\), if there is a morphism \\(f\\) from \\(X\\) to a zero object (denoted by \\(0\\)), then \\(f\\) must itself be the zero morphism."}
{"id": 8, "formal_statement": "theorem dummy (hs : s ‚àà K.faces) : (s : Set E) ‚äÜ K.space :=", "nl_statement": "The theorem states that for any set \\(s\\) which is a face of a simplicial complex \\(K\\) in a Euclidean space \\(E\\), the set \\(s\\) is a subset of the space of \\(K\\)."}
{"id": 9, "formal_statement": "theorem dummy {P : (‚àÄ i, Œ± i) ‚Üí Prop} : (‚àÉ x, P x) ‚Üî ‚àÉ a v, P (Fin.cons a v) :=", "nl_statement": "The statement deals with a property concerning the existence of a certain structure within a sequence or a tuple of elements from potentially different types (denoted by `Œ± i` for any index `i`). Specifically, it addresses whether a property `P`, which applies to an entire sequence or tuple, can be satisfied by constructing a new sequence using a specific method.\n\nThe essence of the problem is captured in the equivalence statement: there exists a sequence `x` that satisfies property `P` if and only if there exists an element `a` and a sequence `v` such that `P` is satisfied by constructing a new sequence from `a` and `v` using the `Fin.cons` constructor. The `Fin.cons` constructor creates a new sequence where `a` is the first element and `v` represents the rest of the sequence."}
{"id": 10, "formal_statement": "theorem dummy (x : X) {r : ‚Ñù} (hr : 0 < r) : 0 < Œº (ball x r) :=", "nl_statement": "The statement concerns the measure of a ball in a metric space. Specifically, it asserts that for any point \\(x\\) in a space \\(X\\) and for any positive radius \\(r\\), the measure of the ball centered at \\(x\\) with radius \\(r\\) is positive. This is contingent upon the condition that \\(r\\) is greater than zero."}
{"id": 11, "formal_statement": "theorem dummy (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=", "nl_statement": "The theorem named `nhdsWithin_compl_singleton_sup_pure` states that for any element `a` in a topological space `Œ±`, the neighborhood within the set excluding `a` (denoted as `ùìù[‚â†] a`), when combined with the singleton set containing `a` (denoted as `pure a`), is equivalent to the neighborhood of `a` (denoted as `ùìù a`)."}
{"id": 12, "formal_statement": "theorem dummy {x y : I} : I.toCotangent x = I.toCotangent y ‚Üî (x - y : R) ‚àà I ^ 2 :=", "nl_statement": "The theorem states that for any two elements \\(x\\) and \\(y\\) in a set \\(I\\), the condition \\(I.toCotangent(x) = I.toCotangent(y)\\) holds if and only if the difference \\(x - y\\), considered as an element of the real numbers \\(R\\), belongs to the square of the set \\(I\\) (denoted as \\(I^2\\))."}
{"id": 13, "formal_statement": "theorem dummy : (1 : R[X]).roots = ‚àÖ :=", "nl_statement": "The statement is about polynomial roots in the context of a specific ring \\( R \\). It claims that the polynomial which is equivalent to the constant 1 (denoted as \\(1 : R[X]\\)) has no roots, which is symbolized by its roots being equal to an empty set \\(\\emptyset\\)."}
{"id": 14, "formal_statement": "theorem dummy : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t ‚à™ s‚ÇÇ ‚äº t :=", "nl_statement": "The given statement concerns the behavior of a specific mathematical operation, denoted as \"‚äº,\" applied to sets and their unions. It asserts that the result of applying this operation to the union of two sets, \\(s‚ÇÅ \\cup s‚ÇÇ\\), and another set \\(t\\), is equivalent to the union of the results of applying the operation separately to \\(s‚ÇÅ\\) and \\(t\\), and to \\(s‚ÇÇ\\) and \\(t\\). Formally, the theorem can be stated as:\n\n\"For any sets \\(s‚ÇÅ\\), \\(s‚ÇÇ\\), and \\(t\\), the operation \\(‚äº\\) applied to the union of \\(s‚ÇÅ\\) and \\(s‚ÇÇ\\) with \\(t\\) is equivalent to the union of the operation \\(‚äº\\) applied separately to \\(s‚ÇÅ\\) with \\(t\\) and to \\(s‚ÇÇ\\) with \\(t\\).\"\n\nIn mathematical notation, this is expressed as:\n\\[\n(s‚ÇÅ \\cup s‚ÇÇ) ‚äº t = s‚ÇÅ ‚äº t \\cup s‚ÇÇ ‚äº t\n\\]"}
{"id": 15, "formal_statement": "theorem dummy {X : C} : Monotone (J‚ÇÅ.close : Sieve X ‚Üí Sieve X) :=", "nl_statement": "The given theorem asserts the monotonicity of the closure operation in a sieve context within a category, specifically for a sieve `J‚ÇÅ` on an object `X` in a category `C`. In more intuitive terms, this theorem is about a property of a certain operation (`J‚ÇÅ.close`) applied to sieves on an object in category theory, stating that this operation is monotone. That is, if you have two sieves and one is a subset of the other, then applying the closure operation to both will preserve this subset relation."}
{"id": 16, "formal_statement": "theorem dummy {a b : Œ±} (h : Finite a b) : ¬¨IsUnit a := let ‚ü®n, hn‚ü© :=", "nl_statement": "The theorem states that for any two elements `a` and `b` in a certain set `Œ±`, if there is a finite relationship between `a` and `b` (denoted by `Finite a b`), then `a` cannot be a unit (denoted by `¬¨IsUnit a`)."}
{"id": 17, "formal_statement": "theorem dummy [Nonempty P] : Cospherical (‚àÖ : Set P) := let ‚ü®p‚ü© :=", "nl_statement": "The statement asserts that an empty set is cospherical in any nonempty space. In geometric terms, cospherical means that all points of a set lie on the surface of a sphere with a common radius and center. The theorem states that if you have any nonempty space \\(P\\), then the empty set within \\(P\\) is considered cospherical."}
{"id": 18, "formal_statement": "theorem dummy {x : E} : 0 ‚â§ re ‚ü™x, x‚ü´ :=", "nl_statement": "The statement concerns the non-negativity of the real part of the inner product of a vector with itself in an inner product space. Specifically, it asserts that for any vector \\(x\\) in an inner product space \\(E\\), the real part of the inner product of \\(x\\) with itself (\\(‚ü™x, x‚ü´\\)) is greater than or equal to zero."}
{"id": 19, "formal_statement": "theorem dummy {p : Œ± ‚Üí Œ≤ ‚Üí Prop} : (‚àÄ x y, p x y) ‚Üî ‚àÄ y x, p x y :=", "nl_statement": "The theorem presented states that for any property \\(p\\) that takes two arguments of types \\(\\alpha\\) and \\(\\beta\\), the property holds for all combinations of these two types if and only if it holds when the order of the types is swapped. In other words, it doesn't matter in which order you apply the arguments; if the property holds universally for one order, it also holds for the reverse order."}
{"id": 20, "formal_statement": "theorem dummy {p : Œ± ‚Üí Prop} {x : Œ±} : { x | p x } x ‚Üî p x :=", "nl_statement": "The theorem states a proposition about sets and elements in the context of a property `p` applied to elements of type `Œ±`. Specifically, it concerns the set of all elements `x` of type `Œ±` for which the property `p` holds. The statement of the theorem is: an element `x` belongs to the set `{ x | p x }` if and only if the property `p` holds for `x`."}
{"id": 21, "formal_statement": "theorem dummy {s t : Set Œ±} : s ‚äÜ t ‚Üí s ‚à© t = s :=", "nl_statement": "The theorem states that if set \\(s\\) is a subset of set \\(t\\), then the intersection of \\(s\\) and \\(t\\) is equal to \\(s\\). This means that if all elements of \\(s\\) are also in \\(t\\), then when we take the intersection of these two sets (which consists of all elements that are in both \\(s\\) and \\(t\\)), we will just get \\(s\\) back."}
{"id": 22, "formal_statement": "theorem dummy [Nontrivial M‚ÇÄ] : IsPrimitiveRoot (0 : M‚ÇÄ) 0 :=", "nl_statement": "The problem presents a theorem related to the concept of primitive roots in the context of a mathematical structure, \\(M‚ÇÄ\\), under the assumption that \\(M‚ÇÄ\\) is nontrivial. The theorem states that \\(0\\) is a primitive root of \\(0\\) in \\(M‚ÇÄ\\)."}
{"id": 23, "formal_statement": "theorem dummy {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p :=", "nl_statement": "The theorem states that for non-negative extended real numbers `p` and `q`, and a sequence of functions `f`, if `f` is in the space `‚Ñìp` for `q`, and `q` is less than or equal to `p`, then `f` is also in the space `‚Ñìp` for `p`. This is a statement about the inclusion of Lp spaces, where `‚Ñìp` represents a space of sequences whose p-th powers are summable."}
{"id": 24, "formal_statement": "theorem dummy (n : ‚Ñï) (a : R) (h : a ‚â† 0) : order (monomial R n a) = n :=", "nl_statement": "Suppose we have a natural number \\(n\\) and an element \\(a\\) in a ring \\(R\\), with the condition that \\(a \\neq 0\\). The theorem states that the order of the monomial \\(a x^n\\) (denoted as \\(monomial\\ R\\ n\\ a\\)) is equal to \\(n\\)."}
{"id": 25, "formal_statement": "theorem dummy (g : N ‚ãä[œÜ] G) : (map f‚ÇÅ f‚ÇÇ h g).right = f‚ÇÇ g.right :=", "nl_statement": "The theorem named `map_right` concerns a mathematical structure called a semidirect product, denoted as `N ‚ãä[œÜ] G`. This theorem involves a mapping from one semidirect product to another, expressed through the function `map f‚ÇÅ f‚ÇÇ h`, where `f‚ÇÅ` and `f‚ÇÇ` are functions mapping the elements of the groups involved in the semidirect products, and `h` is a condition that ensures the mapping respects the semidirect product structure. The statement of the theorem is that applying this `map` function to an element `g` of the semidirect product `N ‚ãä[œÜ] G` and then taking the \"right\" part of the result (which corresponds to an element of the group `G`) is the same as applying the function `f‚ÇÇ` directly to the \"right\" part of `g`."}
{"id": 26, "formal_statement": "theorem dummy [Zero Œ±] : diag (0 : Matrix n n Œ±) = 0 :=", "nl_statement": "The statement in question is about matrices and their diagonal elements. Specifically, it concerns a square matrix (a matrix with the same number of rows and columns) that is filled entirely with zeros. The theorem states that if you take the diagonal of such a zero matrix (a matrix where all elements are zero), the resulting diagonal vector will also be entirely zero."}
{"id": 27, "formal_statement": "theorem dummy (s : Finset Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚Äñ‚àè b in s, f b‚Äñ‚Çä = ‚àè b in s, ‚Äñf b‚Äñ‚Çä :=", "nl_statement": "The theorem `nnnorm_prod` states that for any finite set `s` of type `Œ≤` and any function `f` from `Œ≤` to `Œ±`, the non-negative norm (notated as ‚Äñ‚àè b in s, f b‚Äñ‚Çä) of the product of the function `f` applied to each element `b` in the set `s` is equal to the product of the non-negative norms of the function `f` applied to each element `b` in the set `s`. In simpler terms, taking the product of the values first and then applying the non-negative norm is the same as applying the non-negative norm to each value first and then taking their product."}
{"id": 28, "formal_statement": "theorem dummy : Function.Bijective (ghostMap : ùïé R ‚Üí ‚Ñï ‚Üí R) :=", "nl_statement": "The statement pertains to the concept of bijectivity of a function named `ghostMap`, which operates from the domain of Witt vectors over a ring `R` to the codomain of functions mapping natural numbers to `R`. The core of this theorem asserts that `ghostMap` is bijective, which means it is both injective (one-to-one) and surjective (onto). This bijectivity is established on the premise that there exists an equivalence (denoted by `ghostEquiv`) between Witt vectors over `R` and a certain mathematical structure, and this equivalence is bijective."}
{"id": 29, "formal_statement": "theorem dummy (f : V ‚Üí‚Çó[K] V‚ÇÅ) : rank f ‚â§ Module.rank K V :=", "nl_statement": "The theorem named `rank_le_domain` is concerned with linear maps from a vector space \\(V\\) over a field \\(K\\) to another vector space \\(V_1\\). It states that the rank of a linear map \\(f\\) from \\(V\\) to \\(V_1\\) is less than or equal to the rank of the vector space \\(V\\) itself. In mathematical terms, if \\(f : V \\to V_1\\) is a linear map, then the rank of \\(f\\) is less than or equal to the Module rank of \\(V\\)."}
{"id": 30, "formal_statement": "theorem dummy : Tendsto (fun x => x ^ (-(1 : ‚Ñù) / x)) atTop (ùìù 1) :=", "nl_statement": "The theorem in question states that as \\(x\\) approaches infinity, the expression \\(x^{-(1/x)}\\) converges to 1."}
{"id": 31, "formal_statement": "theorem dummy (x : ‚Ñù) (n : ‚Ñï) : sin (x - n * (2 * œÄ)) = sin x :=", "nl_statement": "The statement asserts that for any real number \\(x\\) and any natural number \\(n\\), the sine of \\(x\\) minus \\(n\\) times \\(2\\pi\\) (which represents \\(n\\) full rotations in radians) is equal to the sine of \\(x\\) alone. Mathematically, this can be expressed as \\(\\sin(x - n \\cdot 2\\pi) = \\sin(x)\\)."}
{"id": 32, "formal_statement": "theorem dummy : ‚Äñ(0 : Lp E p Œº)‚Äñ‚Çä = 0 :=", "nl_statement": "The statement in question asserts that the non-negative norm (also known as the \"norm plus\" or \\( \\|\\cdot\\|\\_+\\)) of the zero function in the space \\(L^p(E, p, \\mu)\\) is equal to zero. This space involves functions that are measurable with respect to a measure \\( \\mu \\), taking values in a Banach space \\( E \\), and integrable to the \\( p \\)-th power. The statement is formalized within the context of the Lean4 theorem prover."}
{"id": 33, "formal_statement": "theorem dummy : IsComplement' (transferSylow P hP).ker P :=", "nl_statement": "The statement `ker_transferSylow_isComplement'` asserts that within a group \\(G\\), for a given Sylow \\(p\\)-subgroup \\(P\\) of \\(G\\) (with \\(p\\) being a prime and \\(P\\) satisfying the Sylow theorems), the kernel of the \"transfer\" homomorphism from \\(P\\) to itself is a complement to \\(P\\) in a specific sense. This \"specific sense\" refers to the notion of \\(P\\) and its kernel together satisfying certain conditions that make them behave somewhat like two pieces fitting together to form a whole, without necessarily being a direct product."}
{"id": 34, "formal_statement": "theorem dummy (hb : P.b ‚â† 0) : P.toPoly ‚â† 0 :=", "nl_statement": "The statement concerns proving that a certain polynomial, referred to as `P.toPoly`, is not equal to zero, under the condition that a specific coefficient of this polynomial, denoted as `P.b`, is also not equal to zero. The theorem is formalized as follows: if `P.b` is not equal to zero, then `P.toPoly` is not equal to zero."}
{"id": 35, "formal_statement": "theorem dummy : (homogeneousComponent n œÜ).IsHomogeneous n :=", "nl_statement": "The statement `homogeneousComponent_isHomogeneous` asserts that for any given natural number `n` and any polynomial `œÜ`, the homogeneous component of `œÜ` of degree `n` is indeed a homogeneous polynomial of degree `n`. In simpler terms, this means if you take all parts of a polynomial that are of degree `n`, the resulting polynomial will only consist of terms of degree `n`."}
{"id": 36, "formal_statement": "theorem dummy (hf : Injective f) {x y : Œ±} : f x ‚â† f y ‚Üî x ‚â† y :=", "nl_statement": "The statement pertains to a function `f` and asserts that for any two elements `x` and `y` from a certain set (implied by the type `Œ±`), the fact that `f(x)` is not equal to `f(y)` is equivalent to `x` not being equal to `y`, under the condition that `f` is an injective function. Injectivity here means that whenever `f(a) = f(b)`, it must follow that `a = b`."}
{"id": 37, "formal_statement": "theorem dummy [OrderTop Œ±] [OrderTop (Subtype p)] (htop : p ‚ä§) : ((‚ä§ : Subtype p) : Œ±) = ‚ä§ :=", "nl_statement": "The theorem states that if `Œ±` is a type with a designated top element (greatest element) and if `p` is a property that subsets of `Œ±` can have, then the top element of the subtype of `Œ±` consisting of those elements that satisfy the property `p` is the same as the top element of `Œ±`. This is under the assumption that the top element of `Œ±` satisfies the property `p`."}
{"id": 38, "formal_statement": "theorem dummy (x : H) : map I (ùìù x) = ùìù[range I] I x :=", "nl_statement": "The theorem states that for a given point \\(x\\) in a topological space \\(H\\), the image of the neighborhood of \\(x\\) under a continuous function \\(I\\), which maps \\(H\\) to another topological space, is equivalent to the neighborhood within the range of \\(I\\) of the point \\(I(x)\\)."}
{"id": 39, "formal_statement": "theorem dummy (a : SignType) : -a = a ‚Üî a = 0 :=", "nl_statement": "The theorem states that for a given element \\(a\\) of some type `SignType`, the equation \\(-a = a\\) holds if and only if \\(a = 0\\)."}
{"id": 40, "formal_statement": "theorem dummy (h : a ‚àâ s) : s ‚à© insert a t = s ‚à© t :=", "nl_statement": "Intersection of a Set with the Insertion of an Element Not in the Set\n\nConsider a set `s` and another set `t`, along with an element `a` that is not a member of `s` (denoted as `a ‚àâ s`). The theorem states that the intersection of `s` with the set obtained by inserting `a` into `t` (`insert a t`) is identical to the intersection of `s` with `t` itself. In mathematical notation, this is expressed as:\n\n\\[s \\cap (t \\cup \\{a\\}) = s \\cap t\\]"}
{"id": 41, "formal_statement": "theorem dummy {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=", "nl_statement": "The theorem states that for any function `f` from a set `Œ±` to a set `Œ≤`, and for any two outer measures `m` and `m'` on `Œ±`, the outer measure of the supremum (least upper bound) of `m` and `m'` mapped through `f` is equal to the supremum of the outer measures of `m` and `m'` individually mapped through `f`. \n\nThis can be intuitively understood as saying that if you have two ways of measuring things in one space (`Œ±`), and then you map those measurements into another space (`Œ≤`), taking the \"bigger\" measurement at each point in `Œ±` before or after the mapping gives the same result."}
{"id": 42, "formal_statement": "theorem dummy (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=", "nl_statement": "The theorem states that for any element `a` of a certain type `A` and natural numbers `m` and `n`, the operation of scaling `a` by the sum of `m` and `n` (denoted as `(m + n) ‚Ä¢ a`) is equivalent to the sum of scaling `a` by `m` and then by `n` (denoted as `m ‚Ä¢ a + n ‚Ä¢ a`)."}
{"id": 43, "formal_statement": "theorem dummy {l : List K} : (‚àÄ x ‚àà l, x ‚àà s) ‚Üí l.sum ‚àà s :=", "nl_statement": "The statement given concerns a property about the sum of elements in a list. Specifically, it deals with a list `l` of elements of type `K`. The lemma states that if every element `x` in the list `l` belongs to a set `s`, then the sum of all elements in the list `l` also belongs to the set `s`."}
{"id": 44, "formal_statement": "theorem dummy : (‚àÉ·∂† a in comap f l, p a) ‚Üî ‚àÉ·∂† b in l, ‚àÉ a, f a = b ‚àß p a :=", "nl_statement": "The statement in question concerns the concept of \"filter frequently\" within the context of mathematical analysis, specifically dealing with filters, a generalization of sequences and notions of convergence. In essence, it's about understanding the frequency of certain conditions within a \"filtered\" context. The theorem can be stated in natural language as:\n\n\"There exists a condition 'p' that holds frequently for elements 'a' in the comap (the preimage under a function 'f') of a filter 'l', if and only if, there exists a condition that holds frequently for elements 'b' in the filter 'l', such that for some 'a', 'f(a) = b' and 'p(a)' holds.\"\n\nThis essentially ties the frequency of a condition in the preimage of a filter to the frequency of a related condition directly in the filter itself."}
{"id": 45, "formal_statement": "theorem dummy (m : ‚Ñï+) {n k : ‚Ñï+} : k.Coprime n ‚Üí (m * k).gcd n = m.gcd n :=", "nl_statement": "The theorem states that if a number 'k' is coprime with 'n' (meaning 'k' and 'n' have no common prime factors), then the greatest common divisor (GCD) of 'n' and the product of 'm' and 'k' is the same as the GCD of 'n' and 'm'. In other words, multiplying 'm' by a number 'k' that is coprime to 'n' does not change the GCD of 'n' and 'm'."}
{"id": 46, "formal_statement": "theorem dummy (hx : x ‚àà p) : x - y ‚àà p ‚Üî y ‚àà p :=", "nl_statement": "Given a mathematical structure `p` (which can be thought of as a set with additional structure, such as a group, ring, or module) and elements `x` and `y` belonging to some ambient space of `p`, the statement `x - y ‚àà p` is equivalent to `y ‚àà p` if `x` is an element of `p`."}
{"id": 47, "formal_statement": "theorem dummy : AntilipschitzWith 1 f :=", "nl_statement": "The statement describes a theorem named \"antilipschitz\" which asserts that a function `f` is Antilipschitz with a constant 1. This implies that there exists a constant \\( K \\geq 1 \\) such that for any two points \\( x \\) and \\( y \\) in the domain of \\( f \\), the distance between \\( f(x) \\) and \\( f(y) \\) in the codomain is bounded below by the distance between \\( x \\) and \\( y \\) divided by \\( K \\). In this specific case, since \\( K \\) is 1, it indicates that \\( f \\) does not contract distances between points."}
{"id": 48, "formal_statement": "theorem dummy {s‚ÇÅ s‚ÇÇ s‚ÇÉ : Finset Œ±} : s‚ÇÅ ‚äá s‚ÇÇ ‚Üí s‚ÇÇ ‚äá s‚ÇÉ ‚Üí s‚ÇÅ ‚äá s‚ÇÉ :=", "nl_statement": "The theorem states that if you have three finite sets \\(s_1, s_2,\\) and \\(s_3\\) of some type \\(\\alpha\\), and \\(s_1\\) is a superset of \\(s_2\\) (meaning all elements of \\(s_2\\) are also in \\(s_1\\)), and \\(s_2\\) is a superset of \\(s_3\\) (meaning all elements of \\(s_3\\) are also in \\(s_2\\)), then it can be concluded that \\(s_1\\) is a superset of \\(s_3\\) (meaning all elements of \\(s_3\\) are also in \\(s_1\\))."}
{"id": 49, "formal_statement": "theorem dummy : neLocus (f + g) f = g.support :=", "nl_statement": "The statement concerns a mathematical property involving the concept of a \"non-equality locus\" (neLocus) of functions in the context of formal verification. Specifically, it states that the non-equality locus of the sum of two functions (`f + g`) and one of those functions (`f`) is equal to the support of the other function (`g`)."}
{"id": 50, "formal_statement": "theorem dummy : Function.Bijective <| fromLocalizedModule S f :=", "nl_statement": "The theorem named `fromLocalizedModule.bij` states that the function `fromLocalizedModule` applied to a set `S` and a function `f` is bijective. A bijective function is one that is both injective (one-to-one) and surjective (onto)."}
{"id": 51, "formal_statement": "theorem dummy {f : Œπ ‚Üí SimpleGraph V} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß a ‚â† b :=", "nl_statement": "The statement pertains to simple graphs and an operation on them defined by an infimum (denoted by `‚®Ö`). Specifically, it asserts a condition for when two vertices, `a` and `b`, are adjacent in the graph obtained by taking the infimum of a family of simple graphs `(f : Œπ ‚Üí SimpleGraph V)` indexed by `Œπ`. The condition is that `a` and `b` are adjacent in this infimum graph if and only if `a` and `b` are adjacent in every graph in the family and `a` does not equal `b`."}
{"id": 52, "formal_statement": "theorem dummy : lowerBounds (‚àÖ : Set Œ±) = univ :=", "nl_statement": "The theorem named `lowerBounds_empty` states that the set of all lower bounds of the empty set, within any given type `Œ±`, is equal to the universal set. In simpler terms, it tells us that if you consider the empty set (a set with no elements) and look for all the elements that could be considered as lower bounds (elements that are less than or equal to every element in the set) to this empty set, you will find that every possible element can serve as a lower bound. This is because there are no elements in the empty set to contradict this claim, making every element in the universe a valid lower bound."}
{"id": 53, "formal_statement": "theorem dummy [Preorder Œ±] (h : Unbounded (¬∑ ‚â§ ¬∑) s) : Unbounded (¬∑ < ¬∑) s :=", "nl_statement": "The statement asserts that if a set \\(s\\) in a preorder \\(\\alpha\\) is unbounded with respect to the relation \\(\\leq\\) (less than or equal to), then it is also unbounded with respect to the relation \\(<\\) (less than)."}
{"id": 54, "formal_statement": "theorem dummy (b) : Sigma.Œπ I.left b ‚â´ I.sndSigmaMap = I.snd b ‚â´ Sigma.Œπ I.right _ :=", "nl_statement": "The theorem named `Œπ_sndSigmaMap` concerns a categorical setting, specifically within the framework of category theory limits. It states that for a given object `b`, the composition of two morphisms ‚Äì the injection morphism from `b` into the left part of a sigma type (denoted by `Sigma.Œπ I.left b`) followed by a certain morphism called `I.sndSigmaMap` ‚Äì is equal to the composition of another morphism associated with `b` (denoted by `I.snd b`) followed by the injection into the right part of the sigma type (denoted by `Sigma.Œπ I.right _`)."}
{"id": 55, "formal_statement": "theorem dummy {Œ±} (d x : Œ±) : unbot' d x = x :=", "nl_statement": "The statement involves a function `unbot'` that takes two arguments: a default value `d` and a value `x`, both of the same type `Œ±`. The theorem claims that the result of this function is simply the value `x`, regardless of what the default value `d` might be."}
{"id": 56, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) (h h') (x : Œ±) : SimpleFunc.mk f h h' x = f x :=", "nl_statement": "The theorem stated in the Lean4 syntax essentially expresses the following in natural language: Let's consider a function `f` which maps elements of type `Œ±` to elements of type `Œ≤`. We are also given `h` and `h'` which are likely to be hypotheses or conditions related to this function (though their specific roles are not detailed in the given statement). The theorem states that for a simple function created with `f`, `h`, and `h'`, when this simple function is applied to an element `x` of type `Œ±`, it results in the same output as directly applying the function `f` to `x`. In mathematical terms, the output of `SimpleFunc.mk f h h' x` is equal to the output of `f x`."}
{"id": 57, "formal_statement": "theorem dummy (h : Irrational x) {m : ‚Ñï} (hm : m ‚â† 0) : Irrational (x / m) :=", "nl_statement": "The theorem `div_nat` states that if `x` is an irrational number and `m` is a natural number (denoted by ‚Ñï) that is not equal to 0, then the division of `x` by `m` results in an irrational number.\n\nIn summary, the proof relies on the principle that if `x` is irrational, then dividing `x` by a nonzero natural number `m` yields another irrational number, by extending the non-zero condition from the natural numbers to the integers and applying a property of irrational numbers regarding division by integers.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 58, "formal_statement": "theorem dummy {s u : Set Œ±} (h : s ‚äÜ u) (t : Set Œ±) : s ‚äÜ t ‚à™ u :=", "nl_statement": "The theorem states that if a set \\(s\\) is a subset of another set \\(u\\), then \\(s\\) is also a subset of the union of \\(t\\) and \\(u\\), where \\(s\\), \\(t\\), and \\(u\\) are sets of some unspecified type \\(\\alpha\\)."}
{"id": 59, "formal_statement": "theorem dummy (h : x ^ 2 < y) : x < sqrt y :=", "nl_statement": "The theorem named `lt_sqrt_of_sq_lt` asserts that if the square of a number `x` is less than another number `y`, then `x` itself is less than the square root of `y`. This statement is formalized within the context of real numbers."}
{"id": 60, "formal_statement": "theorem dummy (i : Œπ) (f : Œ†‚ÇÄ i, Œ≤ i) : single i (f i) + f.erase i = f :=", "nl_statement": "The theorem named `single_add_erase` states that for any finite-dimensional function `f` from indices `i` to values in `Œ≤ i`, if you create a new function by taking the \"single\" function at index `i` with its corresponding value `f i`, and then add (`+`) this back to the original function `f` with the value at `i` erased (`f.erase i`), the result is identical to the original function `f`."}
{"id": 61, "formal_statement": "theorem dummy (n : ‚Ñï) : n.bits.length = n.size :=", "nl_statement": "The statement we're looking at asserts that the length of the binary representation (list of bits) of a natural number \\(n\\) is equal to the size of \\(n\\). The \"size\" in this context refers to the number of bits required to represent \\(n\\) in binary form."}
{"id": 62, "formal_statement": "theorem dummy (n : ‚Ñï) : bodd (succ n) = not (bodd n) :=", "nl_statement": "The theorem `bodd_succ` states that the Boolean parity (oddness) of the successor of a natural number `n` is the negation of the Boolean parity of `n` itself. In simpler terms, if `n` is even, then `n + 1` is odd, and if `n` is odd, then `n + 1` is even."}
{"id": 63, "formal_statement": "theorem dummy {M N P : AddSubmonoid R} : M * N ‚â§ P ‚Üî ‚àÄ m ‚àà M, ‚àÄ n ‚àà N, m * n ‚àà P :=", "nl_statement": "The theorem concerns the product of two add submonoids `M`, `N` of a ring `R` and its relation to another add submonoid `P` of the same ring. It states that the product `M * N` is a subset of `P` if and only if for every element `m` in `M` and every element `n` in `N`, their product `m * n` is an element of `P`."}
{"id": 64, "formal_statement": "theorem dummy {s} : ContinuousOn I.symm s :=", "nl_statement": "The statement given is about a property of continuity in a mathematical setting, specifically within the context of functions and spaces. The theorem, named `continuousOn_symm`, asserts that a certain function, denoted as `I.symm`, is continuous on a set `s`. This is a concept from topology, a branch of mathematics concerned with the properties of space that are preserved under continuous transformations."}
{"id": 65, "formal_statement": "theorem dummy (x y : ‚Ñù) : expMapCircle (x + y) = expMapCircle x * expMapCircle y :=", "nl_statement": "The theorem named `expMapCircle_add` concerns a property of the exponential map from real numbers to the unit circle in the complex plane. Specifically, it states that for any two real numbers \\(x\\) and \\(y\\), the exponential map of their sum (\\(x + y\\)) is equal to the product of the exponential maps of \\(x\\) and \\(y\\) individually."}
{"id": 66, "formal_statement": "theorem dummy : r S = r' S :=", "nl_statement": "The statement you've provided, `theorem r_eq_r' : r S = r' S`, expresses that two mathematical objects, `r S` and `r' S`, are equal. These objects are typically functions, sets, or algebraic structures defined within the context of the theorem, which is not fully detailed in your snippet. The theorem is situated within a mathematical framework that likely involves concepts of order, sets, and possibly algebraic operations (like multiplication) given the syntax and operations mentioned."}
{"id": 67, "formal_statement": "theorem dummy : Ioi a ‚à© Ioi b = Ioi (a ‚äî b) :=", "nl_statement": "The theorem states that the intersection of two sets, where each set consists of all elements greater than a certain value (denoted by `Ioi a` for elements greater than `a` and `Ioi b` for elements greater than `b`), is equal to the set of all elements greater than the maximum of those two values (`a ‚äî b`), where `‚äî` denotes the supremum or least upper bound of `a` and `b`."}
{"id": 68, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) (g l r) : (Equiv.mk f g l r : Œ± ‚Üí Œ≤) = f :=", "nl_statement": "The lemma states that given a function `f` from type `Œ±` to type `Œ≤` and an equivalence relation `Equiv.mk f g l r`, when this equivalence relation is viewed as a function from `Œ±` to `Œ≤`, it is identical to the original function `f`."}
{"id": 69, "formal_statement": "theorem dummy (f : HeytingHom Œ± Œ≤) : (HeytingHom.id Œ≤).comp f = f :=", "nl_statement": "The statement concerns a mathematical structure known as a Heyting algebra, which is a generalization of Boolean algebra important in intuitionistic logic. Specifically, it deals with homomorphisms between Heyting algebras, which are functions preserving the algebraic structure. The theorem `id_comp` asserts that the composition of any Heyting algebra homomorphism `f` from an algebra `Œ±` to another algebra `Œ≤` with the identity homomorphism on `Œ≤` results in the original homomorphism `f`."}
{"id": 70, "formal_statement": "theorem dummy (f g : X ‚ü∂ Y) : (parallelPair f g).obj zero = X :=", "nl_statement": "The statement given is a lemma in the context of category theory, particularly within the framework of limits. It specifies a property about the object part of a parallel pair construction in a category. Let's break down the elements of the statement for a clearer understanding:\n\n- `X ‚ü∂ Y` represents a morphism from an object `X` to an object `Y` in a category.\n- `parallelPair f g` refers to the construction of a parallel pair using two morphisms `f` and `g`, both of which go from `X` to `Y`.\n- `.obj zero` is about evaluating the object part of this construction at a particular point, in this case, the point denoted by `zero`.\n- The conclusion `(parallelPair f g).obj zero = X` states that evaluating the object part of the parallel pair constructed from `f` and `g` at `zero` yields the object `X`.\n\nSo, the lemma is stating that, within the framework of category theory, when you construct a parallel pair from two morphisms between the same objects and evaluate its object part at `zero`, the result is simply the original object `X`."}
{"id": 71, "formal_statement": "theorem dummy {s t : Cofork f g} (hs : IsColimit s) : s.œÄ ‚â´ hs.desc t = t.œÄ :=", "nl_statement": "The theorem stated concerns category theory, specifically within the context of a mathematical structure known as a cofork in the domain of limits and colimits. The theorem can be phrased in natural language as follows:\n\n\"In a category, given two coforks 's' and 't' of a pair of parallel morphisms 'f' and 'g', if 's' is a colimit cofork, then the composition of the unique morphism (œÄ) from the vertex of 's' to any object, with the unique colimiting morphism (desc) from the vertex of 's' to the vertex of 't', is equal to the unique morphism (œÄ) from the vertex of 't' to any object.\"\n\nIn simpler terms, this theorem states that in a specific category theory setup involving a structure known as a cofork, there is a certain consistency in how morphisms (functions between objects in category theory) are composed."}
{"id": 72, "formal_statement": "theorem dummy : (R ‚àô x) = ‚ä• ‚Üî x = 0 :=", "nl_statement": "The statement to be discussed is: \"The span of a singleton set containing an element `x` in a ring `R` is equal to the trivial submodule (denoted as `‚ä•`, or the 'bottom' element in the lattice of submodules) if and only if `x` is the zero element of the ring.\""}
{"id": 73, "formal_statement": "theorem dummy (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=", "nl_statement": "The given theorem states that composing two comap (preimage filter) operations on a filter \\(G\\) with functions \\(\\phi\\) and \\(\\psi\\) is equivalent to another composition of comap operations on the same filter \\(G\\) but with different functions \\(\\theta\\) and \\(\\rho\\). In formula terms, it says \\(\\text{comap}\\ \\phi (\\text{comap}\\ \\psi G) = \\text{comap}\\ \\theta (\\text{comap}\\ \\rho G)\\)."}
{"id": 74, "formal_statement": "theorem dummy : DifferentiableOn ùïú iso s :=", "nl_statement": "The theorem states that a function, denoted as `iso`, is differentiable on a set `s` under the condition that `iso` is a continuous linear equivalence. In mathematical terms, a continuous linear equivalence is a function that is both a linear isomorphism (meaning it is a linear map that is invertible, and its inverse is also a linear map) and continuous, with a continuous inverse. The set `s` is within a field `ùïú`, which typically represents the real numbers (‚Ñù) or complex numbers (‚ÑÇ). The statement `DifferentiableOn ùïú iso s` asserts that `iso` is differentiable at every point in the set `s`."}
{"id": 75, "formal_statement": "theorem dummy : Admissible (E' 4) :=", "nl_statement": "The statement you've shared, `theorem admissible_E'4 : Admissible (E' 4)`, declares a theorem named `admissible_E'4`. This theorem asserts that a certain entity, denoted as `E' 4`, is admissible. In the context of theorem proving and formal verification, \"admissible\" often refers to a property or a predicate that a given object, function, or procedure satisfies under certain conditions. Without more specific context about `E' 4`, we can understand it as some mathematical or logical entity whose admissibility is under consideration."}
{"id": 76, "formal_statement": "theorem dummy (s : Finset Œ±) : Set.Countable (‚Üës : Set Œ±) :=", "nl_statement": "The statement given is about a mathematical property related to finite sets and countability. Specifically, it asserts that the set obtained from a finite set (in Lean4 represented as `Finset`) is countable. In more intuitive terms, it says that if you take any finite set (which is a set with a limited number of elements) and then consider it as a 'normal' set (outside of the specific structure of `Finset`), this resulting set will have a property called countability. Countability, in the realm of mathematics, means that the elements of the set can be matched one-to-one with the elements of some subset of the natural numbers, thereby establishing that the set is not too large, in a certain sense."}
{"id": 77, "formal_statement": "theorem dummy : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=", "nl_statement": "The given statement is a theorem in the context of mathematical or computer science logic, using the Lean4 theorem prover syntax. The theorem states that the function `inl` (which stands for \"inject left\") from a type `A` to the product type `A √ó B` is identical to a function that takes an element `x` of type `A` and returns a pair `(x, 0)`, where `0` is an element of type `B`. This assumes an appropriate definition of `0` in the context of `B`, such as a neutral element or a default value."}
{"id": 78, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) {o : Part Œ±} : ‚àÄ {a}, a ‚àà o ‚Üí f a ‚àà map f o | _, ‚ü®_, rfl‚ü© => ‚ü®_, rfl‚ü© :=", "nl_statement": "The theorem states that if you have a function `f` from type `Œ±` to type `Œ≤`, and an object `o` of type `Part Œ±` (which means `o` is a partial element of type `Œ±`, potentially representing a computation that may not return a result), then for any element `a` of type `Œ±` that is part of `o`, the function `f` applied to `a` (`f a`) is part of the mapped object `map f o` (which represents applying `f` to the result of the computation represented by `o`, if there is one)."}
{"id": 79, "formal_statement": "theorem dummy : ‚Ñµ‚ÇÄ ‚â§ ùî† :=", "nl_statement": "The theorem named `aleph0_le_continuum` asserts that the cardinality of the set of all natural numbers (denoted as ‚Ñµ‚ÇÄ, or \"aleph null\") is less than or equal to the cardinality of the continuum (denoted as ùî†). The continuum typically refers to the set of real numbers or its cardinality."}
{"id": 80, "formal_statement": "theorem dummy : sinh x ^ 2 = cosh x ^ 2 - 1 :=", "nl_statement": "The theorem states that the square of the hyperbolic sine of any real number \\(x\\) (denoted as \\(\\sinh(x)^2\\)) is equal to the square of the hyperbolic cosine of that same number \\(x\\) (denoted as \\(\\cosh(x)^2\\)) minus 1. This is a fundamental identity in hyperbolic trigonometry, analogous to the Pythagorean identity in circular trigonometry."}
{"id": 81, "formal_statement": "theorem dummy : Submodule.fst R M M‚ÇÇ ‚äî Submodule.snd R M M‚ÇÇ = ‚ä§ :=", "nl_statement": "The theorem `fst_sup_snd` states that the supremum (join) of the first and second submodules of a module, when considered over a ring R and modules M and M‚ÇÇ, is the entire module (denoted as ‚ä§, which represents the top element in the lattice of submodules, i.e., the whole module itself)."}
{"id": 82, "formal_statement": "theorem dummy (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f :=", "nl_statement": "The statement concerns a scenario in mathematical category theory, specifically within the context of limits and image factorization. The theorem, named `Image.lift_fac`, asserts that given a monomorphism factorisation of a morphism \\(f\\), named `F'`, the composite of the morphism obtained by lifting \\(f\\) through `F'`'s factorisation, followed by `F'`'s monomorphism `m`, is equal to the canonical morphism `Œπ` from the image of \\(f\\)."}
{"id": 83, "formal_statement": "theorem dummy (f : Œπ ‚Üí Œ±) : Monovary f f :=", "nl_statement": "The statement provided is about a mathematical concept referred to as \"monovary.\" While the term \"monovary\" isn't standard in mathematical literature, based on the context and structure of the statement, it seems to refer to a property of a function where, given two inputs, there's a consistent ordering relationship between their outputs. The statement `monovary_self (f : Œπ ‚Üí Œ±) : Monovary f f` declares a theorem named `monovary_self` about a function `f` that maps from some type `Œπ` to another type `Œ±`. The theorem asserts that the function `f` satisfies the monovary property when compared with itself."}
{"id": 84, "formal_statement": "theorem dummy : @WellFounded NatOrdinal (¬∑ < ¬∑) :=", "nl_statement": "The given theorem states that the \"<\" (less than) relation on natural numbers is well-founded. In simpler terms, it asserts that any non-empty set of natural numbers has a least element according to this relation. This is a foundational principle in mathematics, ensuring that there are no infinite descending chains of natural numbers, which supports the concept of mathematical induction and recursive definitions."}
{"id": 85, "formal_statement": "theorem dummy (x : ùî∏) : IsUnit (exp ùïÇ x) :=", "nl_statement": "The statement `isUnit_exp (x : ùî∏)` asserts that the exponential of any element `x` in a given algebraic structure `ùî∏` is a unit. In mathematical terms, a \"unit\" in this context means an element that has a multiplicative inverse within the same structure, which implies that the exponential of `x` does not only exist but also has an inverse, ensuring it can be \"undone\" by multiplication with this inverse."}
{"id": 86, "formal_statement": "theorem dummy : @prod Œ± _ 0 = 1 :=", "nl_statement": "The theorem named `prod_zero` asserts that the product of an empty multiset (a collection of elements that can include duplicates, similar to a set but without the restriction of unique elements) in any given type `Œ±` is `1`. This is a generalization that applies regardless of the specific type `Œ±`, as long as it's a type where the concept of \"product\" makes sense (for example, numbers)."}
{"id": 87, "formal_statement": "theorem dummy (h : Isometry f) : LipschitzWith 1 f :=", "nl_statement": "The statement is about a property of a function \\(f\\) that is an isometry. The theorem states that if \\(f\\) is an isometry, then it is also Lipschitz continuous with a Lipschitz constant of 1. This means that \\(f\\) does not stretch distances by more than a factor of 1."}
{"id": 88, "formal_statement": "theorem dummy {B C : V} (f : B ‚ü∂ C) [Mono f] : Exact (0 : 0 ‚ü∂ B) f :=", "nl_statement": "The theorem named `exact_zero_mono` is about a specific scenario in category theory, particularly dealing with the concept of exact sequences. In this context, it concerns objects `B` and `C` within a category `V` and a morphism `f` from `B` to `C`. The theorem asserts that if `f` is a monomorphism (injective on the level of morphisms), then the sequence formed by the zero morphism (a morphism that sends all elements to a zero object, if one exists, in the category) from the zero object `0` to `B`, followed by `f` to `C`, is exact at `B`."}
{"id": 89, "formal_statement": "theorem dummy (f : Perm Œ±) (x) : f‚Åª¬π (f x) = x :=", "nl_statement": "The statement to be proven is that for any permutation `f` of a set and for any element `x` of that set, applying the inverse of `f` to the result of applying `f` to `x` yields `x` itself. In simpler terms, if you shuffle a set in a certain way (`f`), and then shuffle it back (`f‚Åª¬π`), you end up with the original arrangement for any chosen element `x`."}
{"id": 90, "formal_statement": "theorem dummy {a : Œ±} {s : Finset Œ±} : a ‚àà s ‚Üî a ‚àà s.1 :=", "nl_statement": "The theorem in question concerns an element `a` of type `Œ±` and a finite set `s` of type `Finset Œ±`. The statement to prove is that `a` belongs to the set `s` if and only if `a` belongs to the underlying list (`s.1`) of the finite set `s`."}
{"id": 91, "formal_statement": "theorem dummy : cosh x < cosh y ‚Üî |x| < |y| :=", "nl_statement": "The theorem states that the hyperbolic cosine of x is less than the hyperbolic cosine of y if and only if the absolute value of x is less than the absolute value of y. This is represented in mathematical language as \"cosh x < cosh y ‚Üî |x| < |y|\"."}
{"id": 92, "formal_statement": "theorem dummy {a : Œ±} (x : Œ±) (hx : x ‚àà factors a) : Prime x :=", "nl_statement": "The theorem states that if `x` is a factor of `a` (denoted as `x ‚àà factors a`), then `x` must be a prime number."}
{"id": 93, "formal_statement": "theorem dummy {a b : Œ±} : ofAdd a ‚â§ ofAdd b ‚Üî a ‚â§ b :=", "nl_statement": "The theorem states that for any two elements \\(a\\) and \\(b\\) of a certain type \\(\\alpha\\), the relation \\( \\text{ofAdd } a \\leq \\text{ofAdd } b \\) is equivalent to \\( a \\leq b \\).\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 94, "formal_statement": "theorem dummy (m : M) {a b : N} (ab : r (Œº m a) (Œº m b)) : r a b :=", "nl_statement": "The statement provided can be understood as a formal mathematical theorem concerning relations and actions on certain sets or structures, typically found in the context of algebra or formal logic. Specifically, it deals with a scenario where if a certain relation `r` holds between the images of two elements `a` and `b` under an action `Œº` by an element `m`, then the relation `r` also holds directly between `a` and `b`. \n\nIn more detailed terms, given:\n- A set or group `M`,\n- A set `N`,\n- A relation `r` that applies to elements of `N`,\n- An action `Œº` that takes an element of `M` and an element of `N`, and returns another element of `N`,\n\nthe theorem asserts that if for some `m` in `M`, and for any elements `a` and `b` in `N`, the relation `r` holds between the result of acting on `a` and `b` with `m` (i.e., `r(Œº(m, a), Œº(m, b))` is true), then the relation `r` must also hold directly between `a` and `b` (i.e., `r(a, b)` is true)."}
{"id": 95, "formal_statement": "theorem dummy : IsTorsionBySet R (torsionBySet R M s) s :=", "nl_statement": "The theorem named `torsionBySet_isTorsionBySet` states that for a given ring `R`, a module `M` over `R`, and a set `s`, the subset `torsionBySet R M s` indeed satisfies the property of being a torsion set by the set `s`. This property essentially means that every element in the `torsionBySet R M s` subset is torsioned by the set `s`, indicating that there exists a scalar in `s` such that when this scalar multiplies the element, the result is zero in the context of the module operation."}
{"id": 96, "formal_statement": "theorem dummy (a b c : Œ±) : a ‚äî b ‚äî c = a ‚äî c ‚äî (b ‚äî c) :=", "nl_statement": "The statement (theorem) being considered here deals with an algebraic structure where the operation `‚äî` is defined. This operation is generally understood to be a \"join\" operation in the case of lattices - a mathematical structure where every two elements have a least upper bound (join) and a greatest lower bound (meet). The statement is about distributivity of the join operation over itself when you have three elements, `a`, `b`, and `c` of some type `Œ±`. The type `Œ±` is assumed to be a lattice or to at least support the operation `‚äî`.\n\nIn a natural language, the theorem can be stated like this:\n\n\"In any lattice (or similar structure) for any three elements `a`, `b`, and `c`, the join of `a` with the join of `b` and `c` is equal to the join of `a` with `c` joined with the join of `b` with `c`.\"\n\nMathematically, this can be written as:\n`a ‚äî (b ‚äî c) = (a ‚äî c) ‚äî (b ‚äî c)`\n\nThis illustrates a distributive property where joining `b` and `c` before or after joining both to `a` yields the same result."}
{"id": 97, "formal_statement": "theorem dummy (u v w : E) : ‚Äñu / w‚Äñ - ‚Äñv / w‚Äñ ‚â§ ‚Äñu / v‚Äñ :=", "nl_statement": "The problem statement is about comparing the norms (or magnitudes) of two different divisions involving vectors (or elements) \\(u\\), \\(v\\), and \\(w\\) in a vector space \\(E\\). Specifically, it states that the difference between the norm of \\(u\\) divided by \\(w\\) and the norm of \\(v\\) divided by \\(w\\) is less than or equal to the norm of \\(u\\) divided by \\(v\\). In mathematical terms, this can be expressed as:\n\nGiven three elements \\(u\\), \\(v\\), and \\(w\\) in a vector space \\(E\\), the inequality \\(\\|u / w\\| - \\|v / w\\| \\leq \\|u / v\\|\\) holds."}
{"id": 98, "formal_statement": "theorem dummy : (fun x => x + a) ‚Åª¬π' Ioc b c = Ioc (b - a) (c - a) :=", "nl_statement": "The theorem named `preimage_add_const_Ioc` states that the preimage of an open-closed interval `(b, c]` under the function `f(x) = x + a` is equal to the interval `(b - a, c - a]`."}
{"id": 99, "formal_statement": "theorem dummy (I : Ideal R) : annihilator I * I = ‚ä• :=", "nl_statement": "The statement given describes a theorem concerning an algebraic structure, specifically within the context of ring theory and ideal theory. The theorem is about the annihilator of an ideal in a ring and its multiplication with the ideal itself. The statement asserts that multiplying the annihilator of an ideal by the ideal results in the trivial ideal, denoted by ‚ä• (bottom), which contains only the additive identity (zero in the context of rings).\n\nTo unpack this a bit, let's understand the terms:\n- An **ideal** in ring theory is a subset of a ring that is closed under addition and under multiplication by any element of the ring.\n- The **annihilator** of an ideal \\(I\\) in a ring \\(R\\) is the set of all elements in \\(R\\) that, when multiplied with any element of \\(I\\), yield the zero element of the ring. Symbolically, \\(\\text{annihilator}(I) = \\{r \\in R \\mid \\forall i \\in I, r \\cdot i = 0\\}\\).\n- The symbol \\(*\\) denotes the multiplication of ideals, which is defined as the set of all finite sums of products of elements from each ideal.\n- \\(‚ä•\\) denotes the trivial ideal, which contains only the zero element."}
{"id": 100, "formal_statement": "theorem dummy : id.comp f = f :=", "nl_statement": "The theorem presented, named `id_comp`, asserts that composing any linear map `f` with the identity map (`id`) results in the linear map `f` itself. This is a fundamental property in linear algebra, showcasing that the identity map acts as a neutral element in the composition of linear maps."}
{"id": 101, "formal_statement": "theorem dummy {p : E √ó F} : ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p :=", "nl_statement": "The statement concerns a mathematical concept related to differential calculus in the context of multivariable calculus. It states that the function that projects onto the first component of a pair (from a product space E √ó F to E) is continuously differentiable at a point \\(p\\) in \\(E √ó F\\). This is formalized as \"ContDiffAt ùïú n (Prod.fst : E √ó F ‚Üí E) p\", where \\(ùïú\\) represents the underlying field (commonly the real numbers \\(\\mathbb{R}\\)), \\(n\\) indicates the degree of differentiability, \\(E\\) and \\(F\\) are types representing spaces, \\(Prod.fst\\) is the function that takes a pair \\((e, f)\\) and returns its first component \\(e\\), and \\(p\\) is a specific point in \\(E √ó F\\)."}
{"id": 102, "formal_statement": "theorem dummy (i : m) (j : n) : stdBasisMatrix i j (0 : Œ±) = 0 :=", "nl_statement": "The statement asserts that for any given indices \\(i\\) and \\(j\\), and for the field \\(Œ±\\) where \\(0\\) is an element of \\(Œ±\\), the standard basis matrix (\\(\\text{stdBasisMatrix}\\)) entry at position \\(i, j\\) with value \\(0\\) in \\(Œ±\\) is a zero matrix."}
{"id": 103, "formal_statement": "theorem dummy : (ofFintype f h).support = Function.support f :=", "nl_statement": "The theorem named `support_ofFintype` asserts that the support of a probability mass function (PMF) obtained from a finite type (denoted by `ofFintype f h`) is identical to the support of the function `f` itself. Here, `support` refers to the set of elements where the function (in this case, `f`) does not yield a zero value. The notation `Function.support f` denotes this concept of support specifically for the function `f`, while `(ofFintype f h).support` refers to the support of the PMF derived from `f` under the assumption that `f`'s domain is a finite type, as indicated by `h`."}
{"id": 104, "formal_statement": "theorem dummy [IsNoetherianRing A] {f : A ‚Üí‚Çê[R] B} : f.FiniteType ‚Üî f.FinitePresentation :=", "nl_statement": "The statement concerns a property of a homomorphism \\(f\\) from a ring \\(A\\) to another ring \\(B\\), given that \\(A\\) is a Noetherian ring. The property in question is whether \\(f\\) being of finite type is equivalent to \\(f\\) having a finite presentation."}
{"id": 105, "formal_statement": "theorem dummy (hxy : x ‚â° y [SMOD U]) (c : R) : c ‚Ä¢ x ‚â° c ‚Ä¢ y [SMOD U] :=", "nl_statement": "The theorem we're looking at concerns a scenario in modular arithmetic, specifically dealing with scalar multiplication in the context of equivalence classes modulo some subgroup \\(U\\) of a ring \\(R\\). It states that if two elements \\(x\\) and \\(y\\) of the ring are equivalent modulo \\(U\\), denoted \\(x \\equiv y \\, [SMOD \\, U]\\), then for any scalar \\(c\\) from \\(R\\), the product of \\(c\\) and \\(x\\) is equivalent modulo \\(U\\) to the product of \\(c\\) and \\(y\\). In simpler terms, if you multiply \\(x\\) and \\(y\\) (which are already equivalent under a specific modulo) by the same number \\(c\\), their products will also be equivalent under the same modulo."}
{"id": 106, "formal_statement": "theorem dummy (X : C) : IsPullback (0 : 0 ‚ü∂ X) (0 : (0 : C) ‚ü∂ 0) (ùüô X) (0 : 0 ‚ü∂ X) := { w :=", "nl_statement": "This theorem asserts that in any category \\(C\\), given the object \\(X\\), there exists a pullback where both of the pullback's projection maps are the zero morphism from the terminal object 0 to \\(X\\) and from the terminal object 0 to itself, respectively, and the other two morphisms involved are the identity morphism on \\(X\\) and the zero morphism from the terminal object to \\(X\\). The statement formalizes a specific scenario in category theory related to the construction of pullbacks, emphasizing the role of terminal objects and zero morphisms in such constructions."}
{"id": 107, "formal_statement": "theorem dummy (h : ‚àÄ x, e x = e' x) : e = e' :=", "nl_statement": "The theorem states that if for every element x, the function e applied to x equals the function e' applied to x, then the functions e and e' themselves are equal.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 108, "formal_statement": "theorem dummy : coprod (inl R M M‚ÇÇ) (inr R M M‚ÇÇ) = LinearMap.id :=", "nl_statement": "The statement concerns the concept of direct sums (coproducts) in the context of linear algebra. It claims that for any given linear maps from a vector space \\(R\\) to vector spaces \\(M\\) and \\(M_2\\), respectively, denoted by \\(inl\\) for the injection into the first component and \\(inr\\) for the injection into the second component, the coproduct (or direct sum) of these two maps is equivalent to the identity map on the vector space formed by the direct sum of \\(M\\) and \\(M_2\\)."}
{"id": 109, "formal_statement": "theorem dummy : 1 < a‚Åª¬π ‚Üî a < 1 :=", "nl_statement": "The theorem in question states a condition about the inverse of a number, specifically, it deals with when the inverse of a number is greater than 1. Formally, it says that \"the inverse of a (denoted as \\(a^{-1}\\)) is greater than 1 if and only if \\(a\\) is less than 1.\""}
{"id": 110, "formal_statement": "theorem dummy (x : R) : (C x).roots = 0 :=", "nl_statement": "The theorem states that for any real number \\(x\\), the set of roots of the constant polynomial \\(C(x)\\) is empty."}
{"id": 111, "formal_statement": "theorem dummy {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : IsIso f.unop ‚Üî IsIso f :=", "nl_statement": "The theorem we are looking at is in the context of category theory, specifically dealing with opposite categories. It states that for any two objects \\(X\\) and \\(Y\\) in the opposite category \\(C^{op}\\), a morphism \\(f : X \\to Y\\) in \\(C^{op}\\) is an isomorphism if and only if its unopposite \\(f.unop\\) (which is a morphism in the original category \\(C\\)) is an isomorphism."}
{"id": 112, "formal_statement": "theorem dummy : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c) :=", "nl_statement": "The theorem states that if you take an open interval between two points b and c (denoted as Ioo b c, where Ioo stands for an open interval), and then add a constant value a to every point within that interval, the result is an open interval from (a + b) to (a + c)."}
{"id": 113, "formal_statement": "theorem dummy [FiniteIndex H] (h : H ‚â§ K) : FiniteIndex K :=", "nl_statement": "The statement concerns the concept of finite index in the context of subgroups. Specifically, it asserts that if \\( H \\) is a subgroup with a finite index and \\( H \\) is a subgroup of \\( K \\) (denoted \\( H \\leq K \\)), then \\( K \\) also has a finite index."}
{"id": 114, "formal_statement": "theorem dummy (hc : 0 < c) : b / c < a ‚Üî b < a * c :=", "nl_statement": "The theorem states that for any three real numbers \\(a\\), \\(b\\), and \\(c\\), with \\(c\\) being greater than zero (\\(0 < c\\)), the inequality \\(b / c < a\\) is equivalent to \\(b < a \\cdot c\\). This means that dividing \\(b\\) by \\(c\\) and comparing the result to \\(a\\) is the same as comparing \\(b\\) directly to the product of \\(a\\) and \\(c\\), given that \\(c\\) is a positive number."}
{"id": 115, "formal_statement": "theorem dummy (E : Set Œ±) {Œ¥ : ‚Ñù} (hŒ¥ : 0 < Œ¥) : thickening Œ¥ E ‚àà ùìùÀ¢ E :=", "nl_statement": "The theorem states that for any set \\(E\\) in a metric space and any positive real number \\(\\delta\\), the thickening of \\(E\\) by \\(\\delta\\) is an element of the neighborhood filter of \\(E\\)."}
{"id": 116, "formal_statement": "theorem dummy {f : ‚àÄ i, Œ∫ i ‚Üí LowerSet Œ±} : (a ‚àà ‚®Ü (i) (j), f i j) ‚Üî ‚àÉ i j, a ‚àà f i j :=", "nl_statement": "The theorem in question can be stated as follows in natural language: \n\n\"Given a family of lower sets `f` indexed by two parameters `i` and `j`, an element `a` belongs to the supremum (least upper bound) of these lower sets if and only if there exists a specific pair of indices `i` and `j` such that `a` is in the lower set `f i j`.\"\n\nHere, a lower set in a partially ordered set is a set that, for every element in it, all lesser elements (according to the partial order) are also in the set. The supremum of a collection of sets is the least set that is an upper bound of all the sets in the collection."}
{"id": 117, "formal_statement": "theorem dummy (v : V) (v‚ÇÅ v‚ÇÇ v‚ÇÉ : V) : ‚à† (v + v‚ÇÅ) (v + v‚ÇÇ) (v + v‚ÇÉ) = ‚à† v‚ÇÅ v‚ÇÇ v‚ÇÉ :=", "nl_statement": "The statement concerns a property of angles in Euclidean geometry. Specifically, it states that if you translate (move without rotating) a triangle by the same vector \\(v\\), the angle formed by three points (\\(v_1, v_2, v_3\\)) remains unchanged even after the translation. In mathematical terms, this is expressed as the angle formed by three points \\(v + v_1\\), \\(v + v_2\\), and \\(v + v_3\\) being equal to the angle formed by the original points \\(v_1, v_2, v_3\\)."}
{"id": 118, "formal_statement": "theorem dummy {a : Œ±} {s t : Set Œ±} (h : s ‚àà ùìù[t] a) : ùìù[s ‚à© t] a = ùìù[t] a :=", "nl_statement": "The theorem `nhdsWithin_inter_of_mem` concerns the topology of a set in the context of neighborhoods within a given set. Specifically, it states that for a point `a` in a space `Œ±`, and two subsets `s` and `t` of that space, if `s` is in the neighborhood of `a` restricted to `t` (denoted as `s ‚àà ùìù[t] a`), then the neighborhood of `a` restricted to the intersection of `s` and `t` (denoted as `ùìù[s ‚à© t] a`) is equal to the neighborhood of `a` restricted to `t` (denoted as `ùìù[t] a`)."}
{"id": 119, "formal_statement": "theorem dummy (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=", "nl_statement": "The theorem named `sqFrom_left` concerns a morphism `f` between two chain complexes `C‚ÇÅ` and `C‚ÇÇ` in homological algebra, where `f` is a homomorphism from `C‚ÇÅ` to `C‚ÇÇ`. The statement involves a particular square (a part of the diagram in homological algebra that illustrates the relationships between different components of these complexes) obtained from the morphism `f` at a specific index `i`. The theorem asserts that the left side of this square, denoted as `(f.sqFrom i).left`, is equal to the action of the morphism `f` at the index `i`, expressed as `f.f i`.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 120, "formal_statement": "theorem dummy : StrictMono (map f) :=", "nl_statement": "The given statement describes a theorem named `map_strictMono_of_injective` which concerns strict monotonicity. In essence, the theorem states that if you have a function `f` that is injective (meaning it maps distinct elements to distinct elements), then the operation of mapping elements through `f` over a structure, specifically a submonoid, is strictly monotone. Strict monotonicity, in this context, means that if you have a certain order in your original set, this order is preserved (and is strict, i.e., no equality for distinct elements) in the transformed set through the function `f`."}
{"id": 121, "formal_statement": "theorem dummy (s t : LowerSet Œ±) : (‚Üë(s / t) : Set Œ±) = s / t :=", "nl_statement": "The theorem `coe_div` concerns the division of two lower sets, `s` and `t`, within a given type `Œ±`. It states that the coercion (type conversion) of the division of these two lower sets to a set of type `Œ±` is equal to the division of the sets themselves. In mathematical terms, if `s` and `t` are lower sets, then converting the result of `s / t` directly to a set of type `Œ±` yields the same result as performing the division operation on `s` and `t` considered as sets of type `Œ±`."}
{"id": 122, "formal_statement": "theorem dummy : ¬¨IsSuccLimit a ‚Üî a ‚àà range (@succ Œ± _ _) :=", "nl_statement": "The statement `not_isSuccLimit_iff'` asserts that a certain element `a` is not a successor limit if and only if `a` is in the range of the successor function. In more intuitive terms, this means that an element is not considered a successor limit precisely when it can be obtained by applying the successor function to some other element."}
{"id": 123, "formal_statement": "theorem dummy {u v : V} {p : G.Walk u v} (h : p.IsEulerian) : p.IsTrail :=", "nl_statement": "Given a graph \\(G\\) with vertices \\(V\\) and a walk \\(p\\) from vertex \\(u\\) to vertex \\(v\\) in \\(G\\), if \\(p\\) is an Eulerian walk (meaning it uses every edge of \\(G\\) exactly once), then \\(p\\) is also a trail (meaning it does not repeat any edges)."}
{"id": 124, "formal_statement": "theorem dummy : s ‚àà falling k ùíú ‚Üî (‚àÉ t ‚àà ùíú, s ‚äÜ t) ‚àß s.card = k :=", "nl_statement": "The statement pertains to a set \\(s\\) belonging to a certain mathematical construction called \"falling\" for a given set \\(\\mathcal{A}\\) and an integer \\(k\\). Specifically, it asserts that \\(s\\) is an element of the \"falling\" of \\(k\\) over \\(\\mathcal{A}\\) if and only if there exists a set \\(t\\) in \\(\\mathcal{A}\\) such that \\(s\\) is a subset of \\(t\\) and the cardinality (the number of elements) of \\(s\\) is exactly \\(k\\)."}
{"id": 125, "formal_statement": "theorem dummy : Odd (m + n) ‚Üî (Odd m ‚Üî Even n) :=", "nl_statement": "The statement deals with the parity (odd or even status) of the sum of two numbers, \\(m + n\\). Specifically, it asserts that the sum \\(m + n\\) is odd if and only if \\(m\\) is odd and \\(n\\) is even, or \\(m\\) is even and \\(n\\) is odd. In simpler terms, for the sum of two numbers to be odd, one of the numbers must be odd, and the other must be even."}
{"id": 126, "formal_statement": "theorem dummy (s‚ÇÅ s‚ÇÇ : Finset Œ±) : (s‚ÇÅ ‚à© s‚ÇÇ).1 = s‚ÇÅ.1 ‚à© s‚ÇÇ.1 :=", "nl_statement": "The statement concerns the intersection of two finite sets, denoted by `s‚ÇÅ` and `s‚ÇÇ`, within some universe `Œ±`. The theorem asserts that the intersection of these two sets, when we look at the underlying elements (denoted by `.1`), is equivalent to the intersection of the elements of `s‚ÇÅ` and `s‚ÇÇ` directly."}
{"id": 127, "formal_statement": "theorem dummy (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=", "nl_statement": "The theorem named `prodExtendRight_apply_eq` asserts that when a certain function, denoted `prodExtendRight`, is applied to a pair consisting of elements `a` (of some type) and `b` (of type Œ≤‚ÇÅ), the result is a new pair. The first element of this new pair is the same `a`, and the second element is the result of applying some function `e` to `b`. In other words, this theorem is about transforming the second element of a given pair `(a, b)` by applying a function `e` to it, while keeping the first element `a` unchanged."}
{"id": 128, "formal_statement": "theorem dummy [DecidableEq Œ±] : (s‚ÇÅ ‚à™ s‚ÇÇ) ‚Ä¢ t = s‚ÇÅ ‚Ä¢ t ‚à™ s‚ÇÇ ‚Ä¢ t :=", "nl_statement": "The theorem in question states that for any two sets \\(s_1\\) and \\(s_2\\), and another set \\(t\\), when you perform a scalar multiplication of the union of \\(s_1\\) and \\(s_2\\) with \\(t\\), the result is the same as taking the scalar multiplication of each set \\(s_1\\) and \\(s_2\\) with \\(t\\) and then taking the union of the results. Here, scalar multiplication refers to the operation applied between elements of the sets and \\(t\\), and the context suggests we're dealing with operations in a vector space or a similar algebraic structure. The operation \"‚Ä¢\" signifies this scalar multiplication or a similar operation, depending on the underlying algebraic structure."}
{"id": 129, "formal_statement": "theorem dummy : PowerSeries.constantCoeff R œÜ = œÜ.coeff 0 :=", "nl_statement": "The statement in question is about power series in a mathematical context, specifically within the framework of the Lean4 theorem prover. The theorem named `constantCoeff_coe` asserts that the constant coefficient of a power series `œÜ` over a ring `R` is equal to the coefficient of `œÜ` at index 0. This can be seen as addressing a fundamental property of power series, where the constant term plays a crucial role in various mathematical analyses and operations."}
{"id": 130, "formal_statement": "theorem dummy : s * t ‚äÜ u ‚Üî ‚àÄ b ‚àà t, op b ‚Ä¢ s ‚äÜ u :=", "nl_statement": "The problem statement revolves around the relation between sets \\(s\\), \\(t\\), and \\(u\\), specifically focusing on the product of two sets \\(s\\) and \\(t\\), and whether this product is a subset of a third set \\(u\\). The theorem `mul_subset_iff_right` expresses this relationship as an equivalence (\\(‚äÜ\\)), asserting that the product of \\(s\\) and \\(t\\) is a subset of \\(u\\) if and only if for every element \\(b\\) in \\(t\\), the operation of \\(b\\) scaling \\(s\\) (denoted by \\(op b ‚Ä¢ s\\)) results in a subset of \\(u\\)."}
{"id": 131, "formal_statement": "theorem dummy {x : PGame} : ‚àÄ j, x ‚ßè x.moveRight j :=", "nl_statement": "The theorem we're discussing asserts that for any given position `x` in a certain two-player game (presumably a part of combinatorial game theory and represented as a type `PGame`), and for any legal move `j` that shifts the game to a \"right\" position from `x` (denoted as `x.moveRight j`), the shifted position is strictly less favorable to the player making the move. This is formalized as `‚àÄ j, x ‚ßè x.moveRight j`, where `‚ßè` signifies a strictly less favorable or losing position for the moving player."}
{"id": 132, "formal_statement": "theorem dummy : ‚Äñsoln - a‚Äñ < ‚ÄñF.derivative.eval a‚Äñ :=", "nl_statement": "The statement to be proven is that the norm of the difference between a solution `soln` and a point `a` is less than the norm of the derivative of a function `F` evaluated at `a`."}
{"id": 133, "formal_statement": "theorem dummy {s : Set M} (hs : s.Countable) : CG (closure L s) :=", "nl_statement": "The theorem concerns a mathematical structure `M` and a set `s` within `M`. It states that if `s` is a countable set, then the closure of `s` under some language `L` is countably generated (`CG`). In formal terms, `CG` refers to a property where a set can be described or generated by a countably infinite set or a smaller set. The language `L` here refers to a formal language used to describe certain properties or operations within the structure `M`. The `closure` of a set `s` under `L` refers to the smallest closed set that contains `s` and is closed under the operations or relations described by `L`."}
{"id": 134, "formal_statement": "theorem dummy : finSuccEquivLast (Fin.last n) = none :=", "nl_statement": "The statement at hand concerns a mathematical construct, likely from the realm of type theory or formal mathematics, involving a function or mapping named `finSuccEquivLast`. Specifically, it pertains to the behavior of this function when applied to a particular value, `Fin.last n`. The theorem claims that `finSuccEquivLast` applied to `Fin.last n` yields `none`."}
{"id": 135, "formal_statement": "theorem dummy (f : ‚àÄ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one :=", "nl_statement": "The theorem `bsup_one` is about calculating the supremum (least upper bound) of a set of ordinals indexed by ordinals less than 1. It states that for any function `f` that assigns an ordinal to each ordinal less than 1, the supremum of `f` when the index set is restricted to ordinals less than 1 is equal to `f(0)`. In simpler terms, because the only ordinal less than 1 is 0, the supremum of such a set is just the value of the function at 0."}
{"id": 136, "formal_statement": "theorem dummy : a ^ 2 = b ^ 2 ‚Üî a = b ‚à® a = -b :=", "nl_statement": "The statement we're examining asserts that the square of \\(a\\) being equal to the square of \\(b\\) (\\(a^2 = b^2\\)) implies that \\(a\\) is either equal to \\(b\\) or \\(a\\) is the negative of \\(b\\) (\\(a = b\\) or \\(a = -b\\))."}
{"id": 137, "formal_statement": "theorem dummy : orderOf (1 : G) = 1 :=", "nl_statement": "The theorem `orderOf_one` states that the order of the element 1 in a group G is 1."}
{"id": 138, "formal_statement": "theorem dummy (l : Filter Œ±) : ‚ãÇ‚ÇÄ { s | s ‚àà ùìù l } = Iic l :=", "nl_statement": "This theorem pertains to the field of topology within mathematics, specifically dealing with the behavior of filters and neighborhoods in a topological space. The statement of the theorem is as follows: the intersection of all sets that belong to the neighborhood of a filter `l` is equal to the set of all elements less than or equal to `l` (`Iic l`)."}
{"id": 139, "formal_statement": "theorem dummy : ‚Üë(‚ä§ : ConvexCone ùïú E) = (univ : Set E) :=", "nl_statement": "The statement to be translated is a theorem about convex cones in a certain mathematical setting, written in the syntax of the Lean4 theorem prover. Specifically, the theorem states that the coercion (type conversion) of the top (‚ä§) element in the type `ConvexCone ùïú E` to a set of elements in `E` is equal to the universal set of `E`."}
{"id": 140, "formal_statement": "theorem dummy : ùìù (‚àû : OnePoint X) = map (‚Üë) (coclosedCompact X) ‚äî pure ‚àû :=", "nl_statement": "The statement given, `nhds_infty_eq`, is about the neighborhood filter of the point at infinity in a topological space extended by a point at infinity, commonly referred to as the Alexandroff extension. Specifically, it claims that the neighborhood filter of infinity in this extended space is equal to the supremum (least upper bound) of the image under the inclusion map of the filter of coclosed compact sets in the original space and the pure filter at infinity."}
{"id": 141, "formal_statement": "theorem dummy {X Y : C} (a b c : X ‚ü∂ Y) : a + b + c = a + (b + c) :=", "nl_statement": "The statement in question is a mathematical theorem concerning the associativity of addition within a certain context, possibly within a category in category theory. The specific entities involved are `X` and `Y`, which might be objects in a category, and `a`, `b`, and `c`, which are morphisms (or arrows) from `X` to `Y`. The theorem asserts that the operation of addition on these morphisms is associative, meaning that when you add three of them together, it doesn't matter how you group the additions; the result will be the same. In symbolic terms, this is expressed as \\(a + (b + c) = (a + b) + c\\)."}
{"id": 142, "formal_statement": "theorem dummy : Infinite (Icc a b) :=", "nl_statement": "The theorem named `Icc.infinite` asserts that the closed interval `[a, b]` (denoted by `Icc a b` in Lean4, where `Icc` stands for Interval Closed-Closed, indicating both endpoints are included) is infinite under certain conditions."}
{"id": 143, "formal_statement": "theorem dummy {s t : Set Œ±} : ((‚Üë) : s ‚Üí Œ±) ‚Åª¬π' t = ‚àÖ ‚Üî s ‚à© t = ‚àÖ :=", "nl_statement": "The statement given can be translated into natural language as a problem in set theory. The theorem states that the preimage of a set \\(t\\) under the canonical embedding function from a subset \\(s\\) to a universal set \\(\\alpha\\) is empty if and only if the intersection of \\(s\\) and \\(t\\) is empty. In more intuitive terms, it's saying that if you take all elements from the subset \\(s\\) that, when mapped into the larger space \\(\\alpha\\), land in \\(t\\), you'll end up with an empty set precisely when \\(s\\) and \\(t\\) have no elements in common."}
{"id": 144, "formal_statement": "theorem dummy (f : A ‚Üí*[n] Œ≤) (h) : mk f h = f :=", "nl_statement": "The statement defines a theorem related to a specific type of mathematical function, specifically a Freiman homomorphism of a certain order `n`, from a set `A` to another set `Œ≤`. The theorem asserts that if you construct a Freiman homomorphism using a function `f` and some condition `h`, then the resulting homomorphism is identical to the original function `f` used in the construction."}
{"id": 145, "formal_statement": "theorem dummy (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ :=", "nl_statement": "The theorem states that for any path \\( \\gamma \\) connecting two points \\( x \\) and \\( y \\), if you reparameterize \\( \\gamma \\) using the identity function (which means you don't actually change the parameterization), then the path remains unchanged."}
{"id": 146, "formal_statement": "theorem dummy {a : M} {x y : MÀ£} : SemiconjBy a ‚Üëx‚Åª¬π ‚Üëy‚Åª¬π ‚Üî SemiconjBy a x y :=", "nl_statement": "The given statement is about a property in a mathematical structure, often involving algebraic operations like multiplication or addition. Specifically, it discusses the concept of \"SemiconjBy,\" which stands for \"semiconjugate by.\" The theorem states a condition under which one element is semiconjugate by another with respect to the inverses of two units in a given structure (likely a group or a monoid, given the context of units and inverses). In more accessible terms, the theorem is about understanding when the action of an element on the inverses of two other elements (considered as units, meaning they have inverses themselves) preserves a certain relational structure compared to acting on the elements directly without taking inverses."}
{"id": 147, "formal_statement": "theorem dummy (a : Œ±) (b : Œ≤) : (single a b).symm = single b a :=", "nl_statement": "The statement at hand concerns a theorem about a mathematical construct called \"single,\" possibly representing a kind of function or mapping within the context of the Lean4 theorem prover environment. The theorem states that if you take a \"single\" mapping from an element `a` of type `Œ±` to an element `b` of type `Œ≤`, and then you find the symmetric (inverse) of this mapping, it will be equal to a \"single\" mapping from `b` to `a`."}
{"id": 148, "formal_statement": "theorem dummy : (Œª_ (ùüô a)).hom = (œÅ_ (ùüô a)).hom :=", "nl_statement": "The statement to be proven, referred to as a theorem, asserts that in a bicategory (a generalization of a category allowing for morphisms between morphisms), the left unitor and the right unitor of the identity morphism of an object are equal. Specifically, it states that the morphism associated with the left unitor applied to the identity morphism of an object \\(a\\) is identical to the morphism associated with the right unitor applied to the same identity morphism of the object \\(a\\)."}
{"id": 149, "formal_statement": "theorem dummy (a : M) {m n : ‚Ñï} (h : m ‚â§ n) : a ^ m * a ^ (n - m) = a ^ n :=", "nl_statement": "The theorem states that for any element \\(a\\) of a monoid \\(M\\) and any natural numbers \\(m\\) and \\(n\\) where \\(m\\) is less than or equal to \\(n\\), the product of \\(a\\) raised to the power of \\(m\\) and \\(a\\) raised to the power of \\(n - m\\) is equal to \\(a\\) raised to the power of \\(n\\). In mathematical terms, this can be written as: if \\(m \\leq n\\), then \\(a^m \\cdot a^{n - m} = a^n\\)."}
{"id": 150, "formal_statement": "theorem dummy (l : Œπ ‚Üí‚ÇÄ R) : h.coeffs (DualBases.lc e l) = l :=", "nl_statement": "The theorem `coeffs_lc` asserts that for any linear combination `l` of elements from a base indexed by `Œπ` over a ring `R`, the coefficient function `h.coeffs` applied to the linear combination `DualBases.lc e l` yields `l` itself."}
{"id": 151, "formal_statement": "theorem dummy {m n : ‚Ñï} : (‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n :=", "nl_statement": "The theorem states that for any two natural numbers `m` and `n`, the integer cast of `m` divides the integer cast of `n` if and only if `m` divides `n` in the natural numbers. This can be formally represented as `(‚Üëm : ‚Ñ§) ‚à£ ‚Üën ‚Üî m ‚à£ n`, where `‚Üëm` and `‚Üën` denote the casting of `m` and `n` to integers, respectively, and `‚à£` denotes the division relation (divisibility)."}
{"id": 152, "formal_statement": "theorem dummy (c : F) : fderiv ùïú (fun y => f y + c) x = fderiv ùïú f x :=", "nl_statement": "The theorem `fderiv_add_const` is about the Frechet derivative, a concept from calculus that generalizes the derivative to functions between Banach spaces. The statement asserts that the Frechet derivative at a point `x` of the function that adds a constant `c` to another function `f` is the same as the Frechet derivative of the function `f` itself at `x`. In simpler terms, adding a constant to a function does not change its derivative."}
{"id": 153, "formal_statement": "theorem dummy (x : A) (n : ‚Ñï) : œÜ (x ^ n) = œÜ x ^ n :=", "nl_statement": "The theorem states that for a given algebraic homomorphism \\( \\phi \\) from a structure \\( A \\) to another structure (implied but not explicitly stated, typically another algebraic structure like a group, ring, or field), and for any element \\( x \\) of \\( A \\) and any natural number \\( n \\), the homomorphism \\( \\phi \\) applied to \\( x \\) raised to the power of \\( n \\) is equal to \\( \\phi(x) \\) raised to the power of \\( n \\). In simpler terms, this theorem asserts that the homomorphism preserves exponentiation."}
{"id": 154, "formal_statement": "theorem dummy : ball 1 Œ¥ / s = thickening Œ¥ s‚Åª¬π :=", "nl_statement": "The theorem stated is about the relationship between a specific mathematical function called \"ball\" when applied with certain parameters, and another function or concept referred to as \"thickening\". Specifically, the theorem says that the result of dividing \"ball 1 Œ¥\" by \"s\" is equivalent to \"thickening Œ¥ s‚Åª¬π\". Here, \"Œ¥\" and \"s\" are variables, and \"s‚Åª¬π\" denotes the multiplicative inverse of \"s\"."}
{"id": 155, "formal_statement": "theorem dummy (h : f ‚â§ id) (n : ‚Ñï) : f^[n] ‚â§ id :=", "nl_statement": "The statement given can be translated into natural language as follows:\n\n\"If a function \\(f\\) is less than or equal to the identity function over its domain, then for any non-negative integer \\(n\\), the \\(n\\)-th iterate of \\(f\\) is also less than or equal to the identity function.\"\n\nIn simpler terms, if applying the function \\(f\\) to any element of its domain always produces a result that is less than or equal to applying the identity function (which just returns the same element), then repeatedly applying \\(f\\) \\(n\\) times (where \\(n\\) is a non-negative integer) will also produce results that are less than or equal to just returning the original element."}
{"id": 156, "formal_statement": "theorem dummy : ((¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑) ‚áí (¬∑ ‚â§ ¬∑)) (@prod G _ N _) (@prod G _ N _) :=", "nl_statement": "The statement given in Lean4 syntax describes a theorem related to the product of two mathematical structures, denoted as `@prod G _ N _`. The theorem, named `prod_mono`, asserts that if one element is less than or equal to another element in the first structure (`¬∑ ‚â§ ¬∑`), and similarly in the second structure, then the product of these two structures follows the same relationship of being less than or equal to the product of the corresponding elements in each structure."}
{"id": 157, "formal_statement": "theorem dummy (h : IsMinOn f s a) : IsExtrOn f s a :=", "nl_statement": "The statement asserts that if a function \\(f\\) has a minimum value at a point \\(a\\) within a set \\(s\\), then \\(a\\) is an extremum point of \\(f\\) on \\(s\\). In other words, the point \\(a\\) not only serves as a minimum but also qualifies more broadly as an extremum (either minimum or maximum) within the set \\(s\\)."}
{"id": 158, "formal_statement": "theorem dummy : a ‚àà s ‚àÜ t ‚Üî a ‚àà s ‚àß a ‚àâ t ‚à® a ‚àà t ‚àß a ‚àâ s :=", "nl_statement": "The theorem `mem_symmDiff` states a condition about an element `a` being a part of the symmetric difference between two sets `s` and `t`. Specifically, it presents that `a` belongs to the symmetric difference of `s` and `t` (denoted as `s ‚àÜ t`) if and only if `a` is in `s` and not in `t`, or `a` is in `t` and not in `s`."}
{"id": 159, "formal_statement": "theorem dummy (i j k : ‚Ñ§) : gcd (i * j) (i * k) = natAbs i * gcd j k :=", "nl_statement": "The statement to be proven is: For any three integers \\(i\\), \\(j\\), and \\(k\\), the greatest common divisor (gcd) of the product of \\(i\\) and \\(j\\) with the product of \\(i\\) and \\(k\\) is equal to the product of the absolute value of \\(i\\) and the gcd of \\(j\\) and \\(k\\)."}
{"id": 160, "formal_statement": "theorem dummy : (0 : R[X]).support = ‚àÖ :=", "nl_statement": "The statement concerns a property of polynomials over a ring \\(R\\), specifically dealing with the concept of the \"support\" of a polynomial. The \"support\" of a polynomial is the set of indices of its coefficients that are non-zero. The statement claims that the support of the zero polynomial (denoted \\(0 : R[X]\\)) is the empty set (\\(\\emptyset\\))."}
{"id": 161, "formal_statement": "theorem dummy {m : ‚Ñï+} (hm : p m) : PNat.find h ‚â§ m :=", "nl_statement": "The theorem presented here involves a certain property `p` within the context of positive natural numbers, denoted by `‚Ñï+`. It asserts that for any positive natural number `m` that satisfies the property `p`, the smallest positive natural number that satisfies `p` (found using `PNat.find` given a proof `h` that such a number exists) is less than or equal to `m`."}
{"id": 162, "formal_statement": "theorem dummy : ‚àÄ {a : ‚Ñ§‚àöd}, Nonneg a ‚Üí ‚àÉ x y : ‚Ñï, a = ‚ü®x, y‚ü© ‚à® a = ‚ü®x, -y‚ü© ‚à® a = ‚ü®-x, y‚ü© | ‚ü®(x : ‚Ñï), (y : ‚Ñï)‚ü©, _ => ‚ü®x, y, Or.inl rfl‚ü© | ‚ü®(x : ‚Ñï), -[y+1]‚ü©, _ => ‚ü®x, y + 1, Or.inr <| Or.inl rfl‚ü© | ‚ü®-[x+1], (y : ‚Ñï)‚ü©, _ => ‚ü®x + 1, y, Or.inr <| Or.inr rfl‚ü© | ‚ü®-[_+1], -[_+1]‚ü©, h => False.elim h :=", "nl_statement": "The statement pertains to a theorem about non-negative elements `a` of a certain type `‚Ñ§‚àöd`, which represents integers extended with a square root of a non-specified integer `d`. Specifically, it asserts that for any non-negative element `a` of this type, there exist natural numbers `x` and `y` such that `a` can be represented in one of three possible forms: either as a pair of `x` and `y`, a pair of `x` and the negation of `y`, or a pair of the negation of `x` and `y`."}
{"id": 163, "formal_statement": "theorem dummy (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=", "nl_statement": "The statement to be proved is about finding the divisors of a nonzero natural number \\(n\\). It asserts that when you filter all natural numbers up to \\(n\\) (inclusive) by whether they divide \\(n\\), the result is the same as the set of divisors of \\(n\\)."}
{"id": 164, "formal_statement": "theorem dummy (r : R) (p : GroupSeminorm E) (x : E) : (r ‚Ä¢ p) x = r ‚Ä¢ p x :=", "nl_statement": "The statement concerns a mathematical construct involving a seminorm within a group structure on a vector space \\(E\\), and the operation of scalar multiplication on this seminorm. Specifically, it asserts that for any scalar \\(r\\), any group seminorm \\(p\\) on \\(E\\), and any vector \\(x\\) in \\(E\\), the operation of scalar multiplication on the group seminorm applied to \\(x\\) (\\((r ‚Ä¢ p) x\\)) is equivalent to applying the seminorm \\(p\\) to \\(x\\) and then scaling the result by \\(r\\) (\\(r ‚Ä¢ p x\\))."}
{"id": 165, "formal_statement": "theorem dummy (s : S) (a : ùìú(ùïú, A)) : (s ‚Ä¢ a).toProd = s ‚Ä¢ a.toProd :=", "nl_statement": "The statement involves a mathematical operation within a specific algebraic structure. It asserts that for any scalar `s` from a set `S` and any element `a` from a module `ùìú` over a field `ùïú` with values in a set `A`, the operation of scalar multiplication `s ‚Ä¢ a` followed by an operation `toProd` on the result is equivalent to performing the `toProd` operation on `a` first and then applying scalar multiplication by `s` to the outcome. In simpler terms, it's stating a property about how two operations, scalar multiplication and `toProd`, interact with each other in a mathematical framework.\n\nIn natural language, the explanation of the proof is as follows: The statement that scalar multiplication of an element followed by the `toProd` operation is equivalent to performing `toProd` on the element first and then scalar multiplying is immediately true by how these operations are defined. There's no need for a detailed proof because the operations' definitions make the statement obviously true.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 166, "formal_statement": "theorem dummy : BddAbove s ‚Üí BddAbove (f '' s) | ‚ü®C, hC‚ü© => ‚ü®f C, Hf.mem_upperBounds_image hC‚ü© :=", "nl_statement": "The statement concerns a mathematical property about bounded sets and functions. Specifically, it says that if a set `s` is bounded above, then the image of `s` under a function `f` is also bounded above. This principle reflects a foundational idea in mathematical analysis, particularly relevant in the context of functions and their behavior over sets."}
{"id": 167, "formal_statement": "theorem dummy (a b : Œ±) (m : ‚Ñ§) : toIocMod hp a (b + m ‚Ä¢ p) = toIocMod hp a b :=", "nl_statement": "The theorem `toIocMod_add_zsmul` concerns an operation `toIocMod` in a mathematical context, where `a`, `b` are elements and `m` is an integer (`‚Ñ§`). The operation `p` is also involved, although its nature is not specified, it's implied to be part of the context in which `toIocMod` operates. The theorem states that the result of applying `toIocMod` to `a` and `b + m ‚Ä¢ p` (where `b + m ‚Ä¢ p` denotes `b` plus `m` times `p`) is equal to applying `toIocMod` directly to `a` and `b`."}
{"id": 168, "formal_statement": "theorem dummy : DifferentiableOn ùïú f ‚àÖ :=", "nl_statement": "The statement to be translated is a theorem related to differentiability in mathematical analysis. In natural language, the theorem can be stated as: \"A function 'f' is differentiable on an empty set in the space 'ùïú'.\""}
{"id": 169, "formal_statement": "theorem dummy (f : R ‚Üí+*[M] S) : ‚áë(f : R ‚Üí+[M] S) = f :=", "nl_statement": "The statement given is a theorem in the context of algebra, particularly dealing with a specific kind of homomorphism (a function preserving algebraic structure) between algebraic structures. Specifically, it refers to a \"mul_semiring_action_hom\", which is a homomorphism in a multiplicative semiring action context. The theorem states that the function application of this homomorphism (`f`) is equivalent to the homomorphism itself when it is considered as a function from `R` to `S`. This is a formal way of saying that applying the homomorphism `f` to an element produces the same result as using `f` as a function."}
{"id": 170, "formal_statement": "theorem dummy (n : ‚Ñï) : Fintype.card (Fin n) = n :=", "nl_statement": "The statement in question is about the cardinality of a finite type, specifically the type of finite sequences of natural numbers less than a given number `n`. It asserts that the size (or cardinality) of the set of all such sequences, denoted as `Fin n`, is exactly `n`. In other words, if you create a type that contains all numbers from 0 up to (but not including) `n`, there are `n` such numbers."}
{"id": 171, "formal_statement": "theorem dummy : padicValNat p 1 = 0 :=", "nl_statement": "The theorem states that for any prime number \\(p\\), the \\(p\\)-adic valuation of \\(1\\) is \\(0\\). The \\(p\\)-adic valuation, denoted as `padicValNat`, is a function that measures the highest power of \\(p\\) that divides a given number. In this context, it is applied to the number \\(1\\)."}
{"id": 172, "formal_statement": "theorem dummy : invRev (invRev L‚ÇÅ) = L‚ÇÅ :=", "nl_statement": "The statement provided describes a theorem named `invRev_invRev`, which asserts that if you take an inversion and then reverse operation (denoted as `invRev`) on a list `L‚ÇÅ`, and then apply the same operations (`invRev`) again, you will end up with the original list `L‚ÇÅ`. This is a formal way of stating that performing these two operations twice in a row cancels out their effects, returning the list to its initial state."}
{"id": 173, "formal_statement": "theorem dummy (h : a ‚àà l‚ÇÅ) (l‚ÇÇ : List Œ±) : a ‚àà l‚ÇÅ ‚à™ l‚ÇÇ :=", "nl_statement": "The theorem `mem_union_left` states that if an element `a` is a member of a list `l‚ÇÅ`, then `a` is also a member of the union of list `l‚ÇÅ` and another list `l‚ÇÇ`."}
{"id": 174, "formal_statement": "theorem dummy ‚¶Éf g : Œ± ‚Üí‚Çõ Œ≤‚¶Ñ (H : (f : Œ± ‚Üí Œ≤) = g) : f = g :=", "nl_statement": "The statement concerns the injectivity of a function when cast to a different type. Specifically, it asserts that if two functions `f` and `g`, which map from some type `Œ±` to another type encapsulated in `Œ≤` under a simple function space `Œ± ‚Üí‚Çõ Œ≤`, are equal when viewed as functions from `Œ±` to `Œ≤` (by casting), then they were originally equal as functions in the simple function space `Œ± ‚Üí‚Çõ Œ≤`."}
{"id": 175, "formal_statement": "theorem dummy : Monotone (@Prod.snd Œ± Œ≤) :=", "nl_statement": "The statement asserts the monotonicity of the `snd` function over pairs in the context of two arbitrary types `Œ±` and `Œ≤`. Specifically, it claims that the `snd` function, which takes a pair and returns its second element, is monotone. This means that for any two pairs where the first is less than or equal to the second (in the context of the ordering of their second elements), the second element of the first pair is less than or equal to the second element of the second pair."}
{"id": 176, "formal_statement": "theorem dummy {p : Prop} [Decidable p] : decide p ‚Üî p :=", "nl_statement": "The statement concerns a theorem about decision procedures in the context of propositional logic. It specifically deals with a property of the `decide` function, which is used to make a decision about a proposition `p` (where `p` is a proposition for which a decision procedure exists, indicated by `[Decidable p]`). The theorem states that applying the `decide` function to a proposition `p` is logically equivalent to the proposition `p` itself. This means that if `decide p` returns true, then the proposition `p` is true, and if `decide p` returns false, then the proposition `p` is false.\n\nIn natural language, the theorem and its proof assert that the procedure for deciding the truth of a proposition, when available, is reliable and consistent with the proposition's inherent truth value. This is an important foundation in formal verification and theorem proving, ensuring that decision procedures integrated into proof assistants or theorem provers like Lean4 accurately reflect the logical properties they are meant to decide.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 177, "formal_statement": "theorem dummy {s : Set Œ±} (hs : s.Finite) : MeasurableSet s :=", "nl_statement": "The statement given is about a set \\(s\\) within some space \\(\\alpha\\), and it deals with the concept of measurability within the context of sets. Specifically, the theorem asserts that if a set \\(s\\) is finite, then it is measurable. This theorem bridges the concepts of finiteness and measurability in set theory, suggesting that the property of being finite for a set implies that the set can be measured."}
{"id": 178, "formal_statement": "theorem dummy {b n : ‚Ñï} (hb : 1 < b) (hn : n ‚â† 0) : log b (n * b) = log b n + 1 :=", "nl_statement": "The statement to be proven is about the logarithm of a product involving a base \\(b\\) and an integer \\(n\\), specifically \\(log_b(n \\cdot b) = log_b(n) + 1\\). This is under the conditions that \\(b > 1\\) and \\(n\\) is not equal to zero."}
{"id": 179, "formal_statement": "theorem dummy (v : n ‚Üí R) : (toLinear A).toLinearEquiv v = Matrix.mulVecLin (‚ÜëA) v :=", "nl_statement": "The statement defines a theorem related to linear algebra, specifically within the context of linear transformations and matrix operations. The theorem is about the application of a linear transformation, derived from a general linear group (essentially a non-singular matrix, which can be inverted), to a vector. It asserts that applying this transformation to a vector is equivalent to multiplying the matrix representation of this transformation by the vector."}
{"id": 180, "formal_statement": "theorem dummy [AddMonoidWithOne R] (n : ‚Ñï) : ((bit1 n : ‚Ñï) : R) = bit1 (n : R) :=", "nl_statement": "The theorem states that for any natural number `n` and in any additive monoid with a one element (`R`), the cast from the natural number `bit1 n` (which represents the number `2*n + 1`) to `R` is equal to the `bit1` representation of `n` in `R`, which also should be interpreted as `2*n + 1` within `R`."}
{"id": 181, "formal_statement": "theorem dummy (f : ‚àÄ i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a :=", "nl_statement": "The theorem named `pi_eval` is concerned with a function `f` that, for any index `i`, provides a continuous map from a type `A` to a space `X i`, where `X i` denotes a type that varies with `i`. The statement asserts that for any element `a` of type `A`, the evaluation of the product (or \"pi\") of these maps at `a` is equal to the function that, for each `i`, evaluates the map `f i` at `a`."}
{"id": 182, "formal_statement": "theorem dummy : (s : Set Œ±) ‚äÜ t ‚Üî (s : NonemptyInterval Œ±) ‚â§ t :=", "nl_statement": "Subset Relation Between Sets and Nonempty Intervals\n\nThe theorem in question discusses the relationship between a set `s` of type `Œ±` and another set `t`, also of type `Œ±`, in the context of subset relations and order relations. Specifically, it states that the subset relation between `s` and `t` (denoted as `s ‚äÜ t`) is equivalent to an order relation between `s` and `t` when `s` is considered as a `NonemptyInterval` of type `Œ±`. The order relation in question is the \"less than or equal to\" relation (denoted as `‚â§`)."}
{"id": 183, "formal_statement": "theorem dummy : (fun x => a + x) ‚Åª¬π' Ioo b c = Ioo (b - a) (c - a) :=", "nl_statement": "The statement concerns the preimage of an interval under a specific function. The function in question is \\(f(x) = a + x\\), and we are looking at the preimage of an open interval \\(Ioo(b, c)\\), which stands for all the points \\(x\\) such that \\(b < x < c\\). The theorem asserts that the preimage of this interval under our function is another interval, specifically \\(Ioo(b - a, c - a)\\). This means that for all \\(x\\) that when you add \\(a\\) to them, they fall between \\(b\\) and \\(c\\), those \\(x\\) originally were in the interval between \\(b - a\\) and \\(c - a\\)."}
{"id": 184, "formal_statement": "theorem dummy {a : Œ±} {s : Multiset Œ±} : dedup (a ::‚Çò s) = ndinsert a (dedup s) :=", "nl_statement": "The theorem `dedup_cons` concerns the operation of removing duplicate elements from a list (or multiset) in the context where the type of elements in the list is not specified (`Œ±`). It states that if you have an element `a` and a multiset `s`, then removing duplicates from the multiset that starts with `a` followed by `s` (`a ::‚Çò s`) is the same as inserting `a` into the multiset obtained by first removing duplicates from `s` and ensuring `a` is not duplicated (`ndinsert a (dedup s)`)."}
{"id": 185, "formal_statement": "theorem dummy : (‚àÖ : Set Œ±) ‚Ä¢ t = ‚àÖ :=", "nl_statement": "The theorem states that the scalar multiplication of the empty set with any set `t` results in the empty set. In mathematical terms, if you have a set `Œ±` and another set `t`, then multiplying every element of the empty set by every element of `t` will yield the empty set."}
{"id": 186, "formal_statement": "theorem dummy (z : N) : f.map (fun y ‚Ü¶ show MonoidHom.id M y ‚àà S from y.2) f z = z :=", "nl_statement": "The statement concerns a mathematical structure where `f` is a type of function known as a monoid homomorphism, which maps elements from one monoid (let's say, `M`) to another while preserving the monoid operation. This particular theorem, `map_id`, asserts that for any element `z` of a certain type `N`, when `f` is applied to `z` through a specific mapping process that involves the identity function of the monoid `M` and ensures the mapped value is in a subset `S`, the result is the same as the input `z`. This implies that the mapping process effectively behaves as an identity function for elements in `N`."}
{"id": 187, "formal_statement": "theorem dummy [Bot Œ≤] (a : Œ±) : (‚ä• : InfHom Œ± Œ≤) a = ‚ä• :=", "nl_statement": "The statement concerns a mathematical or logical framework where we're dealing with a concept of \"bottom\" or \"least element\" within a specific context, likely a lattice or ordered set. Specifically, it's about an \"infimum homomorphism\" (`InfHom`) between two types or sets, `Œ±` and `Œ≤`, where `Œ≤` is equipped with a bottom element (`‚ä•`). The theorem asserts that applying this bottom element of type `InfHom Œ± Œ≤` to any element `a` of type `Œ±` yields the bottom element of type `Œ≤`."}
{"id": 188, "formal_statement": "theorem dummy (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b :=", "nl_statement": "The statement to be proved is about the relationship between the comap (the preimage under a function) of a certain neighborhood filter (`ùìù b`) through the function `pure` and an ultrafilter `b` on some type `Œ±`. Specifically, it asserts that the comap of the neighborhood filter of `b` through the `pure` function is less than or equal to the ultrafilter `b` itself."}
{"id": 189, "formal_statement": "theorem dummy (x : R) : aevalTower g y (C x) = g x :=", "nl_statement": "The theorem, named `aevalTower_C`, concerns the evaluation of a polynomial at a certain point within the context of algebra. Specifically, it deals with the scenario where we have a polynomial whose coefficients come from a ring `R`, and we are evaluating this polynomial at a point `y` in some algebraic structure that `R` maps into via a function `g`. The theorem states that if you take a constant polynomial `C x` (a polynomial that is equal to the constant `x` for some `x` in `R`), and evaluate it under these conditions, the result is simply the image of `x` under the map `g`."}
{"id": 190, "formal_statement": "theorem dummy : ‚àÄ {a b : Cardinal}, b ‚â† 0 ‚Üí a ‚à£ b ‚Üí a ‚â§ b | a, x, b0, ‚ü®b, hab‚ü© => by simpa only [hab, mul_one] using mul_le_mul_left' (one_le_iff_ne_zero.2 fun h : b = 0 => b0 (by rwa [h, mul_zero] at hab)) a :=", "nl_statement": "The statement to be proved is: For any two cardinal numbers \\(a\\) and \\(b\\), if \\(b\\) is not equal to \\(0\\) and \\(a\\) divides \\(b\\), then \\(a\\) is less than or equal to \\(b\\)."}
{"id": 191, "formal_statement": "theorem dummy : Isometry e :=", "nl_statement": "The theorem being discussed is about an isometry, specifically it states that a certain entity 'e' is an isometry. This theorem is likely in the context of linear algebra or geometry, where an isometry refers to a transformation that preserves distances between points."}
{"id": 192, "formal_statement": "theorem dummy (l : List Char) : l.asString.length = l.length :=", "nl_statement": "The statement concerns the relationship between a list of characters (`l : List Char`) and its corresponding string representation (`l.asString`). Specifically, it asserts that the length of the string representation of this list (`l.asString.length`) is equal to the length of the list itself (`l.length`)."}
{"id": 193, "formal_statement": "theorem dummy (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=", "nl_statement": "The theorem states that if you have two balls centered at the same point x, where one ball has radius Œµ‚ÇÅ and the other has radius Œµ‚ÇÇ, and if Œµ‚ÇÅ is less than or equal to Œµ‚ÇÇ, then the first ball (with radius Œµ‚ÇÅ) is entirely contained within the second ball (with radius Œµ‚ÇÇ)."}
{"id": 194, "formal_statement": "theorem dummy {a : Œ±} : Œº.restrict {a} = 0 :=", "nl_statement": "The problem statement is about a measure theory concept. Specifically, it states that if you restrict a measure \\( \\mu \\) to a set containing only a single element \\( a \\), then the measure of this restricted set is 0. In more formal terms, for any element \\( a \\) in a given space \\( \\alpha \\), the measure of the set containing just \\( a \\), when restricted, is equal to 0."}
{"id": 195, "formal_statement": "theorem dummy (z1 z2 : ‚Ñ§) : (z1 : ‚Ñ§_[p]) = z2 ‚Üî z1 = z2 :=", "nl_statement": "The statement concerns the equality of two integers, `z1` and `z2`, when they are considered within the context of ‚Ñ§_[p], which represents the p-adic integers. Specifically, it asserts that casting `z1` and `z2` to p-adic integers yields equality if and only if `z1` and `z2` are equal as integers."}
{"id": 196, "formal_statement": "theorem dummy (F : HomotopyWith f‚ÇÄ f‚ÇÅ P) (x : X) : F (0, x) = f‚ÇÄ x :=", "nl_statement": "The statement given describes a theorem named `apply_zero` within the context of Homotopy Theory, a branch of topology. This theorem involves a homotopy `F` that is specifically a `HomotopyWith` between two functions `f‚ÇÄ` and `f‚ÇÅ` from some space `X` to another space governed by a property `P`. The theorem asserts that applying `F` to the pair `(0, x)`‚Äîwhere `0` represents the initial point of the standard unit interval `[0, 1]` and `x` is an element from `X`‚Äîyields the same result as applying the function `f‚ÇÄ` directly to `x`."}
{"id": 197, "formal_statement": "theorem dummy [One M] [One N] {x : M} {y : N} : (x, y) = 1 ‚Üî x = 1 ‚àß y = 1 :=", "nl_statement": "The statement provided is a theorem about pairs of elements from two potentially different types that have a multiplicative identity, denoted as `1`. The types of the elements are `M` and `N`, and each type has an associated identity element `1`. The theorem asserts a condition about a pair `(x, y)` where `x` is from type `M` and `y` is from type `N`. It claims that this pair is equal to the identity pair `(1, 1)` if and only if both `x` is equal to the identity in `M` and `y` is equal to the identity in `N`."}
{"id": 198, "formal_statement": "theorem dummy {n m l : ‚Ñï} : l ‚àà Ico n m ‚Üî n ‚â§ l ‚àß l < m :=", "nl_statement": "The statement to be proven is about the mathematical concept of intervals. Specifically, it concerns an interval of natural numbers from `n` to `m`, denoted as `Ico n m`, which stands for an interval that includes `n` but excludes `m`. The theorem asserts that a number `l` belongs to this interval if and only if `n` is less than or equal to `l` and `l` is less than `m`."}
{"id": 199, "formal_statement": "theorem dummy {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=", "nl_statement": "The problem statement describes a property about the limit superior (limsup) of a sequence (or function) `u` with respect to a filter `f`. The statement asserts that the limit superior of `u` under the filter `f` is less than or equal to the supremum (least upper bound) of the values of `u` at all points `n`."}
{"id": 200, "formal_statement": "theorem dummy {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=", "nl_statement": "The problem presents a theorem involving pairs (also known as tuples) of elements, where `Œ±` and `Œ≤` represent types of the elements in these pairs. Specifically, it involves the `swap` operation on pairs, which exchanges the positions of the elements in a pair. For example, if you have a pair `(a, b)`, applying `swap` to it would yield `(b, a)`. The theorem states that swapping the elements of two pairs `p` and `q` results in equality (i.e., `swap p = swap q`) if and only if the original pairs `p` and `q` were equal to begin with."}
{"id": 201, "formal_statement": "theorem dummy : ‚áë(toCompl‚Çó·µ¢ : E ‚Üí‚Çó·µ¢[ùïú] Completion E) = ((‚Üë) : E ‚Üí Completion E) :=", "nl_statement": "The theorem states that the linear map `toCompl‚Çó·µ¢`, when applied to any element of a vector space `E` over a field `ùïú`, is equivalent to the canonical embedding of that element into the completion space `Completion E`."}
{"id": 202, "formal_statement": "theorem dummy (s : IntermediateField K L) (x : L) : x ‚àà s.toSubalgebra ‚Üî x ‚àà s :=", "nl_statement": "The statement we're examining is a theorem related to elements of an IntermediateField and its corresponding Subalgebra within the context of field theory, particularly within the structures used in the Lean4 theorem prover. The theorem asserts a specific relationship between membership in an IntermediateField `s` and membership in the Subalgebra derived from `s`."}
{"id": 203, "formal_statement": "theorem dummy (B : Bicone F) : B.toCone.pt = B.pt :=", "nl_statement": "The theorem named `toCone_pt` concerns an object `B` which is an instance of a `Bicone` over a functor `F`. The statement of the theorem asserts that the point of the cone generated by `B` (`B.toCone.pt`) is equal to the point of `B` itself (`B.pt`)."}
{"id": 204, "formal_statement": "theorem dummy {y : Œ±} (h : x ‚àà+ [y]) : False :=", "nl_statement": "The theorem states that if an element 'x' is a duplicate in a singleton list consisting of 'y', it leads to a contradiction. Essentially, this is asserting that a singleton list (a list with only one element) cannot have a duplicate of any element."}
{"id": 205, "formal_statement": "theorem dummy (f : F) : comap f ‚ä§ = ‚ä§ :=", "nl_statement": "The theorem states that the preimage (or comap) of the top element (‚ä§, which usually represents the largest element in a given context, such as the entire space or set in consideration) under a function \\( f \\) from a set \\( F \\) is equal to the top element itself. In other words, if you apply the comap function to the top element of a structure, you get back the top element.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 206, "formal_statement": "theorem dummy {x : ‚Ñù‚â•0‚àû} : (x : EReal) = 1 ‚Üî x = 1 :=", "nl_statement": "The statement we're dealing with is a theorem regarding the equality of a certain type of real number, specifically a non-negative extended real number (\\(‚Ñù‚â•0‚àû\\)), to the number 1. In natural language, the theorem asserts that for any non-negative extended real number \\(x\\), casting \\(x\\) as an extended real number (EReal) equals 1 if and only if \\(x\\) itself equals 1."}
{"id": 207, "formal_statement": "theorem dummy (f : Ultrafilter Œ±) {g : Filter Œ±} (hg : NeBot (‚Üëf ‚äì g)) : ‚Üëf ‚â§ g :=", "nl_statement": "The statement `le_of_inf_neBot` concerns ultrafilters and filters on a set `Œ±`. It asserts that if `f` is an ultrafilter on `Œ±` and `g` is a filter on `Œ±`, and the infimum (greatest lower bound) of `f` and `g` is not the bottom element (indicating that `f` and `g` intersect non-trivially), then `f` is less than or equal to `g` in the filter order, meaning `f` is a subset of `g` or `f` refines `g`."}
{"id": 208, "formal_statement": "theorem dummy : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=", "nl_statement": "The statement concerns a property about vector subtraction in a specific mathematical setting. Specifically, it asserts that if a vector \\(s\\) belongs to a set \\(f\\) and another vector \\(t\\) belongs to a set \\(g\\), then the vector resulting from subtracting \\(t\\) from \\(s\\) (denoted as \\(s -·µ• t\\)) belongs to the set obtained by subtracting every element in \\(g\\) from every element in \\(f\\) (denoted as \\(f -·µ• g\\))."}
{"id": 209, "formal_statement": "theorem dummy (h : a ‚äÜ b) : ¬¨b ‚äÇ a :=", "nl_statement": "The theorem states that if set `a` is a subset of set `b` (denoted `a ‚äÜ b`), then `b` cannot be a strict subset of `a` (denoted `¬¨b ‚äÇ a`)."}
{"id": 210, "formal_statement": "theorem dummy : preimage 1 (¬∑ * b‚Åª¬π) ((mul_left_injective _).injOn _) = {b} :=", "nl_statement": "The theorem named `preimage_mul_right_one'` is concerned with the concept of preimages in the context of mathematical functions. Specifically, it deals with the preimage of the set containing only the number 1 under a specific function defined by multiplying an arbitrary element by the inverse of a given non-zero element `b`. The statement claims that this preimage is exactly the set containing only the element `b`."}
{"id": 211, "formal_statement": "theorem dummy : s √óÀ¢ t = ‚ä§ ‚Üî s = ‚ä§ ‚à® t = ‚ä§ :=", "nl_statement": "The statement we're examining asserts that the product of two sets \\(s\\) and \\(t\\) equals the universal set (denoted as \\(\\top\\)) if and only if either \\(s\\) or \\(t\\) is the universal set. Mathematically, this can be expressed as:\n\\[s \\times t = \\top \\iff s = \\top \\ \\text{or} \\ t = \\top.\\]\n\nThis theorem concerns the properties of sets within a certain mathematical structure, possibly a topological space, where \\(\\times\\) represents the Cartesian product of two sets, and \\(\\top\\) represents the universal set, or the set containing all possible elements within a given context."}
{"id": 212, "formal_statement": "theorem dummy (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=", "nl_statement": "The statement given, `theorem pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x`, concerns a specific context in topology, related to the properties of neighborhoods and intervals in a mathematical space.\n\nIn plain language, this theorem states: For any function `a` mapping from an index set `i` to real numbers, and any point `x` in the same space such that for all `i`, `a(i)` is less than `x(i)`, the interval (set of points) strictly greater than `a` (denoted as `Ioi a`) is within the neighborhood of `x` (denoted as `ùìù x`).\n\nHere, `Ioi a` represents an interval of all points greater than `a`, and `ùìù x` represents the neighborhood of the point `x`, which is a set of points that are \"close\" to `x` according to the space's topology."}
{"id": 213, "formal_statement": "theorem dummy : hammingNorm (0 : ‚àÄ i, Œ≤ i) = 0 :=", "nl_statement": "The statement we are examining asserts that the Hamming norm of the zero function is zero. To clarify, the zero function here refers to a function that, for any index \\(i\\), outputs zero for the value of type \\(\\beta i\\). The Hamming norm is a measure of how many entries in a function or vector are non-zero."}
{"id": 214, "formal_statement": "theorem dummy {a a'} {s : Finmap Œ≤} (h : a ‚â† a') : lookup a (erase a' s) = lookup a s :=", "nl_statement": "The theorem states that if you have two distinct keys, `a` and `a'`, and a finite map `s` (which is a collection of key-value pairs where each key is unique), then removing the key `a'` from `s` (to get `erase a' s`) and then looking up `a` in this modified map will give you the same result as looking up `a` directly in the original map `s`. This implies that the operation of removing a key-value pair where the key is `a'` does not affect the outcome of searching for a different key `a` in the map."}
{"id": 215, "formal_statement": "theorem dummy : œÜ 2 = 1 :=", "nl_statement": "The theorem named `totient_two` states that the Euler totient function of 2 equals 1. The Euler totient function, often denoted as œÜ(n), is a function that counts the positive integers up to a given integer n that are relatively prime to n. Two numbers are relatively prime if their greatest common divisor (GCD) is 1, meaning they have no prime factors in common."}
{"id": 216, "formal_statement": "theorem dummy (x) : x ‚àà I.ofPolynomial ‚Üî x ‚àà I :=", "nl_statement": "The statement concerns the membership of an element \\(x\\) in a certain set defined by `I.ofPolynomial` and its equivalence to the membership of \\(x\\) in the set `I`. Specifically, it declares that \\(x\\) is an element of `I.ofPolynomial` if and only if \\(x\\) is an element of `I`."}
{"id": 217, "formal_statement": "theorem dummy {s : Set Œ±} : s ‚äÜ ‚àÖ ‚Üí s = ‚àÖ :=", "nl_statement": "The theorem states that if a set \\(s\\) is a subset of the empty set, then \\(s\\) must itself be the empty set."}
{"id": 218, "formal_statement": "theorem dummy (hI : IsInitial I) {A : C} (f : A ‚ü∂ I) : IsIso f :=", "nl_statement": "The statement is about a property in category theory, specifically concerning initial objects and isomorphisms. The theorem states that if an object `I` is an initial object in a category `C`, then for any morphism `f` from another object `A` in the category `C` to `I`, `f` is an isomorphism."}
{"id": 219, "formal_statement": "theorem dummy : (sumLexAssoc Œ± Œ≤ Œ≥).symm (inr (inr c)) = inr c :=", "nl_statement": "The statement concerns a mathematical construct known as the sum lex associative symmetry, specifically focusing on its application to a certain type of input. In more intuitive terms, the lemma is about a function that rearranges or associates elements from a sum type (which is a type that can hold values of different types, denoted by `Œ±`, `Œ≤`, `Œ≥` in this context) in a certain way, and this lemma is looking at the inverse of that function. The specific case addressed here is when the input to this inverse function is of the form `inr (inr c)`, where `inr` is a constructor that injects a value into the right part of a sum type, and `c` is a value of type `Œ≥`. The statement claims that applying the inverse of the sum lex associative function to this particular form of input yields `inr c`."}
{"id": 220, "formal_statement": "theorem dummy (v : Vector Œ± n) : ofFn (get v) = v :=", "nl_statement": "The theorem states that for any vector \\( v \\) of type \\( \\text{Vector } \\alpha \\ n \\), if you convert the function that retrieves the elements of \\( v \\) back into a vector, you get the original vector \\( v \\) itself. In other words, it says that the operation of converting a get function back to a vector is an identity operation on vectors."}
{"id": 221, "formal_statement": "theorem dummy : (Ioc a b).Nonempty ‚Üî a < b :=", "nl_statement": "The lemma states that the interval (a, b] is non-empty if and only if \\(a < b\\)."}
{"id": 222, "formal_statement": "theorem dummy : infDist x (closure s) = infDist x s :=", "nl_statement": "The statement describes a property of a function named `infDist`, which measures the \"infimum distance\" (or the greatest lower bound of distances) between a point `x` and a set `s`. Specifically, it claims that the infimum distance between a point `x` and the closure of a set `s` is equal to the infimum distance between the point `x` and the set `s` itself. The closure of a set includes all the points in the set plus all the limit points of the set (i.e., points where sequences within the set can converge to)."}
{"id": 223, "formal_statement": "theorem dummy (v : Valuation R Œì‚ÇÄ) : v.toFun = v :=", "nl_statement": "The given statement is about a valuation, `v`, from a ring `R` to a totally ordered abelian group `Œì‚ÇÄ`. The theorem `toFun_eq_coe` asserts that the function `toFun` associated with the valuation `v` is identical to the valuation itself."}
{"id": 224, "formal_statement": "theorem dummy {a : WithTop Œ±} : @LE.le (WithTop Œ±) _ a none :=", "nl_statement": "The theorem states that for any element `a` of type `WithTop Œ±` (where `Œ±` is any type), `a` is less than or equal to `none` in the `WithTop Œ±` ordering."}
{"id": 225, "formal_statement": "theorem dummy : x ‚àà s·∂ú ‚Üî ¬¨x ‚àà s :=", "nl_statement": "The theorem provided is about set theory, specifically dealing with the concept of set complements. It states that for an element \\(x\\) and a set \\(s\\), \\(x\\) is in the complement of \\(s\\) (denoted as \\(s·∂ú\\)) if and only if \\(x\\) is not in \\(s\\)."}
{"id": 226, "formal_statement": "theorem dummy : a * b‚Åª¬π < c * d‚Åª¬π ‚Üî a * d < c * b :=", "nl_statement": "The statement to be proven is that the inequality \\(a \\times \\frac{1}{b} < c \\times \\frac{1}{d}\\) is equivalent to \\(a \\times d < c \\times b\\). This means that multiplying \\(a\\) by the inverse of \\(b\\) is less than multiplying \\(c\\) by the inverse of \\(d\\) if and only if the product of \\(a\\) and \\(d\\) is less than the product of \\(c\\) and \\(b\\)."}
{"id": 227, "formal_statement": "theorem dummy {k l : ‚Ñï} (h : k ‚â† l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) :=", "nl_statement": "The given statement asserts that for any two distinct natural numbers \\(k\\) and \\(l\\), the sets of primitive roots of \\(k\\) and \\(l\\) in some ring \\(R\\) are disjoint. In mathematical terms, no element is a primitive root of both \\(k\\) and \\(l\\) unless \\(k = l\\)."}
{"id": 228, "formal_statement": "theorem dummy (x y z : F) : ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´ :=", "nl_statement": "The theorem `inner_sub_right` states that for any three elements `x`, `y`, and `z` in a field `F`, the inner product of `x` with the difference of `y` and `z` is equal to the inner product of `x` with `y` minus the inner product of `x` with `z`. This can be formally expressed as ‚ü™x, y - z‚ü´ = ‚ü™x, y‚ü´ - ‚ü™x, z‚ü´."}
{"id": 229, "formal_statement": "theorem dummy (hr : 0 < r) : Absorbent ùïú (ball p (0 : E) r) :=", "nl_statement": "The theorem named `absorbent_ball_zero` states that if you have a positive radius `r`, then the ball with center `p` and radius `r` in the vector space `E` over the field `ùïú` is an absorbent set."}
{"id": 230, "formal_statement": "theorem dummy [Top Œ≤] : (‚Üë(‚ä§ : Œ≤) : Germ l Œ≤) = ‚ä§ :=", "nl_statement": "The statement concerns the concept of germs of functions at a filter in the context of topology, specifically within the framework of a topological space \\( \\beta \\) that has a designated top element, denoted as \\( \\top \\). The lemma asserts that the germ (at a filter \\( l \\)) of the constant function at \\( \\top \\) in \\( \\beta \\) is equal to the top element in the space of germs with values in \\( \\beta \\), denoted \\( Germ l \\beta \\)."}
{"id": 231, "formal_statement": "theorem dummy {I J : LieIdeal R L} (h : I ‚â§ J) (k : ‚Ñï) : D k I ‚â§ D k J :=", "nl_statement": "Let \\(I\\) and \\(J\\) be ideals in a Lie algebra \\(L\\) over a ring \\(R\\), and let \\(k\\) be a natural number. If \\(I\\) is a subset of \\(J\\) (denoted \\(I \\leq J\\)), then the \\(k\\)-th derived series of \\(I\\) is a subset of the \\(k\\)-th derived series of \\(J\\)."}
{"id": 232, "formal_statement": "theorem dummy {s : Finset Œ±} : s.Nonempty ‚Üî s ‚â† ‚àÖ :=", "nl_statement": "The theorem states that a finite set \\(s\\) of type \\(\\alpha\\) is nonempty if and only if it is not equal to the empty set."}
{"id": 233, "formal_statement": "theorem dummy {x : ‚Ñù*} (h : x ‚â† 0) : Infinitesimal x ‚Üî Infinite x‚Åª¬π :=", "nl_statement": "The statement concerns the relationship between two properties of hyperreal numbers: being \"infinitesimal\" and having an \"infinite\" inverse. Specifically, it asserts that for any nonzero hyperreal number \\(x\\), \\(x\\) is infinitesimal if and only if its inverse (\\(x^{-1}\\)) is infinite."}
{"id": 234, "formal_statement": "theorem dummy : (1 : ‚Ñù) ‚àà I :=", "nl_statement": "The statement provided is a theorem named `one_mem` that asserts the number 1 is an element of the set \\(I\\), which, based on the context, seems to be referring to the unit interval on the real number line. This interval typically includes all real numbers \\(x\\) such that \\(0 \\leq x \\leq 1\\)."}
{"id": 235, "formal_statement": "theorem dummy : (1 : NumDenSameDeg ùíú x).deg = 0 :=", "nl_statement": "The statement to be proven is that the degree of the number 1, when considered as an element of a homogeneous localization of a graded algebra ùíú at an element x, is 0.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 236, "formal_statement": "theorem dummy (a : Œ±) (S : Submonoid M) : ‚Üë(a ‚Ä¢ S) = a ‚Ä¢ (S : Set M) :=", "nl_statement": "The statement concerns the interaction between scalar multiplication and submonoids within a mathematical structure, presumably a monoid that is part of a larger algebraic context where scalar multiplication is defined. Specifically, the theorem states that when you apply scalar multiplication (denoted by `a ‚Ä¢ S`) to a submonoid `S` of `M`, the result, when considered as a set, is the same as applying scalar multiplication to each element of `S` considered as a set within `M`."}
{"id": 237, "formal_statement": "theorem dummy : (a * ¬∑)^[n] = (a ^ n * ¬∑) :=", "nl_statement": "The theorem named `mul_left_iterate` states that iterating the operation of multiplying by `a` on the left side of an arbitrary element `n` times is equivalent to multiplying by `a` raised to the power of `n` on the left side of that element once."}
{"id": 238, "formal_statement": "theorem dummy (hn : 0 < n) : n * (n - 1)! = n ! :=", "nl_statement": "The statement to be proven is that for any natural number \\(n\\) greater than 0, the product of \\(n\\) and the factorial of \\(n - 1\\) (\\((n - 1)!\\)) is equal to the factorial of \\(n\\) (\\(n!\\))."}
{"id": 239, "formal_statement": "theorem dummy (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) :=", "nl_statement": "Let \\(a\\) be a non-zero p-adic sequence. The problem is to show that there exists an integer \\(z\\) such that the norm of \\(a\\) is equal to \\(p\\) raised to the power of \\(-z\\)."}
{"id": 240, "formal_statement": "theorem dummy [MulZeroOneClass R] (r : R) : inr r = (r ‚Ä¢ Œµ : R[Œµ]) :=", "nl_statement": "This theorem states that in a mathematical structure where multiplication, zero, and one are defined (like a ring), for any element `r` of this structure, the function `inr r` is equal to the scalar multiplication of `r` with a special element `Œµ`, within a certain extension of this structure, often referred to as `R[Œµ]`."}
{"id": 241, "formal_statement": "theorem dummy (x : ùïú) : HasDerivAt (fun x => p.eval x) (p.derivative.eval x) x :=", "nl_statement": "The problem statement is a theorem regarding derivatives in mathematics. Specifically, it states that for any polynomial \\(p\\), at any point \\(x\\) in the field \\(\\mathbb{K}\\), the derivative of \\(p\\) at \\(x\\) exists and is equal to the evaluation of \\(p\\)'s derivative at \\(x\\). In simpler terms, this theorem tells us how to find the slope of the tangent line to the curve defined by a polynomial \\(p\\) at any given point \\(x\\)."}
{"id": 242, "formal_statement": "theorem dummy {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 := have : (-b)*a ‚â• 0 :=", "nl_statement": "The theorem states that for any ordered ring \\(\\alpha\\), given two elements \\(a\\) and \\(b\\) of \\(\\alpha\\), if \\(a\\) is less than or equal to zero (\\(a \\leq 0\\)) and \\(b\\) is greater than zero (\\(0 < b\\)), then the product of \\(b\\) and \\(a\\) (\\(b \\cdot a\\)) is less than or equal to zero (\\(b \\cdot a \\leq 0\\))."}
{"id": 243, "formal_statement": "theorem dummy (a b : ‚Ñ§‚àöd) (h : a < b) (c) : c + a < c + b :=", "nl_statement": "The theorem states that if you have two elements `a` and `b` of a certain mathematical structure (‚Ñ§‚àöd, which seems to represent some domain of integers under a square root operation, possibly quadratic integers), and `a` is less than `b`, then for any element `c` in the same domain, `c + a` is less than `c + b`. This is a generalization of the idea that adding the same quantity to both sides of an inequality does not change the inequality's direction."}
{"id": 244, "formal_statement": "theorem dummy {Œπ : Type w} (b : Basis Œπ R M) : Module.Free R M :=", "nl_statement": "The statement asserts that a module \\(M\\) over a ring \\(R\\) with a basis \\(b\\) indexed by type \\(\\iota\\) is a free module. This is formalized through the lemma `Module.Free.of_basis`."}
{"id": 245, "formal_statement": "theorem dummy {s t : Multiset Œ±} {a : Œ±} : a ‚àà ndunion s t ‚Üî a ‚àà s ‚à® a ‚àà t :=", "nl_statement": "The theorem we're discussing states that an element `a` is a member of the non-deduplicated union (ndunion) of two multisets `s` and `t` if and only if `a` is a member of either `s` or `t`. In simpler terms, this theorem is about checking if an element is part of at least one of two collections where duplicates are allowed but not merged in the union process."}
{"id": 246, "formal_statement": "theorem dummy (x : EReal) : ‚ä• + x = ‚ä• :=", "nl_statement": "The theorem states that for any extended real number \\(x\\), the sum of the bottom element (denoted as \\(‚ä•\\)) and \\(x\\) is equal to the bottom element (\\(‚ä•\\)). In the context of extended real numbers, \\(‚ä•\\) can be thought of as representing an undefined or uncomputable value, which is distinct from real numbers and the symbols for positive and negative infinity."}
{"id": 247, "formal_statement": "theorem dummy {a : Œ±} {S T : AddSubmonoid A} : S ‚â§ a ‚Ä¢ T ‚Üî a‚Åª¬π ‚Ä¢ S ‚â§ T :=", "nl_statement": "The theorem `le_pointwise_smul_iff` is about comparing two additive submonoids `S` and `T` of some algebraic structure `A` under the operation of scalar multiplication by an element `a` from a set `Œ±`. The statement of the theorem is that `S` is a subset of or equal to (`‚â§`) the scalar multiplication of `a` with `T` (denoted as `a ‚Ä¢ T`) if and only if the scalar multiplication of the inverse of `a` with `S` (denoted as `a‚Åª¬π ‚Ä¢ S`) is a subset of or equal to `T`."}
{"id": 248, "formal_statement": "theorem dummy (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=", "nl_statement": "The statement provided involves the concept of intersections over sets in a specific mathematical context, using the Lean4 theorem prover syntax. It asserts that the intersection over all sets obtained by applying a function `h` to the elements of a family of sets `f` (denoted as `‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h }`) is equal to the intersection of applying the function `h` directly to each set in the family `f` (denoted as `‚ãÇ s ‚àà f, h s`). This is under the condition that `h` is a monotone function, meaning `h` preserves the order (if `a ‚â§ b`, then `h(a) ‚â§ h(b)`)."}
{"id": 249, "formal_statement": "theorem dummy (x : Œ≤) : Continuous (OrderHom.const Œ± x) :=", "nl_statement": "The theorem we're examining states that a constant function within a certain framework is continuous. In mathematical terms, for a given type `Œ≤` and a constant `x` of that type, the theorem asserts that the function which maps any input to `x` is continuous."}
{"id": 250, "formal_statement": "theorem dummy : ‚Üë(0 : { P : M // IsLprojection X P }) = (0 : M) :=", "nl_statement": "The statement is about a specific kind of object from a mathematical structure, denoted as `{ P : M // IsLprojection X P }`, where `M` is some mathematical space, `X` is an element or a set within that space, and `P` within this context refers to objects that satisfy the property `IsLprojection` with respect to `X`. The theorem, `coe_zero`, asserts that when you take the zero element from this specific subset of `M` (denoted by `0 : { P : M // IsLprojection X P }`) and view it as an element of `M` (this viewing or conversion is denoted by `‚Üë`), it is equal to the zero element of `M` itself (denoted by `(0 : M)`)."}
{"id": 251, "formal_statement": "theorem dummy : trace (0 : Matrix n n R) = 0 :=", "nl_statement": "The statement asserts that the trace of a zero matrix of size \\(n \\times n\\) over a ring \\(R\\) is equal to 0. The trace of a matrix is the sum of its diagonal elements."}
{"id": 252, "formal_statement": "theorem dummy (hP : P.parts = ‚àÖ) : P.IsUniform G Œµ :=", "nl_statement": "The theorem states that if the partition `P` of a certain structure has no parts (i.e., `P.parts = ‚àÖ`), then `P` satisfies the condition of being uniform with respect to some group `G` and some parameter `Œµ`. The concept of \"uniformity\" in this context is tied to specific conditions or properties that `P` must satisfy, which are not explicitly defined here but are related to how `P` interacts with `G` and `Œµ`."}
{"id": 253, "formal_statement": "theorem dummy : (X : R[X]).natDegree ‚â§ 1 :=", "nl_statement": "The statement concerns the natural degree of a polynomial, specifically a polynomial in a ring \\(R\\) denoted as \\(X\\). The lemma asserts that the natural degree of \\(X\\) is less than or equal to 1."}
{"id": 254, "formal_statement": "theorem dummy (P : C·µí·µñ ‚•§ D) : J.sheafifyMap (ùüô P) = ùüô (J.sheafify P) :=", "nl_statement": "The statement concerns a mathematical structure in category theory, specifically within the context of Grothendieck topologies and sheaf theory. It asserts that applying the \"sheafifyMap\" operation to the identity morphism of a presheaf \\(P\\) (denoted as \\(ùüô P\\)) in a category \\(C\\) yields the identity transformation on the sheafification of \\(P\\) (denoted as \\(ùüô (J.sheafify P)\\)). In essence, it claims that sheafifying does not alter the identity property of the morphism with respect to \\(P\\)."}
{"id": 255, "formal_statement": "theorem dummy {a : R} : IsOpen (basicOpen a : Set (PrimeSpectrum R)) :=", "nl_statement": "The statement given is about a property in algebraic geometry, specifically within the context of the prime spectrum of a ring \\(R\\). The theorem, named `isOpen_basicOpen`, asserts that for any element \\(a\\) of the ring \\(R\\), the set known as `basicOpen(a)` within the prime spectrum of \\(R\\) is an open set. This is a foundational result that ties together algebraic concepts with topological properties, illustrating how algebraic structures can induce a topology on the prime spectrum."}
{"id": 256, "formal_statement": "theorem dummy [Zero Œ±] [Subsingleton n] (A : Matrix n n Œ±) : A.IsDiag :=", "nl_statement": "The theorem states that if we have a matrix `A` of type `Œ±`, indexed by type `n`, in a context where `Œ±` has a zero element (meaning it's possible to define a zero value for type `Œ±`, as in the case for numbers) and `n` is a subsingleton (meaning any two elements of type `n` are identical), then `A` is a diagonal matrix. In simpler terms, for a matrix with entries of type `Œ±` in a scenario where the indexing set `n` has the property that all its elements are essentially the same, the matrix must be diagonal. A diagonal matrix is one where all entries off the main diagonal are zero."}
{"id": 257, "formal_statement": "theorem dummy {Œ¥ : ‚Ñù} {E : Set Œ±} : IsOpen (thickening Œ¥ E) :=", "nl_statement": "The theorem states that the thickening of a set \\(E\\) by a distance \\(\\delta\\) in a metric space is an open set. The \"thickening\" of a set \\(E\\) by \\(\\delta\\) is defined as the set of all points in the metric space that are less than \\(\\delta\\) distance away from \\(E\\)."}
{"id": 258, "formal_statement": "theorem dummy (h : M ‚â§ N) : M * P ‚â§ N * P :=", "nl_statement": "The given theorem states that if one quantity \\(M\\) is less than or equal to another quantity \\(N\\), then multiplying both quantities by the same positive quantity \\(P\\) will maintain this relationship, meaning \\(M \\times P\\) will be less than or equal to \\(N \\times P\\)."}
{"id": 259, "formal_statement": "theorem dummy (p : ‚Ñï) : ‚àÄ {z : ‚Ñ§} (_h : 0 ‚â§ z), (z.toNat : ZMod p) = z | (n : ‚Ñï), _h => by simp only [Int.cast_ofNat, Int.toNat_coe_nat] | Int.negSucc n, h => by simp at h :=", "nl_statement": "The theorem states that for any non-negative integer \\(z\\) and any positive natural number \\(p\\), if you cast \\(z\\) to a natural number and then cast it to \\(ZMod p\\) (a type representing integers modulo \\(p\\)), the result is the same as if you directly cast \\(z\\) to \\(ZMod p\\)."}
{"id": 260, "formal_statement": "theorem dummy (ht : t.Infinite) (hs : s.Nonempty) : (s √óÀ¢ t).Infinite :=", "nl_statement": "The problem statement asserts that if a set `t` is infinite and a set `s` is nonempty, then the Cartesian product of `s` and `t` (notated as `s √óÀ¢ t`) is also infinite."}
{"id": 261, "formal_statement": "theorem dummy : Disjoint (G.neighborFinset v) {v} :=", "nl_statement": "The statement is about a property in graph theory related to a simple graph \\(G\\) and a vertex \\(v\\) in that graph. It asserts that the set of neighbors of \\(v\\) in \\(G\\) (denoted as `G.neighborFinset v`) is disjoint from the singleton set containing only \\(v\\) itself (`{v}`). In other words, \\(v\\) cannot be a neighbor to itself in the neighbor set of \\(v\\), which aligns with the definition of a simple graph where loops (edges from a vertex to itself) are not allowed."}
{"id": 262, "formal_statement": "theorem dummy (x y : PGame) : x ‚â§ y ‚à® y ‚ßè x :=", "nl_statement": "The statement provided is a theorem concerning two entities, `x` and `y`, which are of type `PGame` (presumably representing \"Partizan Games\" in some formalized system of game theory within the Lean4 theorem prover framework). The theorem asserts that for any two such games `x` and `y`, it is either the case that `x` is less than or equal to `y`, denoted `x ‚â§ y`, or `y` is strictly less than `x`, denoted `y ‚ßè x`. This establishes a fundamental dichotomy regarding the comparison of two games in this formal system."}
{"id": 263, "formal_statement": "theorem dummy (hs : s.Finite) : condCount s (s ‚à© t) = condCount s t :=", "nl_statement": "The statement concerns a mathematical property involving conditional counting within a given set. Specifically, it asserts that for any finite set \\(s\\), the conditional count of \\(s\\) intersecting with another set \\(t\\) is equal to the conditional count of \\(s\\) with respect to \\(t\\). This theorem touches upon the concept of measuring the size or probability of events in a constrained space."}
{"id": 264, "formal_statement": "theorem dummy : a ‚àà l‚ÇÅ ‚à© l‚ÇÇ ‚Üí a ‚àà l‚ÇÅ :=", "nl_statement": "The statement to be proven is that if an element `a` is a member of the intersection of two lists `l‚ÇÅ` and `l‚ÇÇ`, then `a` must be a member of the first list `l‚ÇÅ`."}
{"id": 265, "formal_statement": "theorem dummy (a : R) : derivative (C a * X ^ 2) = C (a * 2) * X :=", "nl_statement": "The theorem states that the derivative of the function \\(a \\times x^2\\) with respect to \\(x\\) is \\(2a \\times x\\), where \\(a\\) is a constant."}
{"id": 266, "formal_statement": "theorem dummy (f : Œ± ‚Üí‚Çò[Œº] Œ≥) (n : ‚Ñï) : ‚áë(f ^ n) =·µê[Œº] (‚áëf) ^ n :=", "nl_statement": "The theorem stated in the Lean4 syntax addresses the concept of functional powers within the context of measure theory, specifically for almost everywhere (a.e.) equal functions. The statement can be interpreted as follows:\n\nGiven a measurable function \\(f\\) from a set \\(\\alpha\\) to \\(\\gamma\\) with respect to a measure \\(\\mu\\), and given an integer \\(n\\), the \\(n\\)th power of the function \\(f\\), when applied, is almost everywhere equal to the function \\(f\\) applied and then raised to the \\(n\\)th power."}
{"id": 267, "formal_statement": "theorem dummy : l (a‚ÇÅ ‚äî a‚ÇÇ) = l a‚ÇÅ ‚äî l a‚ÇÇ :=", "nl_statement": "The theorem named `l_sup` states that the application of a function `l` to the supremum (least upper bound) of two elements `a‚ÇÅ` and `a‚ÇÇ` is equal to the supremum of the application of `l` to each of these elements individually. In other words, if you have a function `l` and two elements `a‚ÇÅ` and `a‚ÇÇ`, then taking the supremum of `a‚ÇÅ` and `a‚ÇÇ` first and then applying `l` to it gives you the same result as applying `l` to each of `a‚ÇÅ` and `a‚ÇÇ` separately and then taking their supremum."}
{"id": 268, "formal_statement": "theorem dummy (f : K ‚Üí+* L) (s : Set K) : (closure s).map f = closure (f '' s) :=", "nl_statement": "The theorem named `map_field_closure` concerns the behavior of a certain type of function called a *ring homomorphism* (denoted as `f : K ‚Üí+* L`) when it is applied to the closure of a set `s` within a field `K`. Specifically, it states that the image under `f` of the closure of `s` in `K` is equal to the closure of the image of `s` under `f` in `L`. In other words, if you take a set `s` in a field `K`, close it (taking all elements that can be constructed from `s` using field operations), and then map it to another field `L` using `f`, it's the same as first mapping `s` with `f` and then taking the closure in `L`."}
{"id": 269, "formal_statement": "theorem dummy {a : Fin n} : (a : Fin (n + 1)) = castSucc a :=", "nl_statement": "The statement concerns the type `Fin n`, which represents the set of natural numbers less than `n`. The theorem `coe_eq_castSucc` asserts that for any element `a` of type `Fin n`, when `a` is considered as an element of `Fin (n + 1)` (through coercion), it is equal to the result of applying the function `castSucc` to `a`."}
{"id": 270, "formal_statement": "theorem dummy (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=", "nl_statement": "The theorem `coe_neg_linearMap` concerns a derivation `D` from a ring `R` to a module `M` over `R`, with coefficients in an algebra `A`. It states that the coercion of the negation of `D` (written as `‚Üë(-D)`) to a linear map from `A` to `M` is equal to the negation of `D` considered as a linear map from `A` to `M`."}
{"id": 271, "formal_statement": "theorem dummy : a ‚àÜ b \\ a = b \\ a :=", "nl_statement": "The theorem named `symmDiff_sdiff_left` states that the symmetric difference of two sets `a` and `b`, when the set `a` is subtracted from it, is equal to the set difference of `b` and `a`. In mathematical terms, this can be written as \\(a \\Delta b \\setminus a = b \\setminus a\\)."}
{"id": 272, "formal_statement": "theorem dummy : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=", "nl_statement": "The statement in question is about the `prodMap` function in a context likely involving category theory or a similar abstract mathematical framework. Specifically, it defines `prodMap f g` as equal to the product (in the categorical sense) of two compositions: `f` composed with the projection `fst R S`, and `g` composed with the projection `snd R S`. Here, `f` and `g` are functions or morphisms, and `fst R S` and `snd R S` are projection functions from a product type `(R, S)` to its components `R` and `S`, respectively."}
{"id": 273, "formal_statement": "theorem dummy : f (lfp (g.comp f)) = lfp (f.comp g) :=", "nl_statement": "The statement essentially says that if you map the least fixed point (lfp) of a composition of two functions \\(g\\) after \\(f\\) through \\(f\\), it is equal to the least fixed point of the composition of \\(f\\) after \\(g\\). In simpler terms, it's about the interchangeability of the order of function composition when applied to the concept of least fixed points under certain conditions."}
{"id": 274, "formal_statement": "theorem dummy (x : PGame) [IsEmpty x.RightMoves] : 0 ‚â§ x :=", "nl_statement": "The statement in question is a theorem regarding positional games, specifically a class of games modeled as \"PGames.\" The theorem states that for any game \\(x\\), if the set of possible right moves from \\(x\\) is empty (i.e., there are no moves available for the player making the right moves), then the game \\(x\\) is greater than or equal to 0. This is a formal way to assess the advantage or disadvantage in a given position within such games, with the numerical value (here, 0 or greater) indicating a non-disadvantageous position for the left-moving player under the given condition."}
{"id": 275, "formal_statement": "theorem dummy : r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b) :=", "nl_statement": "This theorem states that if you scale an interval \\([a, b]\\) (denoted as `Icc a b` in Lean4) by a positive real number `r`, the result is the same as scaling the endpoints `a` and `b` by `r` and forming an interval from these scaled points. In mathematical terms, `r ‚Ä¢ Icc a b = Icc (r ‚Ä¢ a) (r ‚Ä¢ b)`, where `‚Ä¢` represents the scalar multiplication."}
{"id": 276, "formal_statement": "theorem dummy (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=", "nl_statement": "The theorem named `sup_liminf` concerns the relationship between the supremum (least upper bound) of a set and the limit inferior (liminf) of a function over a filter. Specifically, it states that for any element `a` in a set `Œ±` and a function `u` from some index set to `Œ±`, the supremum of `a` and the liminf of `u` over a filter `f` is equal to the liminf of the function that takes each element `x` to the supremum of `a` and `u(x)`, over the same filter `f`."}
{"id": 277, "formal_statement": "theorem dummy : (‚àÖ : Set Œ±).Finite :=", "nl_statement": "The theorem states that the empty set, denoted as `‚àÖ`, is finite for any type `Œ±`. In simpler terms, it asserts that if you have an empty collection of items, regardless of what type of items you could potentially have in that collection, the number of items in that collection is finite."}
{"id": 278, "formal_statement": "theorem dummy (s : Set Œπ) : (pi s fun i : Œπ => (‚ä§ : Submodule R (œÜ i))) = ‚ä§ :=", "nl_statement": "The statement is about a property of a mathematical construct called a \"submodule\" within the context of ring theory and linear algebra. Specifically, it asserts a property about the direct product of submodules over a set. The theorem, named `pi_top`, concerns the direct product (œÄ) of a collection of top submodules (denoted as ‚ä§, which represents the entire space in each component) indexed by a set `s` over some index type `Œπ`. It states that this direct product is equal to the top submodule of the direct sum space of these component spaces.\n\nIn simpler terms, if you take each possible \"component space\" at its maximum size (top submodule) for each index in a set, and then consider the product of these spaces, you end up with the entire space of all combined dimensions."}
{"id": 279, "formal_statement": "theorem dummy : toDual (a ‚áî b) = toDual a ‚àÜ toDual b :=", "nl_statement": "The problem statement given in Lean4 syntax is about translating a specific theorem related to dual operations on logical biconditionals (‚Üî) into its dual form. The theorem is stated as `toDual (a ‚áî b) = toDual a ‚àÜ toDual b`. \n\nIn natural language, this theorem suggests that the dual operation applied to the biconditional (if and only if) relationship between two propositions `a` and `b` is equivalent to applying the dual operation to each of the propositions individually and then combining them with an operation represented by `‚àÜ`."}
{"id": 280, "formal_statement": "theorem dummy (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=", "nl_statement": "The problem statement concerns the mathematical concept of \"little o\" notation, which is used in asymptotic analysis to describe the limiting behavior of functions. Specifically, the theorem `isLittleO_irrefl'` asserts that a function `f'` cannot be \"little o\" of itself under certain conditions, within a limit `l`. The condition is that there exists a subset of the domain of `f'`, denoted by `‚àÉ·∂† x in l`, where the norm of `f'(x)` is non-zero."}
{"id": 281, "formal_statement": "theorem dummy : PosMulMono Œ± ‚Üî MulPosMono Œ± :=", "nl_statement": "The statement \"posMulMono_iff_mulPosMono\" presents an equivalence between two properties, `PosMulMono Œ±` and `MulPosMono Œ±`, within a mathematical or logical system defined over a type `Œ±`. The naming suggests these properties relate to the behavior of multiplication with respect to positivity and monotonicity. Specifically, `PosMulMono` might refer to a property where the multiplication of positive elements is monotone, while `MulPosMono` could involve a slightly different, yet closely related, aspect of multiplication and positivity."}
{"id": 282, "formal_statement": "theorem dummy : (0 : MvPowerSeries œÉ k)‚Åª¬π = 0 :=", "nl_statement": "The theorem states that the inverse of the zero multivariate power series in a given field \\(k\\) and with a set of indeterminates \\(\\sigma\\) is equal to the zero multivariate power series. In simpler terms, if you have a series that represents a function in several variables, and this series is entirely made up of zeroes, then the series that would \"undo\" this series (its mathematical inverse) is also entirely made up of zeroes."}
{"id": 283, "formal_statement": "theorem dummy : a + b = b + a :=", "nl_statement": "Commutativity of Addition for Rational Numbers\n\nThe theorem states that for any two rational numbers \\(a\\) and \\(b\\), the sum of \\(a\\) and \\(b\\) is equal to the sum of \\(b\\) and \\(a\\). In other words, when adding two rational numbers, the order in which they are added does not affect the result. This property is known as the commutativity of addition."}
{"id": 284, "formal_statement": "theorem dummy (s : Finset Œ±) : edgeDensity r s ‚àÖ = 0 :=", "nl_statement": "The theorem named `edgeDensity_empty_right` states that for any given finite set `s` and relation `r`, the edge density between the set `s` and an empty set is 0. Edge density, in this context, likely measures some form of relationship or interaction between elements of two sets under a specific relation `r`."}
{"id": 285, "formal_statement": "theorem dummy : (e.adjustToOrientation x).toBasis.orientation = x :=", "nl_statement": "The theorem named `orientation_adjustToOrientation` states that for a given entity `e` with a method `adjustToOrientation` applied to some orientation `x`, when this adjusted entity is converted to its basis representation (via `.toBasis`), the orientation of this basis is exactly `x`."}
{"id": 286, "formal_statement": "theorem dummy : Tendsto (logb b) atTop atBot :=", "nl_statement": "The theorem `tendsto_logb_atTop_of_base_lt_one` states that for a logarithm function with a base `b` less than one (`0 < b < 1`), the logarithm of `x` tends to negative infinity (`atBot`) as `x` tends to positive infinity (`atTop`)."}
{"id": 287, "formal_statement": "theorem dummy (a : R) : natTrailingDegree (C a) = 0 :=", "nl_statement": "The statement we're discussing concerns the natural trailing degree of a certain type of polynomial. Specifically, it addresses the polynomial that results from taking a constant `a` in the ring `R` and creating a constant polynomial `C a` from it. The statement claims that the natural trailing degree of this constant polynomial is `0`."}
{"id": 288, "formal_statement": "theorem dummy : ‚àÄ as bs : List (Filter Œ±), Forall‚ÇÇ (¬∑ ‚â§ ¬∑) as bs ‚Üí sequence as ‚â§ sequence bs | [], [], Forall‚ÇÇ.nil => le_rfl | _::as, _::bs, Forall‚ÇÇ.cons h hs => seq_mono (map_mono h) (sequence_mono as bs hs) :=", "nl_statement": "The theorem `sequence_mono` states that for any two lists of filters, `as` and `bs`, if every element of `as` is less than or equal to the corresponding element in `bs`, then the sequence of `as` is less than or equal to the sequence of `bs`."}
{"id": 289, "formal_statement": "theorem dummy : x ‚àà pi I p ‚Üî ‚àÄ i ‚àà I, x i ‚àà p i :=", "nl_statement": "The statement given is about an element `x` belonging to a product space, specifically `pi I p`. It states that `x` is an element of `pi I p` if and only if, for every index `i` in the index set `I`, the component of `x` at `i` belongs to the space `p i`."}
{"id": 290, "formal_statement": "theorem dummy : (s / t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=", "nl_statement": "The statement concerns the non-emptiness of the division of two sets, \\(s\\) and \\(t\\). Specifically, it asserts that the set resulting from the division of \\(s\\) by \\(t\\) (denoted as \\(s / t\\)) is non-empty if and only if both \\(s\\) and \\(t\\) are non-empty."}
{"id": 291, "formal_statement": "theorem dummy : MeasurableSet (Ioc a b) :=", "nl_statement": "The statement declares that the interval \\( (a, b] \\), which is open on the left side and closed on the right side, is a measurable set."}
{"id": 292, "formal_statement": "theorem dummy (H : ‚àÄ x h, P x h ‚Üî Q x h) : (‚àÄ x h, P x h) ‚Üî ‚àÄ x h, Q x h :=", "nl_statement": "The statement given can be translated into the following natural language problem:\n\n\"Given any property P and Q, if for all elements x and for all conditions h, property P holds for x and h if and only if property Q holds for x and h, then the statement that P holds for all x and h is equivalent to the statement that Q holds for all x and h.\""}
{"id": 293, "formal_statement": "theorem dummy : Differentiable ‚Ñù cos :=", "nl_statement": "The statement in question asserts that the cosine function is differentiable for all real numbers. In mathematical terms, it's saying that for every real number \\(x\\), there exists a derivative of the cosine function at \\(x\\)."}
{"id": 294, "formal_statement": "theorem dummy {v‚ÇÅ v‚ÇÇ : RayVector R M} : -v‚ÇÅ ‚âà -v‚ÇÇ ‚Üî v‚ÇÅ ‚âà v‚ÇÇ :=", "nl_statement": "The statement concerns a property about two vectors (denoted `v‚ÇÅ` and `v‚ÇÇ`) within the context of RayVectors in some mathematical space (represented by `R` and `M`). Specifically, the theorem asserts an equivalence relationship between the negation of these vectors. It states that the negation of `v‚ÇÅ` is equivalent to the negation of `v‚ÇÇ` if and only if `v‚ÇÅ` itself is equivalent to `v‚ÇÇ`."}
{"id": 295, "formal_statement": "theorem dummy (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup :=", "nl_statement": "Given a permutation `f` of some type `Œ±` that forms a cycle (i.e., `f` is a cyclic permutation), the sequence of elements generated by repeatedly applying `f` starting from any element in the cycle (until the cycle is completed) does not contain any duplicate elements."}
{"id": 296, "formal_statement": "theorem dummy [DecidableEq Œ±] (s : Finset Œ±) : s.val.toFinset = s :=", "nl_statement": "The theorem states that for any finite set `s` of type `Œ±`, where `Œ±` is a type for which equality can be decided (indicated by `[DecidableEq Œ±]`), the conversion of the list of elements of `s` back into a finite set results in the original set `s`. In other words, if you take a finite set, list its elements, and then create a finite set from this list, you will end up with the original set you started with."}
{"id": 297, "formal_statement": "theorem dummy {n : ‚Ñï} (i : Fin (n + 1)) : univ.image i.succAbove = {i}·∂ú :=", "nl_statement": "The statement concerns a mathematical property related to the type `Fin (n + 1)`, which represents the set of natural numbers less than `n + 1`. It says that for any element `i` of this type, the image of the universe (considered as the set of all elements of `Fin (n + 1)`) under the function `i.succAbove` is the complement of the singleton set containing `i`.\n\nIn more intuitive terms, if you have a function that maps each element of a finite set of natural numbers (ranging from 0 to `n`) in such a way that each number is mapped to a number above a certain value `i` (excluding `i` itself), then the set of all outputs of this function will be the entire set except for `i`."}
{"id": 298, "formal_statement": "theorem dummy {x : ‚Ñù‚â•0‚àû} : (x : EReal) = ‚ä§ ‚Üî x = ‚ä§ :=", "nl_statement": "The statement provided is about the relationship between two types of mathematical objects in the context of the ‚Ñù‚â•0‚àû and EReal types. Specifically, it concerns an element `x` of the type ‚Ñù‚â•0‚àû (read as \"non-negative extended real numbers,\" which includes all non-negative real numbers along with positive infinity) and its type coercion to EReal (a type that represents the extended real numbers, which includes all real numbers along with negative and positive infinity). The theorem states that coercing `x` from ‚Ñù‚â•0‚àû to EReal and equating it to the top element (positive infinity) in the EReal type is logically equivalent to saying `x` itself is the top element in the ‚Ñù‚â•0‚àû type."}
{"id": 299, "formal_statement": "theorem dummy : ‚Äñ(0 : lp E p)‚Äñ = 0 :=", "nl_statement": "The statement we are examining asserts that the norm of the zero vector in an \\(L^p\\) space \\(E\\) (denoted as \\(\\|0 : lp E p\\|\\)) equals zero. This statement is foundational in functional analysis, where \\(L^p\\) spaces play a crucial role in various applications, including signal processing and quantum mechanics."}
{"id": 300, "formal_statement": "theorem dummy [SemilinearIsometryClass ùìï œÉ‚ÇÅ‚ÇÇ E E‚ÇÇ] (f : ùìï) (x : E) : ‚Äñf x‚Äñ‚Çä = ‚Äñx‚Äñ‚Çä :=", "nl_statement": "The theorem states that for a semilinear isometry \\( f \\) from a vector space \\( E \\) to another vector space \\( E_2 \\), the non-negative norm (or the non-negative version of the norm, also known as the \"nnnorm\") of the image of a vector \\( x \\) under \\( f \\) is equal to the non-negative norm of the vector \\( x \\) itself. This holds in the context where \\( f \\) is a member of a SemilinearIsometryClass, which implies that \\( f \\) preserves the norm of vectors under a semilinear transformation."}
{"id": 301, "formal_statement": "theorem dummy (a : A) : (zmultiplesHom A a).range = zmultiples a :=", "nl_statement": "The theorem states that the range of the `zmultiplesHom` function applied to an element `a` in a set `A` is equal to the set of multiples of `a` (denoted as `zmultiples a`). In mathematical terms, if you have a function that maps any element `a` in a set `A` to its multiples within a certain structure (like a group or ring), the set of all possible outputs (the range) of this function for `a` is exactly the set of all multiples of `a`."}
{"id": 302, "formal_statement": "theorem dummy : toSimpleFunc (0 : Lp.simpleFunc E p Œº) =·µê[Œº] 0 :=", "nl_statement": "The statement at hand expresses a property of a function called `toSimpleFunc` within the context of `Lp` spaces, specifically simple functions in these spaces. The theorem, named `zero_toSimpleFunc`, asserts that applying the `toSimpleFunc` operation to the zero function in the space of simple functions `Lp.simpleFunc E p Œº` yields a function that is almost everywhere (denoted as `=·µê[Œº]`) equal to zero with respect to the measure `Œº`."}
{"id": 303, "formal_statement": "theorem dummy (h‚ÇÅ : s ‚äÜ p) (h‚ÇÇ : p ‚â§ span R s) : span R s = p :=", "nl_statement": "The theorem named `span_eq_of_le` states that if a set `s` is a subset of `p`, and `p` is less than or equal to the span of `s` over a ring `R`, then the span of `s` over `R` is equal to `p`."}
{"id": 304, "formal_statement": "theorem dummy (h : Chain' R l) (n : ‚Ñï) : Chain' R (drop n l) :=", "nl_statement": "The given theorem states that if we have a list `l` where a certain relation `R` holds between every consecutive pair of elements (this property is what `Chain' R l` asserts), then this property still holds for any sublist obtained by dropping the first `n` elements from `l`. This concept is formalized in Lean4 as `Chain'.drop`."}
{"id": 305, "formal_statement": "theorem dummy [PartialOrder Œ±] {a b : Œ±} : (a ‚â† b ‚Üî a < b) ‚Üî a ‚â§ b := haveI :=", "nl_statement": "The statement we are examining asserts a relationship between inequality, strict inequality, and non-strict inequality within a partially ordered set. Specifically, it claims that for any two elements \\(a\\) and \\(b\\) in a partially ordered set, the statement \"a is not equal to b if and only if a is less than b\" is equivalent to saying \"a is less than or equal to b\"."}
{"id": 306, "formal_statement": "theorem dummy {p : Ring.DirectLimit G f} (hp : p ‚â† 0) : p * inv G f p = 1 :=", "nl_statement": "The theorem states that for any non-zero element `p` in the direct limit of a directed system of rings (denoted by `G` and `f`), the product of `p` and its inverse (`inv G f p`) is equal to the identity element of the ring, which is `1`. This theorem is a formalization of the familiar algebraic property that any non-zero element in a field has a multiplicative inverse such that their product yields the identity element."}
{"id": 307, "formal_statement": "theorem dummy {X Y Z : FintypeCat} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=", "nl_statement": "The statement concerns a composition of functions within the context of finite categories, specifically denoted as `FintypeCat`. Given three objects `X`, `Y`, and `Z` in this category and two morphisms (functions) `f` from `X` to `Y` and `g` from `Y` to `Z`, the theorem asserts that applying the composition of `f` and `g` to an element `x` in `X` yields the same result as first applying `f` to `x` to get an element in `Y`, and then applying `g` to this result."}
{"id": 308, "formal_statement": "theorem dummy (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w :=", "nl_statement": "The theorem named `mem_support` concerns a subgraph `H` of a graph `G`. It states that a vertex `v` belongs to the support of `H` if and only if there exists another vertex `w` such that `v` and `w` are adjacent in `H`."}
{"id": 309, "formal_statement": "theorem dummy (u : ZFSet) : u = ‚àÖ ‚à® u.Nonempty :=", "nl_statement": "The theorem states that for any set \\(u\\) in the context of Zermelo-Fraenkel set theory (represented as `ZFSet`), it is either the case that \\(u\\) is equal to the empty set (denoted as \\(‚àÖ\\)) or \\(u\\) is nonempty. This is a fundamental property of sets, asserting that a set must either contain no elements or contain at least one element."}
{"id": 310, "formal_statement": "theorem dummy [Preorder Œ±] [NoBotOrder Œ±] : Unbounded (¬∑ > ¬∑) (@Set.univ Œ±) :=", "nl_statement": "The statement concerns a property in a mathematical setting where we have a type `Œ±` that forms a preorder and has a property called `NoBotOrder`. This property implies that there is no \"bottom\" element in `Œ±`, or in other words, there is no element that is less than every other element in the set. The theorem states that for any element in the universal set of `Œ±`, there exists another element in `Œ±` that is greater than it, signifying that the set is unbounded with respect to the greater-than relation."}
{"id": 311, "formal_statement": "theorem dummy {x y : Œ±} : Associated (normalize x) y ‚Üî Associated x y :=", "nl_statement": "The statement concerns the relationship between two elements, `x` and `y`, within a given algebraic structure, denoted by `Œ±`. It claims that the element obtained by normalizing `x` is associated with `y` if and only if `x` itself is associated with `y`. This presents a bidirectional condition reflecting on the intrinsic properties of association and normalization within the algebraic context."}
{"id": 312, "formal_statement": "theorem dummy (h : e.IsImage s t) : e '' (e.source ‚à© s) = e.target ‚à© t :=", "nl_statement": "The theorem states that for a given equivalence relation `e` that establishes an image relationship between two sets `s` and `t`, the image of the intersection of `e`'s source with `s` under `e` is equal to the intersection of `e`'s target with `t`."}
{"id": 313, "formal_statement": "theorem dummy (ha : IsBot a) (h : b ‚â§ a) : IsBot b :=", "nl_statement": "The statement concerns a property about something called `IsBot`. Specifically, it states that if `a` is a bottom element (`IsBot a`), and `b` is less than or equal to `a` (`b ‚â§ a`), then `b` is also a bottom element (`IsBot b`)."}
{"id": 314, "formal_statement": "theorem dummy {r p : ‚Ñù‚â•0} (h : p ‚â† 0) : r < p‚Åª¬π ‚Üî r * p < 1 :=", "nl_statement": "The statement addresses a property involving two non-negative real numbers, \\(r\\) and \\(p\\), with the condition that \\(p\\) is not equal to zero (\\(p \\neq 0\\)). It asserts that \\(r\\) is less than the multiplicative inverse of \\(p\\) (\\(r < p^{-1}\\)) if and only if the product of \\(r\\) and \\(p\\) is less than 1 (\\(r \\cdot p < 1\\))."}
{"id": 315, "formal_statement": "theorem dummy {x} : IsTotallyDisconnected ({x} : Set Œ±) :=", "nl_statement": "The theorem states that a singleton set, which is a set containing exactly one element, is totally disconnected. In mathematical terms, a set is \"totally disconnected\" if it does not contain any non-trivial connected subset. A \"non-trivial connected subset\" here means a connected set that contains more than one point."}
{"id": 316, "formal_statement": "theorem dummy (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a :=", "nl_statement": "The given statement asserts that if `a` is a positive number (greater than 0) and less than 1, then 1 is less than the reciprocal of `a` (1/a)."}
{"id": 317, "formal_statement": "theorem dummy {R S : CommRingCat} (f : R ‚âÖ S) : IsLocalRingHom f.hom := { map_nonunit :=", "nl_statement": "The theorem states that for any isomorphism \\(f\\) between two commutative rings \\(R\\) and \\(S\\) in the category of commutative rings, the homomorphism \\(f.hom\\) induced by \\(f\\) is a local ring homomorphism. In mathematical terms, a local ring homomorphism preserves the property of being non-units: if an element in the domain is not a unit (invertible element), its image under the homomorphism is also not a unit in the codomain."}
{"id": 318, "formal_statement": "theorem dummy {a : M} (H : a ‚â§ 1) (n : ‚Ñï) : a ^ n ‚â§ 1 :=", "nl_statement": "The theorem states that for any element `a` in a certain mathematical structure `M` (which is not specified in the given code but typically would be some sort of ordered structure like a ring or a group), if `a` is less than or equal to 1, then any natural number power of `a` (`a ^ n`) is also less than or equal to 1. This is under the assumption that the operation `^` and the comparison `‚â§` are defined in a way consistent with our common understanding in mathematics."}
{"id": 319, "formal_statement": "theorem dummy {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=", "nl_statement": "The statement concerns the relationship between two lists, `s` and `t`, within the context of permutations. Specifically, it asserts that a list `s` is a permutation of list `t` if and only if `s` can be found within the permutations of `t`. This statement is formalized using the notation `s ‚àà permutations t ‚Üî s ~ t`, where `‚àà` denotes membership (i.e., `s` is an element of the permutations of `t`), `‚Üî` denotes logical equivalence (i.e., the statement on the left is true if and only if the statement on the right is true), and `~` denotes that two lists are permutations of each other."}
{"id": 320, "formal_statement": "theorem dummy {s‚ÇÅ s‚ÇÇ : WSeq Œ±} {a : Œ±} : a ‚àà s‚ÇÅ ‚Üí a ‚àà append s‚ÇÅ s‚ÇÇ :=", "nl_statement": "The theorem `mem_append_left` is about sequences in a generic type `Œ±` and involves two sequences, `s‚ÇÅ` and `s‚ÇÇ`. It states that if an element `a` of type `Œ±` is a member of the first sequence `s‚ÇÅ`, then `a` is also a member of the sequence obtained by appending `s‚ÇÅ` to `s‚ÇÇ` (denoted as `append s‚ÇÅ s‚ÇÇ`)."}
{"id": 321, "formal_statement": "theorem dummy : Ioc a c ‚äÜ Ioc a b ‚à™ Icc b c :=", "nl_statement": "The statement \"Ioc_subset_Ioc_union_Icc\" asserts that the interval (a, c] is a subset of the union of the intervals (a, b) and [b, c], where (a, b) denotes an open interval that includes all real numbers greater than a and less than b, and [b, c] denotes a closed interval that includes all real numbers greater than or equal to b and less than or equal to c."}
{"id": 322, "formal_statement": "theorem dummy : ‚àÄ n, yn a1 n ‚â° n [MOD 2] | 0 => by rfl | 1 => by simp; rfl | n + 2 => (yn_modEq_two n).add_right_cancel <| by rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))] exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat :=", "nl_statement": "The theorem states that for any natural number \\(n\\), the value of \\(yn(a1, n)\\) is congruent to \\(n\\) modulo 2. In simpler terms, when \\(yn(a1, n)\\) is divided by 2, it leaves the same remainder as \\(n\\) when \\(n\\) is divided by 2."}
{"id": 323, "formal_statement": "theorem dummy {c : E} : a * c ‚àà closedBall (b * c) r ‚Üî a ‚àà closedBall b r :=", "nl_statement": "The statement concerns a property related to the concept of a closed ball in a metric space, specifically focusing on the multiplication operation within such a space. In natural language, the theorem can be stated as follows: For any element \\(c\\) in a space \\(E\\), another element \\(a\\) multiplied by \\(c\\) belongs to the closed ball centered at \\(b \\cdot c\\) with radius \\(r\\) if and only if \\(a\\) itself belongs to the closed ball centered at \\(b\\) with the same radius \\(r\\)."}
{"id": 324, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ¥) (p : Œ± √ó Œ≤) : Prod.map f g p = (f p.1, g p.2) :=", "nl_statement": "The statement concerns a function that operates on a product (or pair) of two types, \\(\\alpha \\times \\beta\\), and maps each element of this pair to a new pair formed by applying two functions, \\(f : \\alpha \\rightarrow \\gamma\\) and \\(g : \\beta \\rightarrow \\delta\\), to the respective elements of the original pair. The theorem asserts that the result of applying the `Prod.map` function with \\(f\\) and \\(g\\) to a pair \\(p\\), where \\(p\\) is an element of type \\(\\alpha \\times \\beta\\), is equal to a new pair formed by applying \\(f\\) to the first element of \\(p\\) and \\(g\\) to the second element of \\(p\\)."}
{"id": 325, "formal_statement": "theorem dummy (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=", "nl_statement": "The theorem states that for any element \\(x\\) in a field \\(F\\), the square root of the norm squared of \\(x\\) is equal to the norm of \\(x\\). In mathematical notation, this can be written as \\(\\sqrt{\\|x\\|^2} = \\|x\\|\\), where \\(\\|x\\|\\) denotes the norm of \\(x\\), and \\(\\|x\\|^2\\) denotes the norm of \\(x\\) squared."}
{"id": 326, "formal_statement": "theorem dummy : Isometry f :=", "nl_statement": "The statement in question declares that a function `f` is an isometry. This means that `f` preserves distances between points according to some metric, typically the Euclidean distance in many contexts. The proof relies on demonstrating this property by showing that the norm (or length) of the image of a vector under `f` is the same as the norm of the vector itself, which is a core characteristic of isometric functions."}
{"id": 327, "formal_statement": "theorem dummy : a ‚àÜ b = c ‚àÜ b ‚Üî a = c :=", "nl_statement": "The theorem presented states that the symmetric difference of sets \\(a\\) and \\(b\\) is equal to the symmetric difference of sets \\(c\\) and \\(b\\) if and only if \\(a\\) is equal to \\(c\\). In mathematical notation, this is represented as \\(a \\Delta b = c \\Delta b \\leftrightarrow a = c\\)."}
{"id": 328, "formal_statement": "theorem dummy (s : Multiset Œ±) : s.gcd = 0 ‚Üî ‚àÄ x : Œ±, x ‚àà s ‚Üí x = 0 :=", "nl_statement": "The statement concerns the greatest common divisor (gcd) of a multiset \\(s\\) of elements from a certain type \\(\\alpha\\), and it claims that the gcd of \\(s\\) is zero if and only if every element \\(x\\) in \\(s\\) is equal to zero."}
{"id": 329, "formal_statement": "theorem dummy : hasse (Œ± √ó Œ≤) = hasse Œ± ‚ñ° hasse Œ≤ :=", "nl_statement": "The statement given as a theorem involves a concept called the \"Hasse diagram\" for a partially ordered set, along with a product operation on two sets, \\(\\alpha\\) and \\(\\beta\\). The theorem claims that the Hasse diagram of the product of two sets \\(\\alpha \\times \\beta\\) is equal to the \"box product\" (denoted by ‚ñ°) of the Hasse diagrams of \\(\\alpha\\) and \\(\\beta\\)."}
{"id": 330, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) (s : Computation Œ±) : Terminates (map f s) ‚Üî Terminates s := ‚ü®fun ‚ü®‚ü®_, h‚ü©‚ü© => let ‚ü®_, h1, _‚ü© :=", "nl_statement": "The statement concerns the relationship between two computations in a context where computations can be transformed by a function. Specifically, it addresses whether applying a function `f` to each element in a computation `s` affects its termination property. The theorem states that a computation `s` of type `Œ±` mapped to a computation of type `Œ≤` through a function `f` terminates if and only if the original computation `s` terminates."}
{"id": 331, "formal_statement": "theorem dummy (h : SeparatedNhds s t) : Disjoint s (closure t) :=", "nl_statement": "The problem statement given is about proving a particular property involving two sets, \\(s\\) and \\(t\\), in the context of topology. Specifically, the statement asserts that if the neighborhoods of \\(s\\) and \\(t\\) are separated (i.e., \\(s\\) and \\(t\\) are separated by neighborhoods), then \\(s\\) and the closure of \\(t\\) are disjoint. In simpler terms, this means there are no common elements between set \\(s\\) and the closure of set \\(t\\) under the condition that \\(s\\) and \\(t\\) themselves are separated by neighborhoods."}
{"id": 332, "formal_statement": "theorem dummy (x y y' : M) : polar Q x (y - y') = polar Q x y - polar Q x y' :=", "nl_statement": "The theorem `polar_sub_right` concerns a mathematical structure known as a quadratic form, denoted by `Q`, defined over some module `M`. The statement of the theorem is about the polar form of the quadratic form, which is a specific way to associate pairs of vectors from `M` with scalars. Specifically, the theorem states that for any three elements `x`, `y`, and `y'` in `M`, the polar form of `Q` evaluated at `x` and the difference `y - y'` is equal to the difference of the polar form of `Q` evaluated at `x` and `y`, and the polar form of `Q` evaluated at `x` and `y'`."}
{"id": 333, "formal_statement": "theorem dummy (a : M) (S T : Subsemiring R) : a ‚Ä¢ (S ‚äî T) = a ‚Ä¢ S ‚äî a ‚Ä¢ T :=", "nl_statement": "The statement concerns a mathematical property within the context of ring theory, particularly within subsemirings of a ring \\(R\\) and scalar multiplication. The theorem can be stated in natural language as follows:\n\n\"For any element \\(a\\) from a module \\(M\\) and any two subsemirings \\(S\\) and \\(T\\) of a ring \\(R\\), the scalar multiplication of \\(a\\) with the supremum (least upper bound) of \\(S\\) and \\(T\\) is equal to the supremum of the scalar multiplication of \\(a\\) with \\(S\\) and \\(T\\).\"\n\nIn simpler terms, if you take two subsets within a ring that are closed under addition and multiplication (subsemirings), combine them to form their supremum (which is essentially their 'union' but in the context of the lattice structure that subsemirings form under inclusion), and then multiply every element of this combination by a certain element from a module, you'll get the same result as if you multiplied every element of each subsemiring by this element and then took the supremum of the results."}
{"id": 334, "formal_statement": "theorem dummy (s t : UpperSet Œ±) : (s ‚äî t).compl = s.compl ‚äî t.compl :=", "nl_statement": "The theorem states that the complement of the supremum (also known as the union in this context) of two upper sets \\(s\\) and \\(t\\) is equal to the supremum of the complements of \\(s\\) and \\(t\\)."}
{"id": 335, "formal_statement": "theorem dummy (x : R) : algebraMap R (TensorAlgebra R M) x = 0 ‚Üî x = 0 :=", "nl_statement": "The statement we're looking at concerns the conditions under which the algebra map from a ring \\(R\\) to the tensor algebra over \\(R\\) and a module \\(M\\), applied to an element \\(x\\) of \\(R\\), yields zero. Specifically, it asserts that this algebra map sends \\(x\\) to zero if and only if \\(x\\) itself is zero."}
{"id": 336, "formal_statement": "theorem dummy {x y : Œ±} {s : Set Œ±} (hx : x = y) (h : y ‚àà s) : x ‚àà s :=", "nl_statement": "The statement concerns a scenario within a set theory context. It asserts that if two elements, `x` and `y`, are considered to be equivalent (x = y), and `y` is a member of a set `s`, then `x` also belongs to the set `s`. This theorem underlines the transitive property of element membership in relation to equivalence of elements."}
{"id": 337, "formal_statement": "theorem dummy (x y : R) : star (x * star y) = y * star x :=", "nl_statement": "The theorem named \"star_mul_star\" concerns two elements, \\( x \\) and \\( y \\), in a certain set \\( R \\). It states that the \"star\" of the product of \\( x \\) and the \"star\" of \\( y \\) is equal to the product of \\( y \\) and the \"star\" of \\( x \\). In mathematical terms, this is expressed as: \\( \\text{star}(x \\cdot \\text{star}(y)) = y \\cdot \\text{star}(x) \\)."}
{"id": 338, "formal_statement": "theorem dummy (h : Irrational x) : Irrational (x - q) :=", "nl_statement": "The statement asserts that if a number \\(x\\) is irrational, then the result of subtracting any rational number \\(q\\) from \\(x\\) is also irrational."}
{"id": 339, "formal_statement": "theorem dummy (ht : Independent t) : SetIndependent <| range t :=", "nl_statement": "The statement concerns the concept of independence in a complete lattice, specifically targeting the scenario where a set is considered independent if, informally speaking, no element of the set can be represented as a combination (in terms of the lattice operations) of the other elements in the set. The theorem states that if a set `t` is independent, then the set obtained from the range of `t` is also independent."}
{"id": 340, "formal_statement": "theorem dummy : closure (range Œπ) = univ :=", "nl_statement": "The statement we're looking at says that the closure of the range of a certain function (let's call it Œπ) is equal to the entire set (univ, which stands for the universe, essentially meaning everything in the context of this discussion).\n\nIn simpler terms, this theorem is claiming that if you take all the values that the function Œπ can produce (that's the range of Œπ), and then you include not just these values but also all the points you can get infinitely close to (that's the closure of the range), you end up covering everything in the entire space you're considering."}
{"id": 341, "formal_statement": "theorem dummy : HasDerivWithinAt (lineMap a b) (b - a) s x :=", "nl_statement": "The theorem named `hasDerivWithinAt_lineMap` is concerned with differential calculus, particularly focusing on the concept of a derivative within a specified set. The `lineMap` function, given points `a` and `b`, maps any point `x` linearly between them. The theorem states that `lineMap` has a derivative at `x` within a set `s`, and this derivative is the difference `b - a`."}
{"id": 342, "formal_statement": "theorem dummy [IntCast Œ±] (n : ‚Ñ§) : toDual (n : Œ±) = n :=", "nl_statement": "The theorem `toDual_intCast` states that for any type `Œ±` that has an integer casting operation (denoted by `[IntCast Œ±]`), casting an integer `n` to type `Œ±` and then applying the `toDual` function yields the same result as simply having `n`."}
{"id": 343, "formal_statement": "theorem dummy (f : œÉ ‚Üí MvPolynomial œÑ R) : aeval f = bind‚ÇÅ f :=", "nl_statement": "The theorem `aeval_eq_bind‚ÇÅ` states that the operation of algebraic evaluation (`aeval`) of a multivariate polynomial with coefficients in a ring `R` and variables in sets `œÉ` and `œÑ`, when applied to a function `f` that maps elements of `œÉ` to multivariate polynomials over `œÑ`, is equivalent to the operation of binding (`bind‚ÇÅ`) the variables of the first set `œÉ` in the multivariate polynomial to the multivariate polynomials provided by the function `f`."}
{"id": 344, "formal_statement": "theorem dummy (n : ‚Ñï) : tan (n * œÄ) = 0 :=", "nl_statement": "The theorem states that the tangent of any integer multiple of œÄ (pi) is equal to 0. This is formally expressed for any natural number \\(n\\)."}
{"id": 345, "formal_statement": "theorem dummy {_m : MeasurableSpace Œ±} : ‚áë(0 : Measure Œ±) = 0 :=", "nl_statement": "The statement given is a theorem concerning a measure (a mathematical concept used to assign a size or volume to subsets of a given space) in the context of a measurable space (a basic structure used in measure theory that allows the measurement of volumes of subsets). The theorem asserts that applying the zero measure (denoted by \\(0 : Measure \\alpha\\), where \\(\\alpha\\) represents the type of elements in the space) to any set within this space yields the value 0. This essentially means that the measure of any set according to the zero measure is 0.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 346, "formal_statement": "theorem dummy : hs.toFinset ‚äÜ ht.toFinset ‚Üî s ‚äÜ t :=", "nl_statement": "The statement expresses a relationship between two sets, \\(s\\) and \\(t\\), and their conversions to finite sets, denoted as \\(hs.toFinset\\) and \\(ht.toFinset\\), respectively. Specifically, it states that the subset relationship between \\(hs.toFinset\\) and \\(ht.toFinset\\) is equivalent to the subset relationship between \\(s\\) and \\(t\\). In simpler terms, it means that \\(s\\) is a subset of \\(t\\) if and only if the finite set version of \\(s\\) is a subset of the finite set version of \\(t\\)."}
{"id": 347, "formal_statement": "theorem dummy {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=", "nl_statement": "The theorem states that for any two objects \\(X\\) and \\(Y\\) in a category \\(C\\), if a morphism \\(f\\) from \\(X\\) to \\(Y\\) is such that when the Yoneda functor is applied to \\(f\\), the result is an isomorphism (denoted by `[IsIso (yoneda.map f)]`), then \\(f\\) itself must be an isomorphism in the category \\(C\\) (denoted by `IsIso f`)."}
{"id": 348, "formal_statement": "theorem dummy (s t : Finset Œ±) : s \\ t = s ‚à© t·∂ú :=", "nl_statement": "The statement `s \\ t = s ‚à© t·∂ú` represents a theorem concerning operations on finite sets, where `\\` denotes the set difference operation, `‚à©` represents the intersection of two sets, and `t·∂ú` denotes the complement of set `t`. In plain English, the theorem states that the difference between two finite sets `s` and `t` (elements in `s` that are not in `t`) is equivalent to the intersection of `s` with the complement of `t` (elements in `s` that are also in the set of all elements not in `t`)."}
{"id": 349, "formal_statement": "theorem dummy {x : Subgraph G} : Function.Injective x.spanningHom :=", "nl_statement": "The theorem we're dealing with states that the function `spanningHom` from a subgraph `x` of a graph `G` is injective. In simpler terms, this means that if we map any two elements from the subgraph `x` to the graph `G` using this `spanningHom` function, and if the mapping results are the same, then those two elements were the same to begin with."}
{"id": 350, "formal_statement": "theorem dummy : lift.principalSeg.{u, u + 1}.top = @type Ordinal (¬∑ < ¬∑) _ :=", "nl_statement": "The statement at hand is about a property of ordinal numbers within the context of set theory, specifically focusing on the concept of \"lifting\" a principal segment in ordinals. In essence, the theorem `lift.principalSeg_top'` asserts that the top element of the lifted principal segment of ordinals at levels `u` and `u + 1` is equivalent to a certain type of ordinal defined by its order relation."}
{"id": 351, "formal_statement": "theorem dummy {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=", "nl_statement": "The theorem states that for any natural number \\(n\\) and any element \\(r\\) from a ring \\(R\\), the equation \\(r \\cdot (-1)^n = 0\\) holds if and only if \\(r = 0\\)."}
{"id": 352, "formal_statement": "theorem dummy {x s : Set Œ±} (h : x ‚äÜ s) : x ‚àà ùí´ s :=", "nl_statement": "The statement concerns the concept of powersets within set theory. Specifically, it asserts that if a set \\(x\\) is a subset of another set \\(s\\), then \\(x\\) belongs to the powerset of \\(s\\). The powerset of a set \\(s\\), denoted as \\(\\mathcal{P}(s)\\), is the set of all possible subsets of \\(s\\), including the empty set and \\(s\\) itself."}
{"id": 353, "formal_statement": "theorem dummy : I * J ‚â§ J :=", "nl_statement": "The theorem states that the product of two ideals \\(I\\) and \\(J\\) within a ring is less than or equal to the ideal \\(J\\)."}
{"id": 354, "formal_statement": "theorem dummy : Ioc a‚ÇÅ b‚ÇÅ ‚à© Ioc a‚ÇÇ b‚ÇÇ = Ioc (a‚ÇÅ ‚äî a‚ÇÇ) (b‚ÇÅ ‚äì b‚ÇÇ) :=", "nl_statement": "The theorem states that the intersection of two intervals of the form \\( (a_1, b_1] \\) and \\( (a_2, b_2] \\) (where \\( (a, b] \\) denotes the interval of all real numbers greater than \\( a \\) and less than or equal to \\( b \\)), is equal to the interval \\( (\\max(a_1, a_2), \\min(b_1, b_2)] \\). In more mathematical terms, it's expressed as:\n\\[ (a_1, b_1] \\cap (a_2, b_2] = (\\max(a_1, a_2), \\min(b_1, b_2)] \\]"}
{"id": 355, "formal_statement": "theorem dummy {f : Œ± ‚Üí Œ≤} (c : Œ≤) (hf : f ‚â§·µê[Œº] fun _ => c) : essSup f Œº ‚â§ c :=", "nl_statement": "The statement deals with a concept in measure theory, particularly focusing on the essential supremum of a function \\(f\\) from a set \\(\\alpha\\) to a set \\(\\beta\\), with respect to a measure \\(\\mu\\). The essential supremum, denoted as \\(essSup\\ f\\ \\mu\\), is the least upper bound in \\(\\beta\\) of the set of values that \\(f\\) takes \\(\\mu\\)-almost everywhere (except possibly on a set of measure zero). The lemma asserts that if \\(f\\) is less than or equal to a constant \\(c\\) almost everywhere (denoted by \\(f ‚â§·µê[Œº] \\text{fun} _ => c\\)), then the essential supremum of \\(f\\) with respect to \\(\\mu\\) is less than or equal to \\(c\\)."}
{"id": 356, "formal_statement": "theorem dummy {n : ‚Ñï} (n1 : n ‚â† 1) : minFacProp n (minFac n) :=", "nl_statement": "The statement we're examining asserts that for any natural number \\(n\\) different from 1, the smallest prime factor of \\(n\\) (denoted as `minFac n`) possesses certain properties encapsulated by `minFacProp`. Specifically, these properties ensure that `minFac n` is indeed a prime factor of \\(n\\) and adheres to certain conditions that are fundamental to the definition of a smallest prime factor."}
{"id": 357, "formal_statement": "theorem dummy : (f / g).NeBot ‚Üí f.NeBot :=", "nl_statement": "The theorem named `NeBot.of_div_left` states that if the division of `f` by `g` (denoted as `f / g`) is not bot (bottom), then `f` itself is not bot. In the context of this theorem, \"bot\" typically represents a bottom type or value in type theory and programming, often used to denote a computation that never successfully terminates or a value that represents failure or the absence of a value. Therefore, the theorem asserts that if dividing `f` by `g` results in a meaningful or valid outcome, then `f` must also be meaningful or valid."}
{"id": 358, "formal_statement": "theorem dummy (n : ‚Ñï) : fib (bit0 n + 1) = fib (n + 1) ^ 2 + fib n ^ 2 :=", "nl_statement": "The statement says that for any natural number \\(n\\), the Fibonacci number at position \\(2n + 1\\) (which can be written as `bit0 n + 1` in Lean4, where `bit0 n` represents \\(2n\\)) is equal to the square of the Fibonacci number at position \\(n + 1\\) plus the square of the Fibonacci number at \\(n\\)."}
{"id": 359, "formal_statement": "theorem dummy {b : Œ≤} : s √óÀ¢ {b} = s.map ‚ü®fun i => (i, b), Prod.mk.inj_right _‚ü© :=", "nl_statement": "The statement at hand involves a lemma regarding the Cartesian product of a set `s` with a singleton set containing an element `b`. Specifically, it asserts that the Cartesian product of `s` with a singleton set `{b}` is equivalent to the set obtained by mapping each element `i` in `s` to a pair `(i, b)`. This is expressed in the form of an equation: `s √óÀ¢ {b} = s.map ‚ü®fun i => (i, b), Prod.mk.inj_right _‚ü©`."}
{"id": 360, "formal_statement": "theorem dummy (f : Œ± ‚Üío Œ≤ ‚Üío Œ≥) (x : Œ± √ó Œ≤) : curry.symm f x = f x.1 x.2 :=", "nl_statement": "The given theorem `curry_symm_apply` concerns the operation of currying in the context of order-preserving functions, denoted by `Œ± ‚Üío Œ≤ ‚Üío Œ≥`, where `Œ±`, `Œ≤`, and `Œ≥` are types. In simple terms, currying is a technique that transforms a function that takes multiple arguments into a sequence of functions, each with a single argument. Specifically, this theorem addresses the symmetric uncurrying of a function `f` that maps an argument of type `Œ±` to another function, which in turn maps an argument of type `Œ≤` to an output of type `Œ≥`. The theorem states that for a function `f : Œ± ‚Üío Œ≤ ‚Üío Œ≥` and a pair `x` consisting of `Œ± √ó Œ≤`, applying the uncurried version of `f` to `x` yields the same result as applying `f` to the first element of `x` and then to the second element of `x`."}
{"id": 361, "formal_statement": "theorem dummy : exp (œÄ * I) = -1 :=", "nl_statement": "The statement given is: \"exp (œÄ * I) = -1\". This means we are examining the exponential function when its input is œÄ times the imaginary unit \\(I\\), and asserting that the result of this expression is -1. In more familiar mathematical terms, this is a formal statement of Euler's famous identity \\(e^{i\\pi} + 1 = 0\\), which connects five fundamental mathematical constants: the base of the natural logarithm \\(e\\), the imaginary unit \\(i\\), the constant \\(\\pi\\), the number 1, and the number 0."}
{"id": 362, "formal_statement": "theorem dummy : a ‚à£ b - c ‚Üî a ‚à£ c - b :=", "nl_statement": "The statement concerns the divisibility properties of integers. In particular, it asserts that for any integers `a`, `b`, and `c`, the integer `a` divides `b - c` if and only if `a` divides `c - b`.\n\nIn mathematical terms, using the divisibility notation where `a ‚à£ x` denotes \"a divides x\", the theorem can be expressed as:\n\nFor all integers `a`, `b`, and `c`, `a ‚à£ (b - c)` if and only if `a ‚à£ (c - b)`."}
{"id": 363, "formal_statement": "theorem dummy (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=", "nl_statement": "The statement to be proven is that the tangent of an angle (x) added to an integer multiple of œÄ (where œÄ represents the constant pi, approximately equal to 3.14159) is equal to the tangent of that angle (x) itself. Mathematically, this can be written as tan(x + nœÄ) = tan(x), where x is a real number and n is an integer."}
{"id": 364, "formal_statement": "theorem dummy : ‚àÄ z : ‚Ñ§, Continuous fun a : G => a ^ z | Int.ofNat n => by simpa using continuous_pow n | Int.negSucc n => by simpa using (continuous_pow (n + 1)).inv :=", "nl_statement": "The theorem states that for any integer \\( z \\), the function \\( a \\mapsto a^z \\) (where \\( a \\) is raised to the power of \\( z \\)) is continuous in the context of a certain mathematical space \\( G \\). This means that small changes in \\( a \\) result in small changes in \\( a^z \\), for any integer value of \\( z \\)."}
{"id": 365, "formal_statement": "theorem dummy [‚àÄ i, Sup (Œ±' i)] (f g : ‚àÄ i, Œ±' i) : f ‚äî g = fun i => f i ‚äî g i :=", "nl_statement": "The theorem states that for any indexed family of sets \\(\\alpha'\\) where each set has a supremum (least upper bound), and for any two functions \\(f\\) and \\(g\\) from the index set to the elements of these sets, the supremum of \\(f\\) and \\(g\\) is equal to the function that maps each index \\(i\\) to the supremum of \\(f(i)\\) and \\(g(i)\\)."}
{"id": 366, "formal_statement": "theorem dummy : ‚àÄ n, unaryDecodeNat (unaryEncodeNat n) = n :=", "nl_statement": "The theorem states that for every natural number \\(n\\), if you encode \\(n\\) into a unary representation and then decode it back to a natural number, you will get \\(n\\) back. This essentially proves the correctness of the unary encoding and decoding processes for natural numbers."}
{"id": 367, "formal_statement": "theorem dummy {l : List Œ±} ‚¶Éx‚¶Ñ (h : x ‚àà revzip (powersetAux l)) : x.1 + x.2 = ‚Üël :=", "nl_statement": "The statement concerns a property of pairs (x) generated by the `revzip` function applied to the `powersetAux` of a list (l). Specifically, it claims that for any such pair (x), the sum of the elements of the pair equals the list (l) from which the powerset was generated, when the list is considered as a set (hence the type coercion to a set, indicated by `‚Üël`)."}
{"id": 368, "formal_statement": "theorem dummy [SMul R Œ±] (r : R) (f : m ‚Üí n ‚Üí Œ±) : r ‚Ä¢ of f = of (r ‚Ä¢ f) :=", "nl_statement": "The theorem in question states that if you scale (multiply) all elements of a matrix by a scalar value, this operation is equivalent to creating a matrix from a function that has already been scaled by that scalar. In more formal terms, given a ring \\(R\\) and a type \\(\\alpha\\) equipped with a scalar multiplication operation `SMul`, for any scalar \\(r\\) in \\(R\\), and any function \\(f\\) from \\(m \\times n\\) to \\(\\alpha\\) (which can be thought of as generating the elements of an \\(m \\times n\\) matrix), scaling the matrix generated by \\(f\\) by \\(r\\) is the same as generating a matrix from the function \\(f\\) that has already been scaled by \\(r\\)."}
{"id": 369, "formal_statement": "theorem dummy : Surjective ((‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±) :=", "nl_statement": "The statement to be proven is that the function which maps elements from the FreeRing of a type `Œ±` to the FreeCommRing of the same type (denoted as `(‚Üë) : FreeRing Œ± ‚Üí FreeCommRing Œ±`) is surjective. This means that for every element in the FreeCommRing of type `Œ±`, there exists at least one element in the FreeRing of the same type that maps to it."}
{"id": 370, "formal_statement": "theorem dummy : ‚àÄ a l, length (scanl f a l) = l.length + 1 | a, [] => rfl | a, x :: l => by rw [scanl, length_cons, length_cons, ‚Üê succ_eq_add_one, congr_arg succ] exact length_scanl _ _ :=", "nl_statement": "The theorem states that for any initial value `a` and any list `l`, the length of the list obtained by applying the `scanl` function (which accumulates results of applying a function `f` starting with an initial value across the list `l`) is equal to the length of the original list `l` plus one."}
{"id": 371, "formal_statement": "theorem dummy (e : Œ± ‚âÉo Œ≤) (s : Set Œ≤) : e.symm ‚Åª¬π' (e ‚Åª¬π' s) = s :=", "nl_statement": "The statement concerns a theorem about the preimage of a set under a bijective (specifically, order-preserving) function and its inverse. Given an order-preserving bijection \\(e\\) from a type \\(\\alpha\\) to a type \\(\\beta\\), and a set \\(s\\) of type \\(\\beta\\), the theorem states that taking the preimage of \\(s\\) under \\(e\\), and then taking the preimage of this result under the inverse of \\(e\\) (\\(e^{-1}\\)), yields the original set \\(s\\).\n\nIn simpler terms, if you apply a reversible transformation to move from one space to another, and then apply the reverse of that transformation to go back, you end up exactly where you started."}
{"id": 372, "formal_statement": "theorem dummy [Neg Œ±] (f : m ‚Üí n ‚Üí Œ±) : -of f = of (-f) :=", "nl_statement": "This theorem states that for any type `Œ±` that has a negation operation defined on it (denoted by `[Neg Œ±]`), and for any function `f` that takes two inputs of types `m` and `n` and returns a value of type `Œ±`, the negation of the function `f` applied to some structure (denoted by `-of f`) is equal to applying the same structure to the negation of `f` (denoted by `of (-f)`).\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 373, "formal_statement": "theorem dummy : x \\ (y \\ z) = x \\ y ‚äî x ‚äì y ‚äì z :=", "nl_statement": "The statement to be proven is about the relationship between sets and operations such as set difference (\\), union (‚äî), and intersection (‚äì). Specifically, the theorem `sdiff_sdiff_right` asserts that for any sets x, y, and z, the set difference of x and the set difference of y and z (written as x \\ (y \\ z)) is equal to the union of the set difference of x and y (x \\ y) with the intersection of x, y, and z (x ‚äì y ‚äì z)."}
{"id": 374, "formal_statement": "theorem dummy (s : Set Œ±) : sSup s = ‚®Ü a : s, (a : Œ±) :=", "nl_statement": "The theorem `sSup_eq_iSup'` states that for any set `s` of elements of type `Œ±`, the supremum of `s` (denoted as `sSup s`) is equal to the least upper bound (supremum) of the set of elements `a` in `s` treated as elements of type `Œ±`."}
{"id": 375, "formal_statement": "theorem dummy [Inhabited Œ±] : ‚àÄ {l : List Œ±}, l ‚â† [] ‚Üí head! l ‚àà head? l | [], h => by contradiction | a :: l, _ => rfl :=", "nl_statement": "The statement declares that for any non-empty list of elements of type `Œ±` (with `Œ±` being a type that has at least one element, denoted by `[Inhabited Œ±]`), the first element of the list (obtained by `head!`) is contained within the optional result produced by `head?`. Essentially, this theorem is about ensuring that if you have a non-empty list and you try to get its first element in two different ways (`head!` for a guaranteed element and `head?` for an optional element), the element obtained by the first method (`head!`) is indeed the same as that encapsulated within the optional result of the second method (`head?`)."}
{"id": 376, "formal_statement": "theorem dummy (h : LeftInvOn f' f s) : EqOn (f' ‚àò f) id s :=", "nl_statement": "The theorem states that if there is a function `f'` which is the left inverse of function `f` on a set `s`, then the composition of `f'` and `f` is the identity function on `s`."}
{"id": 377, "formal_statement": "theorem dummy (x y : M‚ÇÄ) (h : IsUnit x) : y * inverse x * x = y :=", "nl_statement": "The theorem states that for any elements \\(x\\) and \\(y\\) in a monoid \\(M‚ÇÄ\\) with a multiplicative inverse (under the condition that \\(x\\) is a unit, meaning it has an inverse in \\(M‚ÇÄ\\)), the operation of multiplying \\(y\\) by the inverse of \\(x\\) and then by \\(x\\) itself results in \\(y\\). This can be summarized as: if \\(x\\) has an inverse in \\(M‚ÇÄ\\), then \\(y \\times x^{-1} \\times x = y\\)."}
{"id": 378, "formal_statement": "theorem dummy (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b ‚äî c) :=", "nl_statement": "The theorem states that if set \\(a\\) is disjoint from set \\(b\\) and also disjoint from set \\(c\\), then set \\(a\\) is disjoint from the union of sets \\(b\\) and \\(c\\) (denoted as \\(b \\cup c\\) or \\(b \\supset c\\))."}
{"id": 379, "formal_statement": "theorem dummy {s : Set Œ±} (hs : s.Finite) (t : Set Œ±) : (s \\ t).Finite :=", "nl_statement": "The theorem states that if you have a finite set `s`, then the difference between set `s` and any other set `t` (denoted as `s \\ t`) is also finite.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 380, "formal_statement": "theorem dummy (n : ‚Ñï) : ‚Äñ(n : ‚Ñ§)‚Äñ = n :=", "nl_statement": "The theorem states that for any natural number \\( n \\), the norm (or absolute value) of \\( n \\) when it is considered as an integer is equal to \\( n \\) itself."}
{"id": 381, "formal_statement": "theorem dummy (hœÜ : IsSymmetric œÜ) (f : R ‚Üí+* S) : IsSymmetric (map f œÜ) :=", "nl_statement": "The problem statement is about proving that if a polynomial œÜ is symmetric in a ring R, then its image under a ring homomorphism f from R to another ring S is also symmetric. In mathematical terms, a polynomial is symmetric if it remains unchanged under any permutation of its variables. The map function here applies the ring homomorphism f to each coefficient of the polynomial œÜ, producing a new polynomial in ring S. The goal is to show that this operation preserves the symmetry of œÜ."}
{"id": 382, "formal_statement": "theorem dummy (ht : (1 : Œ±) ‚àà t) : univ * t = univ :=", "nl_statement": "The statement we're dealing with is a theorem regarding universal sets and multiplication in the context of set theory. The theorem can be phrased as follows: If the number 1 is a member of set \\(t\\), then the product of the universal set and \\(t\\) is equal to the universal set."}
{"id": 383, "formal_statement": "theorem dummy [h : IsSeparable F E] : IsSeparable F K := ‚ü®fun x ‚Ü¶ have ‚ü®_q, hq‚ü© :=", "nl_statement": "The statement we're discussing asserts that if a field extension \\(E\\) over \\(F\\) is separable, then any intermediate field \\(K\\) (where \\(F \\subseteq K \\subseteq E\\)) is also separable over \\(F\\)."}
{"id": 384, "formal_statement": "theorem dummy [FiniteDimensional K V] : (finrank K V : Cardinal.{v}) = Module.rank K V :=", "nl_statement": "The statement provided declares that for a vector space \\(V\\) over a field \\(K\\), when \\(V\\) is finite-dimensional, the finite dimension (or finrank) of \\(V\\) over \\(K\\) is equal to the rank of \\(V\\) over \\(K\\). Here, the finite dimension (finrank) refers to the number of vectors in a basis of the vector space \\(V\\), and the rank refers to the maximum size of a linearly independent subset of \\(V\\)."}
{"id": 385, "formal_statement": "theorem dummy {s : Finset Œ±} (x : (s : Set Œ±)) : ‚Üëx ‚àà s :=", "nl_statement": "This problem involves a theorem related to the membership of an element in a finite set, denoted by `Finset`, in the context of the Lean4 theorem prover. Specifically, the theorem concerns an element `x` of a type-casted finite set `s` (from `Finset` to `Set`) and asserts that this element is indeed a member of the original finite set `s`."}
{"id": 386, "formal_statement": "theorem dummy (h : ‚Äñx‚Äñ = ‚Äñy‚Äñ) : ‚Äñ(1 / 2 : ‚Ñù) ‚Ä¢ (x + y)‚Äñ < ‚Äñx‚Äñ ‚Üî x ‚â† y :=", "nl_statement": "The statement concerns the relationship between two points, \\(x\\) and \\(y\\), in a vector space over the real numbers (\\(\\mathbb{R}\\)). It claims that the norm (length) of the midpoint of the segment joining \\(x\\) and \\(y\\), scaled by \\(1/2\\), is less than the norm of \\(x\\) if and only if \\(x\\) and \\(y\\) are not the same point."}
{"id": 387, "formal_statement": "theorem dummy {Œ± Œ≤} {f g : Embedding Œ± Œ≤} : (‚àÄ x, f x = g x) ‚Üî f = g :=", "nl_statement": "The statement concerns the equivalence of two embeddings, `f` and `g`, from a type `Œ±` to another type `Œ≤`. Specifically, it asserts that for all elements `x` of type `Œ±`, `f` applied to `x` is equal to `g` applied to `x` if and only if `f` is equal to `g` as functions. This is a foundational concept in the theory of functions and embeddings, particularly in the context of functional programming and formal verification."}
{"id": 388, "formal_statement": "theorem dummy (hf : Function.Injective f) : p.map f = 0 ‚Üî p = 0 :=", "nl_statement": "The theorem in question concerns the mapping of a polynomial `p` through a function `f`. Specifically, it states a condition under which the mapped polynomial `p.map f` is equal to the zero polynomial. The condition is based on the injectivity of the function `f`. The theorem asserts that `p.map f` is equal to the zero polynomial if and only if `p` itself is the zero polynomial, given that the function `f` is injective."}
{"id": 389, "formal_statement": "theorem dummy : (equivToOpposite : Œ± ‚Üí Œ±·µí·µñ) = op :=", "nl_statement": "The statement provided describes a theorem about a function named `equivToOpposite` that operates on elements of a type `Œ±` and produces elements of a type `Œ±·µí·µñ`, where `Œ±·µí·µñ` represents the opposite type of `Œ±`. The theorem asserts that this `equivToOpposite` function is equivalent to another function named `op`, which likely takes elements of `Œ±` and also produces elements of the type `Œ±·µí·µñ`."}
{"id": 390, "formal_statement": "theorem dummy : LeftCommutative (min : Œ± ‚Üí Œ± ‚Üí Œ±) :=", "nl_statement": "The statement is about proving that the \"min\" function is left-commutative in the context of a given type `Œ±`. In mathematics and computer science, a function is left-commutative if changing the order of its arguments to the left of a central operation does not change the result. Specifically, this theorem states that for any type `Œ±`, the minimum function `min` exhibits the property where swapping its arguments does not affect the outcome."}
{"id": 391, "formal_statement": "theorem dummy (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 :=", "nl_statement": "The theorem named `finRotate_succ_apply` is about the operation of rotating a finite sequence (or list) of elements of length `n + 1`. The operation \"rotate\" in this context means that each element is moved one position forward in the sequence, and the last element moves to the first position. The statement claims that for any element `i` in a sequence of length `n + 1`, applying the `finRotate` function to `i` is equivalent to incrementing `i` by 1, with a cyclic understanding that after the last position comes the first."}
{"id": 392, "formal_statement": "theorem dummy (hs : s.Nontrivial) : s.einfsep ‚â† ‚àû :=", "nl_statement": "The statement concerns a mathematical structure (let's call it \"s\") and asserts that if \"s\" is nontrivial, then a property of \"s\" termed \"einfsep\" cannot be infinity (‚àû)."}
{"id": 393, "formal_statement": "theorem dummy : s -·µ• (t‚ÇÅ ‚à™ t‚ÇÇ) = s -·µ• t‚ÇÅ ‚à™ (s -·µ• t‚ÇÇ) :=", "nl_statement": "The statement provided is about the vector subtraction (denoted by `-·µ•`) of sets in a mathematical context. It says that if you have a set `s` and you subtract from it the union of two other sets `t‚ÇÅ` and `t‚ÇÇ`, the result is the same as subtracting `t‚ÇÅ` from `s` and `t‚ÇÇ` from `s` separately, and then taking the union of both results."}
{"id": 394, "formal_statement": "theorem dummy (x y z : Œ±) : ‚Äñx ‚äì z - y ‚äì z‚Äñ ‚â§ ‚Äñx - y‚Äñ :=", "nl_statement": "The theorem states that for any three elements \\(x\\), \\(y\\), and \\(z\\) in a certain space \\(\\alpha\\), the norm of the difference between the infimum (greatest lower bound) of \\(x\\) and \\(z\\), and the infimum of \\(y\\) and \\(z\\), is less than or equal to the norm of the difference between \\(x\\) and \\(y\\). In mathematical terms, this can be written as:\n\n\\[\n\\|x \\land z - y \\land z\\| \\leq \\|x - y\\|\n\\]\n\nwhere \\(\\land\\) denotes the infimum operation, and \\(\\|\\cdot\\|\\) denotes the norm."}
{"id": 395, "formal_statement": "theorem dummy : lift.{max v u, u} = lift.{v, u} :=", "nl_statement": "The statement in question asserts a property about a function named `lift` within a specific context, possibly related to ordinals or a similar mathematical structure. The theorem, named `lift_umax'`, proposes that applying the `lift` function with a certain type of type-level parameters (`.{max v u, u}`) results in the same outcome as applying it with another set of parameters (`.{v, u}`). This is a statement about the behavior of the `lift` function under two different, but specific, type scenarios."}
{"id": 396, "formal_statement": "theorem dummy {x : WithOne Œ±} : x ‚â† 1 ‚Üî ‚àÉ a : Œ±, ‚Üëa = x :=", "nl_statement": "The theorem stated in the Lean4 syntax can be translated into natural language as follows:\n\n\"Theorem: For any element \\(x\\) in the extended set \\(WithOne Œ±\\), \\(x\\) is not equal to 1 if and only if there exists an element \\(a\\) in the original set \\(Œ±\\) such that when you extend \\(a\\) to \\(WithOne Œ±\\) (denoted as \\(‚Üëa\\)), it equals \\(x\\).\"\n\nIn simpler terms, this theorem is about understanding when an extended element \\(x\\) (from a set that has been artificially expanded to include a unit element, like 1) is not the artificially added unit element. It asserts that this is the case precisely when \\(x\\) corresponds to some actual element from the original set, after being extended."}
{"id": 397, "formal_statement": "theorem dummy (S T : Submonoid G) : (S ‚äì T)‚Åª¬π = S‚Åª¬π ‚äì T‚Åª¬π :=", "nl_statement": "The theorem states that for any two submonoids \\(S\\) and \\(T\\) of a group \\(G\\), the inverse of their intersection (\\(S \\cap T\\)) is equal to the intersection of their inverses (\\(S^{-1} \\cap T^{-1}\\))."}
{"id": 398, "formal_statement": "theorem dummy : ((‚ä• : L.DefinableSet A Œ±) : Set (Œ± ‚Üí M)) = ‚àÖ :=", "nl_statement": "The given statement is a theorem in the context of formal mathematics, specifically dealing with definable sets within a certain structure `L` over a set `A` of parameters and an arbitrary type `Œ±`, mapping into a model `M`. The theorem states that the coercive interpretation of the bottom element (`‚ä•`) of the lattice of definable sets (`L.DefinableSet A Œ±`) as a set of functions from `Œ±` to `M` is the empty set."}
{"id": 399, "formal_statement": "theorem dummy {f : E ‚Üí‚Çó[ùïú] ùïú} : ‚áëf.toSeminorm = fun x => ‚Äñf x‚Äñ :=", "nl_statement": "The theorem in question states that the seminorm of a linear map \\(f\\) from a vector space \\(E\\) over a field \\(\\mathbb{ùïú}\\) to \\(\\mathbb{ùïú}\\) itself, when applied to any vector \\(x\\) in \\(E\\), is equal to the norm of the output of \\(f\\) acting on \\(x\\). In more familiar terms, this theorem is saying that if you have a linear map \\(f\\) that takes vectors from a space \\(E\\) and outputs elements in \\(\\mathbb{ùïú}\\), then the seminorm of \\(f\\) at any point \\(x\\) is just the norm of \\(f(x)\\), the image of \\(x\\) under \\(f\\)."}
{"id": 400, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) (h : Function.Surjective f) : card Œ≤ ‚â§ card Œ± :=", "nl_statement": "The statement addresses the relationship between the cardinalities (sizes) of two sets, Œ± and Œ≤, given a surjective (onto) function from Œ± to Œ≤. Specifically, it asserts that the cardinality of set Œ≤ (the number of elements in Œ≤) is less than or equal to the cardinality of set Œ± (the number of elements in Œ±) if there exists a surjective function f from Œ± to Œ≤."}
{"id": 401, "formal_statement": "theorem dummy [AddGroup G] (g h : G) : conj g h = g + h + -g :=", "nl_statement": "The statement defines a theorem in the context of an additive group \\( G \\). It states that for any two elements \\( g \\) and \\( h \\) in \\( G \\), the operation `conj g h` is equivalent to the expression \\( g + h + (-g) \\).\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 402, "formal_statement": "theorem dummy {x y : ‚Ñù*} (hx : ¬¨Infinite x) (hy : ¬¨Infinite y) : st (x * y) = st x * st y := have hx' := isSt_st' hx have hy' := isSt_st' hy have hxy :=", "nl_statement": "The theorem concerns the standard part function, denoted as `st`, in the context of hyperreal numbers (`‚Ñù*`). The statement asserts that for any two non-infinite hyperreal numbers `x` and `y`, the standard part of their product equals the product of their standard parts. In simpler terms, if you multiply two non-infinite hyperreal numbers together and then find the standard part of the result, this will be the same as if you found the standard parts of each number first and then multiplied those standard parts together."}
{"id": 403, "formal_statement": "theorem dummy : @Primrec' 2 fun v => v.head + v.tail.head :=", "nl_statement": "The theorem states that the function taking a list of two natural numbers and returning their sum is primitive recursive. In simpler terms, it asserts that the operation of adding the first two numbers in a list is a basic computational process that can be defined using only simple, elementary functions and operations."}
{"id": 404, "formal_statement": "theorem dummy {a : R} (ha : 0 ‚â§ a) : a ^ 2 < 1 ‚Üî a < 1 :=", "nl_statement": "The statement concerns a real number \\(a\\) and establishes a condition about its square, \\(a^2\\), specifically when \\(a^2\\) is less than 1. The condition is expressed in terms of an equivalence (‚Üî), which means the statement is true in both directions: if \\(a^2\\) is less than 1, then \\(a\\) is less than 1, and vice versa. This is given the precondition that \\(a\\) is a non-negative number (\\(0 \\leq a\\))."}
{"id": 405, "formal_statement": "theorem dummy (p : P) : Function.Injective ((¬∑ +·µ• p) : G ‚Üí P) :=", "nl_statement": "The statement provided declares a theorem named `vadd_right_injective`. This theorem states that for a given point `p` in a space `P`, the function that adds a vector from a vector space `G` to `p` (denoted `(¬∑ +·µ• p) : G ‚Üí P`) is injective. In simpler terms, if you take any vector `g` in `G` and add it to `p`, and if the result of adding another vector `g'` to `p` is the same, then `g` and `g'` must be identical. The operation `+·µ•` represents vector addition to a point."}
{"id": 406, "formal_statement": "theorem dummy : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t :=", "nl_statement": "The statement concerns the subsets of two sets, `s‚ÇÅ` and `s‚ÇÇ`, and their relationship after applying an infimum operation with another set `t`. Specifically, if `s‚ÇÅ` is a subset of `s‚ÇÇ` (`s‚ÇÅ ‚äÜ s‚ÇÇ`), then the result of taking the infimum of `s‚ÇÅ` with `t` is a subset of the infimum of `s‚ÇÇ` with `t` (`s‚ÇÅ ‚äº t ‚äÜ s‚ÇÇ ‚äº t`)."}
{"id": 407, "formal_statement": "theorem dummy : (some : Œ± ‚Üí WithBot Œ±) ‚Åª¬π' Ioi a = Ioi a :=", "nl_statement": "The statement to be proven is about the preimage of a function and its relation to a particular kind of set. Specifically, it considers the function `some : Œ± ‚Üí WithBot Œ±`, which takes an element from type `Œ±` and embeds it into the type `WithBot Œ±`. The `WithBot Œ±` type represents all elements of type `Œ±` along with an additional bottom element, which can be thought of as representing the absence of a value or negative infinity in the context of orderings. The statement asserts that the preimage of the interval `(a, +‚àû)` (denoted as `Ioi a` for \"interval open on the right\") under this embedding function is exactly the same set `(a, +‚àû)` within the domain of type `Œ±`."}
{"id": 408, "formal_statement": "theorem dummy {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) :=", "nl_statement": "The theorem named `kernelIsoOfEq_refl` states that given any morphism \\(f\\), and an assumption \\(h\\) that \\(f = f\\) (which is always true by the property of reflexivity), the isomorphism of kernels induced by this equality, denoted as `kernelIsoOfEq h`, is identical to the identity isomorphism on the kernel of \\(f\\), denoted as `Iso.refl (kernel f)`."}
{"id": 409, "formal_statement": "theorem dummy (x : E) : ‚Äñf x‚Äñ = ‚Äñx‚Äñ :=", "nl_statement": "The theorem stated in the Lean4 syntax asserts that for a given function \\(f\\) applied to an element \\(x\\) of a space \\(E\\), the norm (or length) of \\(f(x)\\) is equal to the norm of \\(x\\). This is a formal way to say that the function \\(f\\) preserves the length of the elements it acts upon, which is a property of what's known as a semilinear isometry."}
{"id": 410, "formal_statement": "theorem dummy {x : ‚Ñù} (h : 0 ‚â§ x) : nnabs x = toNNReal x :=", "nl_statement": "The theorem named `nnabs_of_nonneg` concerns real numbers. It states that for any real number `x`, if `x` is non-negative (meaning `x` is greater than or equal to 0), then the non-negative absolute value of `x` (`nnabs x`) is equal to the conversion of `x` to a non-negative real number (`toNNReal x`)."}
{"id": 411, "formal_statement": "theorem dummy : boundedBy (0 : Set Œ± ‚Üí ‚Ñù‚â•0‚àû) = 0 :=", "nl_statement": "The theorem named `boundedBy_zero` is about a function `boundedBy` which takes a set of type `Œ±` and maps it to a non-negative extended real number, denoted by `‚Ñù‚â•0‚àû`. The statement asserts that when `boundedBy` is applied to the empty set (denoted by `0` in this context, which stands for the bottom element of the set lattice, i.e., the smallest set or the empty set), the result is `0`, which, in this context, represents the smallest element in the domain of non-negative extended real numbers, i.e., zero. This theorem essentially claims that the `boundedBy` function assigns a measure of zero to the empty set."}
{"id": 412, "formal_statement": "theorem dummy (a : Œ±) (u : Œ±À£) : a /‚Çö u * u = a :=", "nl_statement": "The theorem states that for any element \\(a\\) in a given set \\(\\alpha\\) and any unit \\(u\\) in \\(\\alpha\\) (an element with a multiplicative inverse in \\(\\alpha\\)), the operation of dividing \\(a\\) by \\(u\\) and then multiplying the result by \\(u\\) yields \\(a\\) itself. In symbolic terms, this is expressed as \\(a /‚Çö u * u = a\\), where \\(a /‚Çö u\\) denotes the division of \\(a\\) by \\(u\\), and \\(*\\) denotes multiplication."}
{"id": 413, "formal_statement": "theorem dummy : ((‚ä§ : OpenSubgroup G) : Opens G) = ‚ä§ :=", "nl_statement": "The theorem states that when you take the top (largest possible) open subgroup of a group \\(G\\) and view it as an open subset of \\(G\\), it is equivalent to the whole space \\(G\\)."}
{"id": 414, "formal_statement": "theorem dummy (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=", "nl_statement": "The statement we're dealing with here expresses a property about a transformation, `iterToSum`, when applied to a specific kind of object, `X b`, within a mathematical framework. This transformation involves two types, `S‚ÇÅ` and `S‚ÇÇ`, and a relation `R`. The core assertion is that applying `iterToSum` to `X b` (where `b` is an element of `S‚ÇÅ`) results in `X (Sum.inl b)`. This is a way of saying that the operation `iterToSum` transforms `X b` into a form that is still recognizable as an `X` object, but now tagged or marked in a way (`Sum.inl`) that reflects its origin or category as belonging to the first part (`S‚ÇÅ`) of a sum type. The sum type here is implicitly `S‚ÇÅ + S‚ÇÇ`, where `+` denotes a sum type or a union of types, and `Sum.inl` is a constructor that injects `b` into the left part of the sum."}
{"id": 415, "formal_statement": "theorem dummy : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M ‚Üí‚Çó[R] M') :=", "nl_statement": "The given theorem is about the relationship between the image of a submodule under a linear map and the map applied to the submodule, within the context of modules over a ring R, with M and M' being R-modules. Specifically, it states that the image of a submodule N under a linear map f, when considered as a submodule of M', is equal to the image of the submodule N of M under the map f, treated as a linear map from M to M'."}
{"id": 416, "formal_statement": "theorem dummy : (0 : Cubic R).toPoly.natDegree = 0 :=", "nl_statement": "The statement asserts that the natural degree of the polynomial corresponding to the zero cubic equation is zero. In simpler terms, it means that if you have a cubic equation that equates to zero, the highest power of x (which is referred to as the natural degree in polynomial mathematics) in its polynomial form is also zero. This essentially indicates that the polynomial has no variables, reflecting a constant value, which is zero in this case."}
{"id": 417, "formal_statement": "theorem dummy (v : V‚ÇÅ) : (constVAdd k P‚ÇÅ v).symm = constVAdd k P‚ÇÅ (-v) :=", "nl_statement": "The theorem presented is about a construct in the context of vector spaces over a field \\(k\\) and pertains to affine spaces. It specifically deals with the symmetry property of a constant vector addition operation within an affine space. The theorem can be stated in natural language as follows:\n\n\"Given any vector \\(v\\) in an affine space \\(V_1\\), the inverse operation of adding a constant vector \\(v\\) to any point in the space is equivalent to adding the negative of that vector (\\(-v\\)) to the point.\""}
{"id": 418, "formal_statement": "theorem dummy (a : Œ±) (s : Multiset Œ±) : {a} + s = a ::‚Çò s :=", "nl_statement": "The theorem in question states that adding a singleton set containing an element \\(a\\) to a multiset \\(s\\) is equivalent to inserting \\(a\\) at the beginning of \\(s\\). In mathematical terms, if you have a set with just one element \\(a\\) and you combine it with another collection of elements \\(s\\), the result is the same as if you just put \\(a\\) in front of every element already in \\(s\\)."}
{"id": 419, "formal_statement": "theorem dummy (s : Finset Œ±) : ‚àÖ \\ s = ‚àÖ :=", "nl_statement": "The theorem states that the symmetric difference between an empty set and any finite set 's' is an empty set. In mathematical terms, this is expressed as ‚àÖ \\ s = ‚àÖ, where '‚àÖ' represents the empty set, 's' is any finite set, and '\\' denotes the symmetric difference operation."}
{"id": 420, "formal_statement": "theorem dummy {f g : Lp E p Œº} (h : f =·µê[Œº] g) : f = g :=", "nl_statement": "The theorem states that for any two functions \\(f\\) and \\(g\\) in the space \\(L^p(E, \\mu)\\) (where \\(E\\) is a set, \\(\\mu\\) is a measure, and \\(p\\) is a real number defining the norm), if \\(f\\) is equal to \\(g\\) almost everywhere (denoted as \\(f =·µê[Œº] g\\)), then \\(f\\) is equal to \\(g\\) in the \\(L^p\\) space."}
{"id": 421, "formal_statement": "theorem dummy : x ‚â° 0 [SMOD U] ‚Üî x ‚àà U :=", "nl_statement": "The statement given is a theorem concerning modular arithmetic and submodules in a mathematical structure, likely a ring or a group. It asserts an equivalence between two conditions involving an element \\(x\\) and a submodule \\(U\\). Specifically, the statement says that \\(x\\) is congruent to \\(0\\) modulo \\(U\\) if and only if \\(x\\) is an element of \\(U\\)."}
{"id": 422, "formal_statement": "theorem dummy (n : ‚Ñï) : norm (n : ‚Ñ§‚àöd) = n * n :=", "nl_statement": "The statement concerns the norm function applied to a natural number `n` that has been cast to an integer in a specific algebraic structure, denoted ‚Ñ§‚àöd. This structure involves numbers of the form a + b‚àöd, where a and b are integers, and d is a fixed integer. The theorem asserts that the norm of `n`, when `n` is considered as an element of this structure (specifically, as an integer without the square root part, i.e., with b = 0), is equal to n squared."}
{"id": 423, "formal_statement": "theorem dummy {s : Finset Œ±} : s.max = s.sup (‚Üë) :=", "nl_statement": "The given theorem states that for any finite set `s` of a certain type `Œ±`, the maximum element of `s` is equivalent to the supremum of `s` when applying the coercion function `(‚Üë)`."}
{"id": 424, "formal_statement": "theorem dummy {z : ‚Ñù} : (z : ‚ÑÇ) ‚â† 1 ‚Üî z ‚â† 1 :=", "nl_statement": "The statement concerns a property of real and complex numbers. Specifically, it asserts that a real number \\(z\\), when considered as a complex number, is not equal to 1 if and only if \\(z\\) itself is not equal to 1. This touches on the concept of embedding real numbers into the complex plane, where a real number \\(z\\) is treated as the complex number \\(z + 0i\\)."}
{"id": 425, "formal_statement": "theorem dummy : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset Œ±) :=", "nl_statement": "The given statement is a theorem related to the mapping of a certain type of subset within a finite set (Finset) in the context of a mathematical framework provided by Lean4, a theorem prover. Specifically, the theorem involves the interval \\( (a, b) \\) (denoted as `Ioc a b` in Lean4, which stands for the open-closed interval from \\(a\\) to \\(b\\)) and its mapping through an embedding that restricts to a subtype `p`. The statement asserts that mapping the open-closed interval \\( (a, b) \\) through this embedding yields the same set as considering \\( (a, b) \\) as a finite set directly in the type \\( \\alpha \\)."}
{"id": 426, "formal_statement": "theorem dummy : (1 : ùìú(ùïú, A)).toProd = 1 :=", "nl_statement": "The theorem named `one_toProd` asserts that the multiplicative identity (denoted by `1`) in a certain mathematical structure (denoted as `ùìú(ùïú, A)`) maps to the multiplicative identity (`1`) under a specific transformation or operation (`toProd`). This statement is situated within the context of algebra, specifically focusing on the properties of a mathematical object or structure indicated by `ùìú(ùïú, A)`, which could represent a type of algebraic structure parameterized over elements of type `ùïú` within a set or space `A`. The exact nature of `ùìú` and the operation `toProd` would depend on the broader mathematical framework and definitions established outside this statement. The reference to `DoubleCentralizer.one_toProd` suggests this theorem is related to the concept of double centralizers in algebra, which are a pair of sets that mutually centralize each other in a given ring or algebraic structure.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 427, "formal_statement": "theorem dummy {a : MÀ£} (h : IsUnit (a : M)) : h.unit = a :=", "nl_statement": "The theorem `unit_of_val_units` asserts that if `a` is an element of the multiplicative group of units `MÀ£` and `a` is a unit in the ring `M` (as indicated by `IsUnit (a : M)`), then the canonical unit associated with `a` through the `IsUnit` structure (i.e., `h.unit`) is identical to `a` itself."}
{"id": 428, "formal_statement": "theorem dummy (a b : Œ±) : ({a} : Finset Œ±) / {b} = {a / b} :=", "nl_statement": "The statement provided aims to demonstrate a property of division within the context of singleton sets in some algebraic structure, possibly within a field or division ring, where `Œ±` represents the type of the elements within these sets. Specifically, it asserts that dividing the singleton set containing `a` by the singleton set containing `b` results in a singleton set containing the quotient `a / b`."}
{"id": 429, "formal_statement": "theorem dummy : Disjoint s (t \\ s) :=", "nl_statement": "The theorem named `disjoint_sdiff` states that a set `s` and the set resulting from subtracting `s` from another set `t` (denoted as `t \\ s` or \"t sdiff s\") are disjoint. In other words, the set `s` and the set obtained by removing all elements of `s` from `t` have no elements in common."}
{"id": 430, "formal_statement": "theorem dummy (e : Œ± ‚âÉ Œ≤) : e ‚àò e.symm = id :=", "nl_statement": "The theorem states that for a given equivalence `e` between two types `Œ±` and `Œ≤`, composing `e` with its inverse (`e.symm`) is the same as the identity function on `Œ±`. In other words, applying `e` and then `e.symm` to any element of type `Œ±` yields that same element back."}
{"id": 431, "formal_statement": "theorem dummy {v : V} : dist G v v = 0 :=", "nl_statement": "The theorem states that the distance from a vertex to itself in a simple graph is zero. In mathematical terms, for any vertex \\(v\\) in a graph \\(G\\), the distance between \\(v\\) and itself (\\(dist(G, v, v)\\)) is equal to zero."}
{"id": 432, "formal_statement": "theorem dummy {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : powersetAux' l‚ÇÅ ~ powersetAux' l‚ÇÇ :=", "nl_statement": "Given two lists `l‚ÇÅ` and `l‚ÇÇ` of any type `Œ±`, if `l‚ÇÅ` is a permutation of `l‚ÇÇ` (denoted as `l‚ÇÅ ~ l‚ÇÇ`), then the powerset of `l‚ÇÅ` (constructed in a specific auxiliary manner, denoted as `powersetAux' l‚ÇÅ`) is also a permutation of the powerset of `l‚ÇÇ` (`powersetAux' l‚ÇÇ`)."}
{"id": 433, "formal_statement": "theorem dummy (f : MvPowerSeries œÉ R) (a : R) : a ‚Ä¢ f = C œÉ R a * f :=", "nl_statement": "The theorem being discussed concerns a specific operation within the context of multivariate power series over some ring \\(R\\) and indexed by a set \\(\\sigma\\). It states that for any multivariate power series \\(f\\) and any element \\(a\\) from the ring \\(R\\), scaling the power series \\(f\\) by \\(a\\) (denoted as \\(a ‚Ä¢ f\\)) is equivalent to multiplying \\(f\\) by the constant series created by \\(a\\) (denoted as \\(C œÉ R a * f\\)). The constant series \\(C œÉ R a\\) represents a power series where all coefficients are zero except for the constant term, which is \\(a\\)."}
{"id": 434, "formal_statement": "theorem dummy {l : List Œ±} {m : Œ±} : (maximum l : WithTop Œ±) = m ‚Üí m ‚àà l :=", "nl_statement": "The theorem in question deals with a function that finds the maximum value in a list. Specifically, it states that if the maximum value of a list `l` (where `l` is a list of elements of type `Œ±`) is `m`, then `m` must be an element of `l`. This theorem operates within the context of Lean4's handling of potentially non-terminating or undefined operations using the `WithTop Œ±` type, which extends the type `Œ±` with a top element representing infinity or an undefined maximum."}
{"id": 435, "formal_statement": "theorem dummy {f g : Filter Œ±} : (f ‚äî g).sets = f.sets ‚à© g.sets :=", "nl_statement": "The statement concerns filters in the context of topology or abstract analysis. A filter on a set \\( \\alpha \\) is a collection of subsets of \\( \\alpha \\) that satisfies certain properties. It is used to generalize the notion of convergence and neighborhoods in topology. The theorem states that the set of subsets belonging to the supremum (least upper bound) of two filters \\( f \\) and \\( g \\) is equal to the intersection of the sets of subsets belonging to \\( f \\) and \\( g \\)."}
{"id": 436, "formal_statement": "theorem dummy {f g : E ‚âÉ‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ} (h : f = g) (x : E) : f x = g x :=", "nl_statement": "We are given two linear isometric equivalences \\( f \\) and \\( g \\) from a vector space \\( E \\) to another vector space \\( E_2 \\), both operating under a scalar field with the relation \\( \\sigma_{1 2} \\). The theorem states that if \\( f \\) and \\( g \\) are equal (that is, \\( f = g \\)), then for any vector \\( x \\) in \\( E \\), the application of \\( f \\) and \\( g \\) to \\( x \\) will yield the same result, or formally, \\( f(x) = g(x) \\)."}
{"id": 437, "formal_statement": "theorem dummy : ‚àÄ {s t : Finmap Œ≤}, s.entries = t.entries ‚Üí s = t | ‚ü®l‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®l‚ÇÇ, _‚ü©, H => by congr :=", "nl_statement": "The theorem named `ext` asserts that for any two finite maps `s` and `t` of type `Finmap Œ≤`, if the entries of `s` and `t` are equal, then `s` and `t` themselves are equal."}
{"id": 438, "formal_statement": "theorem dummy (f : Œ± ‚Üí‚Çõ E) (hf : Mem‚Ñíp f p Œº) : (toLp f hf : Lp E p Œº) = hf.toLp f :=", "nl_statement": "The theorem states that for a simple function \\(f\\) from a type \\(\\alpha\\) to a Banach space \\(E\\), if \\(f\\) is in the space \\(L^p\\) with respect to a measure \\(\\mu\\) (denoted as `Mem‚Ñíp f p Œº`), then the `Lp` representation of \\(f\\) created using the `toLp` construction with \\(hf\\) as evidence of \\(f\\) being in \\(L^p\\), is exactly the same as directly using the `toLp` construction on \\(f\\) with \\(hf\\)."}
{"id": 439, "formal_statement": "theorem dummy (Œ± : Type u) [hŒ± : Small.{v} Œ±] : Small.{max v w} Œ± := let ‚ü®‚ü®_, ‚ü®f‚ü©‚ü©‚ü© :=", "nl_statement": "The theorem named `small_lift` concerns the concept of \"smallness\" of types in the context of type theory, specifically within the Lean4 theorem prover framework. It states that if a type `Œ±` is \"small\" in a certain universe `u`, then it is also \"small\" in a larger universe, specifically the maximum of universe `v` and another universe `w`.\n\nIn type theory and logic, a \"small\" type is one that can be encoded within another type, often used to avoid certain paradoxes like Russell's paradox. The concept of \"universes\" is used to stratify types into different levels, preventing self-reference problems."}
{"id": 440, "formal_statement": "theorem dummy (h : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g :=", "nl_statement": "The statement concerns the behavior of a function `g` when applied to two measurable spaces, `m‚ÇÅ` and `m‚ÇÇ`, with the property that `m‚ÇÅ` is less than or equal to `m‚ÇÇ`. Specifically, it asserts that the comap (or preimage) of `m‚ÇÅ` under `g` is less than or equal to the comap of `m‚ÇÇ` under `g`. In mathematical terms, if we have two measurable spaces such that `m‚ÇÅ ‚â§ m‚ÇÇ`, then applying the comap operation with respect to a function `g` to both `m‚ÇÅ` and `m‚ÇÇ` respects this order, i.e., `m‚ÇÅ.comap g ‚â§ m‚ÇÇ.comap g`."}
{"id": 441, "formal_statement": "theorem dummy {x z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=", "nl_statement": "The theorem states that for any real numbers \\(x\\) and \\(z\\), if \\(x\\) is greater than or equal to 1 (\\(1 \\le x\\)) and \\(z\\) is less than or equal to 0 (\\(z \\le 0\\)), then \\(x\\) raised to the power of \\(z\\) (\\(x^z\\)) is less than or equal to 1 (\\(x^z \\le 1\\))."}
{"id": 442, "formal_statement": "theorem dummy (b b' : B) (x : X') : (b * b') ‚Ä¢ x = b ‚Ä¢ b' ‚Ä¢ x :=", "nl_statement": "This theorem involves a mathematical structure, likely a group or a vector space, where `b` and `b'` are elements of a set `B`, and `x` is an element of a set `X'`. The operation `*` denotes multiplication within `B`, and `‚Ä¢` denotes a \"scalar\" action of `B` on `X'` (which could represent scalar multiplication in a vector space, or a group action). The theorem states that for any elements `b`, `b'` of `B` and any element `x` of `X'`, the action of the product of `b` and `b'` on `x` is equal to the action of `b` on the result of the action of `b'` on `x`. In mathematical notation, this is written as:\n\n\\[(b * b') ‚Ä¢ x = b ‚Ä¢ (b' ‚Ä¢ x)\\]"}
{"id": 443, "formal_statement": "theorem dummy {m : ‚Ñï} : ‚àÄ {n k}, psub m n = some k ‚Üî k + n = m | 0, k => by simp [eq_comm] | n + 1, k => by apply Option.bind_eq_some.trans simp only [psub_eq_some, ppred_eq_some] simp [add_comm, add_left_comm, Nat.succ_eq_add_one] :=", "nl_statement": "The theorem states that for any natural numbers \\(m\\), \\(n\\), and \\(k\\), the operation `psub m n = some k` is true if and only if \\(k + n = m\\). Here, `psub` is a function that performs a partial subtraction of \\(n\\) from \\(m\\), returning `some k` if the subtraction is possible without resulting in a negative number, where \\(k\\) is the difference."}
{"id": 444, "formal_statement": "theorem dummy (d : Œ±) : (range fun n => l.getD n d) = insert d { x | x ‚àà l } := calc (range fun n => l.getD n d) = (fun o : Option Œ± => o.getD d) '' range l.get? :=", "nl_statement": "This theorem concerns the relationship between a certain operation on lists and sets in the context of mathematical logic or computer science. The operation in question is `l.getD n d`, which retrieves the n-th element from a list `l`, and if the index `n` is out of bounds (i.e., there is no n-th element), it returns a default value `d`. The theorem asserts that the set obtained by applying this operation to every possible index `n` is equal to the set obtained by inserting the default value `d` into the set of all elements that are in the list `l`."}
{"id": 445, "formal_statement": "theorem dummy : ((1 : RatFunc F) : LaurentSeries F) = 1 :=", "nl_statement": "The statement concerns the field of formal mathematics, specifically within the context of algebraic structures like Rational Functions (`RatFunc`) and Laurent Series over a field `F`. The theorem, named `coe_one`, asserts that when the number 1, considered as a rational function over the field `F`, is converted (coerced) into a Laurent series (also over the field `F`), the result is simply the number 1 (now considered as a Laurent series)."}
{"id": 446, "formal_statement": "theorem dummy (x y : ‚Ñù) : ‚Üë(x - y : ‚Ñù) = (‚Üëx - ‚Üëy : Angle) :=", "nl_statement": "The theorem `coe_sub` concerns the coercion (type conversion) of the difference between two real numbers, `x` and `y`, into an angle. It states that the coercion to an angle of the difference between `x` and `y` (treated as real numbers) is equal to the difference between the coercions of `x` and `y` to an angle."}
{"id": 447, "formal_statement": "theorem dummy (V : Set (Œ± √ó Œ±)) : SymmetricRel (symmetrizeRel V) :=", "nl_statement": "The statement pertains to the concept of symmetric relations within a set of pairs (V : Set (Œ± √ó Œ±)), focusing on the operation called \"symmetrizeRel.\" The theorem asserts that if you apply the operation \"symmetrizeRel\" to any set of pairs V, the resulting relation is symmetric. In essence, it formalizes the idea that if you take a relation and symmetrize it (by adding inverse pairs to ensure symmetry), the modified relation is inherently symmetric."}
{"id": 448, "formal_statement": "theorem dummy : tanh x = sinh x / cosh x :=", "nl_statement": "The statement to be proved is that the hyperbolic tangent of \\(x\\) (written as \\(\\tanh(x)\\)) is equal to the hyperbolic sine of \\(x\\) (written as \\(\\sinh(x)\\)) divided by the hyperbolic cosine of \\(x\\) (written as \\(\\cosh(x)\\))."}
{"id": 449, "formal_statement": "theorem dummy {a x y : MÀ£} : SemiconjBy (a : M) x y ‚Üî SemiconjBy a x y :=", "nl_statement": "The theorem presented involves the concept of SemiconjBy in the context of units in a mathematical structure, likely a ring or a similar algebraic structure. In its essence, the statement 'units_val_iff' is asserting an equivalence between two forms of the SemiconjBy relation. It says that for any units 'a', 'x', and 'y' in this structure, SemiconjBy applied to the elements as units ('a : M', 'x', 'y') is equivalent to SemiconjBy applied to 'a', 'x', and 'y' as elements of the underlying set of the units."}
{"id": 450, "formal_statement": "theorem dummy (hs : MeasurableSet s) : Œº.restrict s t = 0 ‚Üî Œº (t ‚à© s) = 0 :=", "nl_statement": "The statement presents a theorem about measure theory, specifically concerning the restriction of a measure Œº to a set s, and its application to another set t. The theorem states that the measure of the set t restricted to s (denoted as Œº.restrict s t) is equal to zero if and only if the measure of the intersection of t and s (Œº (t ‚à© s)) is equal to zero. This is contingent on s being a measurable set, denoted by hs : MeasurableSet s."}
{"id": 451, "formal_statement": "theorem dummy (s : Stream' Œ±) : pure id ‚äõ s = s :=", "nl_statement": "The theorem named \"identity\" concerns a stream `s` of type `Œ±`. The statement `pure id ‚äõ s = s` asserts that when you apply the pure identity function (`id`) to the stream `s` through an applicative functor (denoted by `‚äõ`), the result is the stream `s` itself, unchanged."}
{"id": 452, "formal_statement": "theorem dummy : a + b ‚àà Set.Ioo c d ‚Üî b ‚àà Set.Ioo (c - a) (d - a) :=", "nl_statement": "The theorem states that for any real numbers \\( a, b, c, \\) and \\( d \\), the sum \\( a + b \\) is between \\( c \\) and \\( d \\) (i.e., in the open interval \\( (c, d) \\)) if and only if \\( b \\) is in the open interval \\( (c - a, d - a) \\)."}
{"id": 453, "formal_statement": "theorem dummy (f g : Œ± ‚Üí‚ÇÇ[Œº] E) : snorm (fun x : Œ± => ‚ü™f x, g x‚ü´) 1 Œº < ‚àû :=", "nl_statement": "The statement concerns a mathematical property within the framework of functional analysis, specifically dealing with the concept of short norm (snorm) in the context of functions that map from a set \\( \\alpha \\) to a Banach space \\( E \\) under a measure \\( \\mu \\). It asserts that the short norm of the function, which maps each element \\( x \\) in \\( \\alpha \\) to the inner product of \\( f(x) \\) and \\( g(x) \\) (denoted as \\( \\langle f(x), g(x) \\rangle \\)), when measured with a norm parameter of \\( 1 \\) and under the measure \\( \\mu \\), is less than infinity."}
{"id": 454, "formal_statement": "theorem dummy (x : selfAdjoint R) (z : ‚Ñ§) : ‚Üë(x ^ z) = (x : R) ^ z :=", "nl_statement": "The given theorem states that for any self-adjoint element \\(x\\) from a specified ring \\(R\\) and for any integer \\(z\\), the coerced value of \\(x\\) raised to the power \\(z\\) in the ring is equal to the element \\(x\\) itself from \\(R\\) raised to the power \\(z\\)."}
{"id": 455, "formal_statement": "theorem dummy ‚¶Éf g : r ‚âÉr s‚¶Ñ (h : ‚àÄ x, f x = g x) : f = g :=", "nl_statement": "The statement is about two functions, \\(f\\) and \\(g\\), which are bijections (one-to-one and onto functions) from a set \\(r\\) to a set \\(s\\). The theorem states that if for every element \\(x\\) in the domain \\(r\\) the value of \\(f(x)\\) is equal to \\(g(x)\\), then the functions \\(f\\) and \\(g\\) are identical."}
{"id": 456, "formal_statement": "theorem dummy (hf : f ‚â† 0) : IsAlgebraic R (root f) :=", "nl_statement": "The statement concerns a property related to algebraic elements over a ring \\(R\\). Specifically, it asserts that if \\(f\\) is a non-zero polynomial, then the root of \\(f\\), denoted here as \\(root(f)\\), is an algebraic element over \\(R\\)."}
{"id": 457, "formal_statement": "theorem dummy ‚¶És t : Set Œ±‚¶Ñ (h : s ‚äÜ t) : BddBelow t ‚Üí BddBelow s :=", "nl_statement": "The theorem stated in the Lean4 syntax is about bounded sets in a partially ordered set. Specifically, it asserts that if one set `s` is a subset of another set `t`, and if `t` is bounded below (meaning there exists an element that is less than or equal to every element in `t`), then `s` must also be bounded below."}
{"id": 458, "formal_statement": "theorem dummy : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=", "nl_statement": "The theorem states that a function Œ¶ is differentiable at a point x in the space ùïú if and only if each component function of Œ¶, denoted as Œ¶(x)i (where i indexes the components of the output of Œ¶), is differentiable at x. This theorem essentially bridges the differentiability of a vector-valued function with the differentiability of its component functions."}
{"id": 459, "formal_statement": "theorem dummy : (‚àÖ : Set Œπ).PairwiseDisjoint f :=", "nl_statement": "The theorem named `pairwiseDisjoint_empty` states that the empty set is pairwise disjoint with respect to any function `f` from a set of indices `Œπ` to sets."}
{"id": 460, "formal_statement": "theorem dummy : (p.prod q).snd = (p.snd, q.snd) :=", "nl_statement": "The theorem in question states that for a pair of elements `(p, q)`, when this pair is treated as a product (a mathematical structure that combines two elements), the second element of this combined structure equals a new pair made of the second elements of `p` and `q`.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 461, "formal_statement": "theorem dummy (S : Submodule R M) : ‚Üë(-S) = -(S : Set M) :=", "nl_statement": "The statement concerns the relationship between a submodule \\(S\\) of a module \\(M\\) over a ring \\(R\\) and its negation. Specifically, it states that the set representation of the negation of \\(S\\) (denoted as \\(-S\\)) is equal to the negation of the set representation of \\(S\\) (denoted as \\(-(S : Set M)\\))."}
{"id": 462, "formal_statement": "theorem dummy {n : ‚Ñ§} : IsUnit n ‚Üî n.natAbs = 1 :=", "nl_statement": "The statement concerns a property of integers (denoted by ‚Ñ§) and explores the conditions under which an integer \\(n\\) is considered a unit. In mathematics, particularly in the context of ring theory, a unit in a ring \\(R\\) is an element that has a multiplicative inverse in \\(R\\). For integers, the only units are \\(1\\) and \\(-1\\), since these are the only integers that, when multiplied by themselves, result in the multiplicative identity, which is \\(1\\). The statement to be proven is:\n\n\"The integer \\(n\\) is a unit if and only if the absolute value of \\(n\\), denoted by \\(n.natAbs\\), is equal to 1.\""}
{"id": 463, "formal_statement": "theorem dummy : Monoid.FG M ‚Üî AddMonoid.FG (Additive M) :=", "nl_statement": "This theorem addresses the equivalence between two statements about the algebraic structure known as a \"Monoid.\" Specifically, it deals with the equivalence of two properties: a Monoid being finitely generated (FG), and its additive counterpart (constructed by considering the monoid operation as addition) being finitely generated. The theorem states that a Monoid \\(M\\) is finitely generated if and only if the additive monoid constructed from \\(M\\) (denoted as Additive \\(M\\)) is also finitely generated."}
{"id": 464, "formal_statement": "theorem dummy : InvOn (arg ‚àò (‚Üë)) expMapCircle (Ioc (-œÄ) œÄ) univ :=", "nl_statement": "The theorem `invOn_arg_expMapCircle` states that there is an inverse function on the argument function composed with the inclusion map `(‚Üë)` (which usually means embedding a smaller structure into a larger one, in this context, possibly embedding real numbers into complex numbers) when restricted to the exponential map of the circle, denoted by `expMapCircle`. This inverse exists within the interval `(-œÄ, œÄ)` excluding the endpoints, and applies universally (`univ` implies the entire space under consideration, which in many contexts means all possible inputs that the function can take).\n\nTo unpack this a bit:\n- `InvOn` suggests we are talking about an inverse function that is defined on a specific subset of its domain.\n- `arg ‚àò (‚Üë)` likely represents a composition of functions where `arg` is the argument (or angle) of a complex number, and `‚Üë` is an inclusion map embedding into a higher structure.\n- `expMapCircle` suggests a function mapping real numbers to the unit circle in the complex plane, typically through the exponential function \\(e^{ix}\\) where \\(x\\) is a real number.\n- `Ioc (-œÄ, œÄ)` denotes an interval of real numbers from \\(-\\pi\\) to \\(\\pi\\), including \\(-\\pi\\) but not \\(\\pi\\), which is a common way to avoid ambiguity in the argument (angle) of complex numbers on the unit circle.\n- `univ` indicates the universal set, or the complete space where the function is defined."}
{"id": 465, "formal_statement": "theorem dummy {p : A[X]} {r : K} (hr : aeval r p = 0) : num A r ‚à£ p.coeff 0 :=", "nl_statement": "The theorem states that if `r` is a root of a polynomial `p` over a field `K`, then the numerator of `r` (assuming `r` is expressed as a fraction in its simplest form in the field `A`) divides the constant term of the polynomial `p`."}
{"id": 466, "formal_statement": "theorem dummy (f : Œ± ‚Üí‚Çò[Œº] Œ≥) : f‚Åª¬π.toGerm = f.toGerm‚Åª¬π :=", "nl_statement": "The statement concerns a function \\(f\\) that belongs to a space of equivalence classes of almost everywhere (a.e.) equal functions, denoted by \\(Œ± ‚Üí‚Çò[Œº] Œ≥\\), where \\(Œ±\\) and \\(Œ≥\\) are types (representing sets in this context) and \\(Œº\\) is a measure on \\(Œ±\\). The theorem states that taking the inverse of \\(f\\) in this space and then finding its equivalence class under the \"toGerm\" mapping yields the same result as first mapping \\(f\\) to its equivalence class and then taking the inverse within this space of germs."}
{"id": 467, "formal_statement": "theorem dummy (s : Finset Œ±) : eraseNone (s.map Embedding.some) = s :=", "nl_statement": "The theorem named `eraseNone_map_some` concerns a specific operation on a finite set (Finset) of elements of some type `Œ±`. It states that if you take a finite set `s`, map each element of this set to an `Option` type using the `Some` constructor (which wraps each element in a `Some`), and then apply an operation called `eraseNone` (which removes all `None` values and unwraps the `Some` values, effectively returning the original elements), the result is the original finite set `s` itself."}
{"id": 468, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) (q : Semiquot Œ±) (b : Œ≤) : b ‚àà map f q ‚Üî ‚àÉ a, a ‚àà q ‚àß f a = b :=", "nl_statement": "The theorem `mem_map` concerns a function `f` that maps elements from one set `Œ±` to another `Œ≤`, and a semiquotient `q` of type `Œ±`. The statement claims that a particular element `b` belongs to the set obtained by mapping `q` through `f` if and only if there exists an element `a` in `q` such that applying `f` to `a` yields `b`."}
{"id": 469, "formal_statement": "theorem dummy {f : ‚Ñï ‚Üí Œ±} (hf : ‚àÄ n, f (n + 1) ‚â§ f n) : Antitone f :=", "nl_statement": "The statement concerns a function \\(f\\) from natural numbers (\\(\\mathbb{N}\\)) to some ordered set \\(\\alpha\\), and asserts that if for every natural number \\(n\\), the value of \\(f\\) at \\(n+1\\) is less than or equal to its value at \\(n\\) (i.e., \\(f(n + 1) \\leq f(n)\\)), then \\(f\\) is antitone. Being antitone means that if you have two natural numbers where the first is less than or equal to the second, then the function value of the first number is greater than or equal to the function value of the second number."}
{"id": 470, "formal_statement": "theorem dummy : s.1.Disjoint t.1 ‚Üî Disjoint s t :=", "nl_statement": "The statement to be translated from Lean4's syntax into natural language is about the relationship between two sets, specifically focusing on the concept of disjoint sets. Disjoint sets are sets that have no elements in common. The theorem `disjoint_val` expresses a condition related to two sets `s` and `t`, encapsulated within another structure (hinted by `s.1` and `t.1`), asserting that a certain property of disjointness between `s.1` and `t.1` is equivalent to the disjointness of `s` and `t`."}
{"id": 471, "formal_statement": "theorem dummy : œÄ < 3.141593 :=", "nl_statement": "The statement to prove is that the value of œÄ (pi) is less than 3.141593."}
{"id": 472, "formal_statement": "theorem dummy : WellFoundedOn (insert a s) r ‚Üî WellFoundedOn s r :=", "nl_statement": "The statement concerns the concept of \"well-foundedness\" on a set with respect to a relation \\(r\\). Specifically, it is asserting the equivalence between the well-foundedness of a set \\(s\\) with an element \\(a\\) inserted into it (\\(insert a s\\)) and the well-foundedness of the set \\(s\\) itself, all with respect to the same relation \\(r\\). In other words, adding a single element to a set does not affect its well-foundedness property with respect to the relation \\(r\\)."}
{"id": 473, "formal_statement": "theorem dummy (ha : ¬¨IsMin a) : Iic (pred a) = Iio a :=", "nl_statement": "The theorem presented asserts that if `a` is not a minimum element (denoted as `¬¨IsMin a`), then the set of all elements less than or equal to the predecessor of `a` (`Iic (pred a)`) is equal to the set of all elements strictly less than `a` (`Iio a`)."}
{"id": 474, "formal_statement": "theorem dummy : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=", "nl_statement": "The statement asserts that the empty set is linearly independent in the context of a vector space over a field R with elements of type M. In simpler terms, it means that no vector in the empty set can be represented as a linear combination of the others, which is trivially true since there are no vectors in the empty set to begin with."}
{"id": 475, "formal_statement": "theorem dummy (a b c : Œ±) : a ‚äì (b ‚äì c) = b ‚äì (a ‚äì c) :=", "nl_statement": "The statement to be proven is about the commutativity of the infimum (inf) operation in a certain context. Specifically, for any three elements \\(a\\), \\(b\\), and \\(c\\) of a type \\(\\alpha\\), the operation of taking the infimum of \\(a\\) with the infimum of \\(b\\) and \\(c\\) is equivalent to taking the infimum of \\(b\\) with the infimum of \\(a\\) and \\(c\\). In other words, the equation \\(a \\wedge (b \\wedge c) = b \\wedge (a \\wedge c)\\) must be proven true, where \\(\\wedge\\) denotes the infimum operation."}
{"id": 476, "formal_statement": "theorem dummy (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=", "nl_statement": "The statement involves a function `f` that is a homomorphism between two additive groups `A'` and `B'`. A homomorphism in this context is a function that preserves the structure of the groups, specifically, it respects the addition operation. The theorem states that for any two elements `x` and `y` in `A'`, applying the function `f` to the difference `x - y` yields the same result as subtracting `f(y)` from `f(x)` in `B'`. In simpler terms, if you subtract two elements and then apply the function, it's the same as applying the function to each element separately and then subtracting the results."}
{"id": 477, "formal_statement": "theorem dummy (a : Bool) : (not a = false) = (a = true) :=", "nl_statement": "The theorem `not_eq_false_eq_eq_true` states that for any boolean value `a`, the statement \"not `a` equals false\" is equivalent to \"`a` equals true.\""}
{"id": 478, "formal_statement": "theorem dummy {c n x} : x ‚àà eval c n ‚Üî ‚àÉ k, x ‚àà evaln k c n :=", "nl_statement": "The theorem in question establishes a connection between two functions, `eval` and `evaln`, within a certain computational framework. Specifically, it states that for any code `c`, natural number `n`, and result `x`, `x` is a result of evaluating `c` with `n` using `eval` if and only if there exists some `k` such that `x` is a result of evaluating `c` with `n` using `evaln` with at least `k` steps. This theorem asserts the completeness of `evaln` in relation to `eval`, meaning that `evaln` can achieve any result that `eval` can, given a sufficient number of steps."}
{"id": 479, "formal_statement": "theorem dummy (h : JoinedIn F x y) : JoinedIn F y x :=", "nl_statement": "The theorem `JoinedIn.symm` asserts that if an element `x` is joined to an element `y` within a framework `F`, then `y` is also joined to `x` within the same framework `F`. This demonstrates the symmetric property of being joined within a specific context or framework."}
{"id": 480, "formal_statement": "theorem dummy (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : IsBigOWith c l f g :=", "nl_statement": "The theorem `isBigOWith_of_le'` states that if for all elements \\(x\\), the norm of \\(f(x)\\) is less than or equal to a constant \\(c\\) times the norm of \\(g(x)\\), then \\(f\\) is big-O of \\(g\\) with constant \\(c\\) in the limit \\(l\\)."}
{"id": 481, "formal_statement": "theorem dummy {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v :=", "nl_statement": "The theorem `stepRet_eval` states that evaluating the function `step` on the result of `stepRet` with some continuation `k` and value `v` yields the same result as applying the halt operation of `k` to the evaluation of `v`, effectively halting the computation and returning the result of `k.eval v` within a computational context."}
{"id": 482, "formal_statement": "theorem dummy (g : Œ≤ ‚Üí Œ≥) (b : Œ≤) : (const Œ± b).map g = const Œ± (g b) :=", "nl_statement": "The statement we're examining is a theorem about functions in a mathematical context, specifically dealing with the concept of mapping one function over another. The essence of the theorem is as follows:\n\nGiven a function `g` that maps elements from type `Œ≤` to type `Œ≥`, and a constant value `b` of type `Œ≤`, when we apply the `map` operation of a constant function `const Œ± b` (a function that always returns `b` for any input of type `Œ±`) through `g`, the result is equivalent to creating a new constant function of type `Œ±` that always returns `g(b)`."}
{"id": 483, "formal_statement": "theorem dummy (K‚ÇÅ K‚ÇÇ : Compacts G) (h : (K‚ÇÅ : Set G) ‚äÜ K‚ÇÇ) : Œº K‚ÇÅ ‚â§ Œº K‚ÇÇ :=", "nl_statement": "The theorem states that given two compact sets `K‚ÇÅ` and `K‚ÇÇ` in a group `G`, if `K‚ÇÅ` is a subset of `K‚ÇÇ`, then the measure `Œº` of `K‚ÇÅ` is less than or equal to the measure `Œº` of `K‚ÇÇ`."}
{"id": 484, "formal_statement": "theorem dummy (x : ‚Ñù) : HasDerivAt cos (-sin x) x :=", "nl_statement": "The statement we're discussing is about the derivative of the cosine function. Specifically, it asserts that for any real number \\(x\\), the derivative of the cosine function at \\(x\\) is \\(-\\sin(x)\\). This is a fundamental result in calculus that relates the rate of change of the cosine function to the sine function."}
{"id": 485, "formal_statement": "theorem dummy (x : A) : f <$$> Const.mk x = Const.mk x :=", "nl_statement": "The theorem states that when a function `f` is applied to a constant value `x` using a functor's map operation (`<$$>`), the result is the same constant value `x` wrapped in a `Const` constructor, regardless of the function `f`. In simpler terms, applying any function to a constant value in this specific context does not change the value; it remains the same constant.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 486, "formal_statement": "theorem dummy (x : E) : ‚ü™0, x‚ü´ = 0 :=", "nl_statement": "The statement given asserts that the inner product of the zero vector and any vector \\(x\\) in a vector space \\(E\\) is equal to zero. This can be stated as: For all vectors \\(x\\) in the vector space \\(E\\), the inner product of the zero vector with \\(x\\) is zero."}
{"id": 487, "formal_statement": "theorem dummy : coeff (C a) n = ite (n = 0) a 0 :=", "nl_statement": "The theorem named `coeff_C` states that when you take a polynomial that is just a constant term `a` (represented as `C a` in Lean4), and you look at the coefficient of the term `x^n` (where `n` is a natural number) in that polynomial, the result is `a` if `n` is 0, and it's 0 otherwise."}
{"id": 488, "formal_statement": "theorem dummy {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚Äñx‚Äñ = c :=", "nl_statement": "The statement asserts the existence of an element \\(x\\) in a vector space \\(E\\) over the real numbers, such that the norm (or length) of \\(x\\) is equal to any given non-negative real number \\(c\\)."}
{"id": 489, "formal_statement": "theorem dummy (n) (a : R) : (monomial n a).support ‚äÜ singleton n :=", "nl_statement": "The theorem `support_monomial'` states that for any natural number `n` and any element `a` of the ring `R`, the support of the monomial `monomial n a` is a subset of the singleton set containing `n`. In simpler terms, it's asserting that if you have a monomial (a polynomial term with a single term), the only exponent that will have a non-zero coefficient in this polynomial is `n`."}
{"id": 490, "formal_statement": "theorem dummy {x : I} : (x : ‚Ñù) ‚â† 0 ‚Üî x ‚â† 0 :=", "nl_statement": "The statement to be proven is that the real number representation of a variable \\( x \\), which belongs to the set \\( I \\) (usually representing some interval), is not zero if and only if \\( x \\) itself is not zero."}
{"id": 491, "formal_statement": "theorem dummy (ha : a ‚â† 0) : a ‚Ä¢ s ‚äÜ t ‚Üî s ‚äÜ a‚Åª¬π ‚Ä¢ t :=", "nl_statement": "The statement concerns a property related to the scaling (multiplication) of elements in a set by a non-zero scalar and how this relates to subset relations between sets. Specifically, it states that for a non-zero scalar \\(a\\), the scaled set \\(a \\cdot s\\) is a subset of \\(t\\) if and only if the set \\(s\\) is a subset of the scaled set \\(a^{-1} \\cdot t\\)."}
{"id": 492, "formal_statement": "theorem dummy (S : Set (UpperSet Œ±)) : (‚Üë(sInf S) : Set Œ±) = ‚ãÉ s ‚àà S, ‚Üës :=", "nl_statement": ":\nTheThe theorem theorem we we're're discussing concerns itself discussing with states that for a any particular set property \\( ofS the\\) smallest of element in upper sets a set in a of type upper \\ sets(\\ withinalpha a\\ given), type the ` intersectionŒ± of`. Specifically all elements, in it \\(S states that\\) the ( smallestden elementoted (` ass \\(Infs`)Inf of S a\\ set `)) whenS viewed` as of a upper set sets can of elements be of represented type as \\ the(\\ unionalpha of\\ all the), elements is equal in to the the set union ` ofS all`.\n\n sets# in Proof \\(:\nSTo\\ understand). this \n\n theoremAn and upper its set proof in, a let partially's ordered break set down is the a components subset and in the which notation, used for:\n\n any- element ` inUpper theSet Œ± subset,` all refers to elements greater the than type or of equal upper sets over a to type it are also `Œ±`. An in the subset. This upper theorem set is in about a how partially we ordered set is a set can such describe the smallest upper set that that for contains any all element upper in sets the in set \\(, anyS\\) greater in element terms is of also a in simple the union set.\n of- all ` the setss inInf S \\(S`\\ denotes).\n\n the greatest# Proof lower:\n boundThe ( proofinf ofimum the) theorem of is the succinct set `ly givenS by` ` ofr upperfl sets`,. which This stands is for the \" smallestref upperlex setivity that\" is in a Lean sup4erset. of This every indicates set that in the ` equalityS stated`.\n in- the ` theorem‚Üë is( considereds toInf be S self)`-e representsvid theent coercion within of the ` contexts ofInf Lean S4`'s into logic a set and of type system elements. of In type more ` practicalŒ± terms`., Coerc the reflexivityion here here implies means that treating the the inf representation ofimum the, intersection which of is an all elements upper in set \\(,S as\\) a as plain an set upper of set elements is.\n by- definition The equal right to-hand the side union, of ` all sets in‚ãÉ \\( sS ‚àà\\) S when, those ‚Üës sets`, represents are viewed as the simple union sets of of all type elements \\ in(\\ allalpha the\\ upper).\n\n setsIn in natural ` languageS,`. the ` reasoning would follow‚ãÉ that` since is \\( theS union\\) operation is a, and collection ` of‚Üë uppers sets`, means and each since ` thes intersection` of in upper ` setsS (\\`( iss alsoInf treated S as\\ a)) plain is set the of smallest elements upper.\n\n setThe theorem containing all, elements therefore of, each asserts set that in if \\( youS take\\ the), smallest then upper by set the that contains property of all upper upper sets sets, in this intersection `S` is exactly (the ` equivalent to thes unionInf of` all of sets ` inS \\(`) and look at it just as a set of elements, you get the same thing as if you tookS\\). Each element in the union of all sets in \\(S\\) must belong to at least one every element upper set in \\( from every upperS set\\ in), `S and therefore`, and must put be them in all the together smallest ( upperthe set union that of includes all all sets elements in of ` \\(SS`\\).\n\n),The demonstrating proof the, equality as. indicated This by boils ` downr to understandingfl`, relies how on upper sets the and reflexivity their of intersections equality work in, Lean fundamentally4 relying. on This their means definition that and the properties statement rather is than self a-e stepvident-by-step from constructive the proof definitions. involved; the way `sInf` and set union are defined makes this equality true by definition. There is no need for a series of logical steps to prove this; it is a direct consequence of how these concepts are constructed within the framework of Lean4's type system and its treatment of sets and upper sets.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 493, "formal_statement": "theorem dummy (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=", "nl_statement": "The statement concerns the vertices of the greatest lower bound (infimum) of a set of subgraphs within a graph `G`. Specifically, it asserts that the set of vertices belonging to the infimum of a set `s` of subgraphs of `G` is exactly the intersection of the sets of vertices of each subgraph in `s`."}
{"id": 494, "formal_statement": "theorem dummy : functor r ‚ãô lift r F H = F :=", "nl_statement": "The theorem named `lift_spec` states that composing the `functor` \\(r\\) with the `lift` of \\(r\\) over a functor \\(F\\) with a property \\(H\\) results in the functor \\(F\\) itself. In simpler terms, if you take a functor, lift it according to some rules (defined by \\(r\\) and \\(H\\)), and then compose it with \\(r\\), you end up with the original functor you started with. This is a property related to category theory, specifically dealing with functors, natural transformations, and constructions like lifting which are fundamental in understanding how different categories relate to each other."}
{"id": 495, "formal_statement": "theorem dummy : trace R (Module.Dual R M) ‚àò‚Çó Module.Dual.transpose = trace R M :=", "nl_statement": "The statement we're examining asserts that the trace of the transpose of a linear module over a ring R, `Module.Dual R M`, is equal to the trace of the original module `M`. The trace of a module can be thought of as a sum of the diagonal elements in a square matrix representation, although in a more abstract sense related to linear algebra and module theory."}
{"id": 496, "formal_statement": "theorem dummy [hsq : HasLift sq] : sq.lift ‚â´ p = g :=", "nl_statement": "The statement provided is about a property in category theory, specifically within the context of commutative squares and lifting properties. It asserts that if there exists a lifting for a square (denoted as `sq`) with respect to some property or structure `HasLift`, then applying the lifting (`lift`) to one side of the square (`sq.lift`) followed by a particular morphism `p` is equivalent to another morphism `g`. This is a formal way to describe how certain transformations or mappings preserve structure within a mathematical framework, particularly within category theory, which deals with the abstract properties of mathematical structures and their relationships."}
{"id": 497, "formal_statement": "theorem dummy [DecidableEq Œ±] (s : Finset Œ±) : (sort r s).toFinset = s :=", "nl_statement": "The statement to be proved is about sorting elements of a finite set (Finset) and then converting this sorted list back into a set. Specifically, the theorem states that if you take a finite set `s`, sort it according to some rule `r`, and then convert this sorted list back into a set, you will end up with the original set `s` you started with. This theorem relies on the assumption that we can decide if any two elements are equal (which is what `DecidableEq Œ±` means, where `Œ±` is the type of the elements in the set)."}
{"id": 498, "formal_statement": "theorem dummy {f : Œ± ‚Üí Œ≤} {x : FreeSemigroup Œ±} : pure f <*> x = f <$> x :=", "nl_statement": "The theorem presented concerns the operation of function application within the context of a free semigroup, specifically focusing on the behavior of `pure` and `<*>` (the apply or sequence operator) in comparison to the fmap (`<$>`) operator. In essence, it states that applying a function `f` of type `Œ± ‚Üí Œ≤` to a value `x` in a free semigroup `FreeSemigroup Œ±` using the `pure` function followed by the sequence operator `<*>` is equivalent to directly mapping `f` over `x` using the fmap operator `<$>`."}
{"id": 499, "formal_statement": "theorem dummy : 1 < cosh x ‚Üî x ‚â† 0 :=", "nl_statement": "The theorem states that the hyperbolic cosine of a number (cosh(x)) is greater than 1 if and only if that number is not zero."}
{"id": 500, "formal_statement": "theorem dummy {K‚ÇÅ K‚ÇÇ : Pretopology C} : K‚ÇÅ ‚â§ K‚ÇÇ ‚Üî (K‚ÇÅ : ‚àÄ X : C, Set (Presieve X)) ‚â§ K‚ÇÇ :=", "nl_statement": "The statement concerns the comparison of two pretopologies, `K‚ÇÅ` and `K‚ÇÇ`, within the context of category theory. A pretopology in category theory is a way to talk about coverings of objects without specifying a topology explicitly. The theorem states that `K‚ÇÅ` is less than or equal to `K‚ÇÇ` if and only if, for every object `X` in category `C`, the set of presieves (collections of morphisms with a common codomain `X`) associated with `K‚ÇÅ` is less than or equal to the set of presieves associated with `K‚ÇÇ`. Essentially, this is about comparing how \"fine\" or \"coarse\" different pretopologies are in terms of the coverings they allow."}
{"id": 501, "formal_statement": "theorem dummy [Balanced C] {G : C} : IsSeparator G ‚Üí IsDetector G :=", "nl_statement": "The theorem stated posits that in a context where 'C' is a balanced category and 'G' is an object within this category, if 'G' is a separator, then 'G' is also a detector."}
{"id": 502, "formal_statement": "theorem dummy (a b : Œ±) : (Ioo a b : Set Œ±) = Set.Ioo a b :=", "nl_statement": "The theorem presented is concerned with the equivalence of two representations of an open interval (which does not include its endpoints) in a certain set `\\(\\alpha\\)`. The theorem states that the set representation of the open interval between `a` and `b` (denoted as `(Ioo a b : Set Œ±)`) is equal to the standard mathematical notation for an open interval (denoted as `Set.Ioo a b`). In simpler terms, this theorem is affirming that two ways of describing the open interval between two points, `a` and `b`, in the context of set `\\(\\alpha\\)` are exactly the same."}
{"id": 503, "formal_statement": "theorem dummy {r : R} : algebraMap R (HahnSeries Œì A) r = C (algebraMap R A r) :=", "nl_statement": "The theorem states that for any element `r` in the ring `R`, applying the algebra map from `R` to the Hahn series over some group `Œì` and ring `A` is the same as first applying the algebra map from `R` to `A` to `r`, and then embedding the result into the Hahn series using the constant term function `C`."}
{"id": 504, "formal_statement": "theorem dummy : UniformEmbedding (Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤) :=", "nl_statement": "The statement declares that the function `Sum.inr : Œ≤ ‚Üí Œ± ‚äï Œ≤` is a uniform embedding. In simpler terms, it's about a specific kind of function that maps elements from one set (Œ≤) to another set, specifically into the right part of a sum type (`Œ± ‚äï Œ≤`), preserving a certain uniformity in the process."}
{"id": 505, "formal_statement": "theorem dummy {q : ‚Ñö} (hq : q.num = 0) : q = 0 :=", "nl_statement": "The theorem named `zero_of_num_zero` is about rational numbers (denoted by `‚Ñö`). It states that if the numerator (`num`) of a rational number `q` is zero, then the rational number itself is equal to zero."}
{"id": 506, "formal_statement": "theorem dummy (f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : (id : L‚ÇÇ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ).comp f = f :=", "nl_statement": "This theorem states that the composition of a linear map \\(f : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ\\) with the identity map on \\(L‚ÇÇ\\) is equal to \\(f\\) itself."}
{"id": 507, "formal_statement": "theorem dummy {a : R} (a0 : a ‚â† 0) : a / a = 1 :=", "nl_statement": "The theorem states that for any nonzero element \\(a\\) in a field \\(R\\), the division of \\(a\\) by itself yields 1."}
{"id": 508, "formal_statement": "theorem dummy (hr : 0 ‚â§ r) : ‚Äñr‚Äñ = r :=", "nl_statement": "The statement asserts that for any non-negative real number \\(r\\) (meaning \\(r \\geq 0\\)), the norm (or absolute value) of \\(r\\) is equal to \\(r\\) itself."}
{"id": 509, "formal_statement": "theorem dummy (e : P‚ÇÅ ‚âÉ P‚ÇÇ) (e' : V‚ÇÅ ‚âÉ‚Çó[k] V‚ÇÇ) (h) : ((‚ü®e, e', h‚ü© : P‚ÇÅ ‚âÉ·µÉ[k] P‚ÇÇ) : P‚ÇÅ ‚Üí P‚ÇÇ) = e :=", "nl_statement": "The theorem in question discusses a situation in a mathematical context involving two affine spaces `P‚ÇÅ` and `P‚ÇÇ`, and two vector spaces `V‚ÇÅ` and `V‚ÇÇ` over a field `k`. It asserts that given an equivalence `e` between `P‚ÇÅ` and `P‚ÇÇ`, and a linear equivalence `e'` between `V‚ÇÅ` and `V‚ÇÇ`, along with a certain condition `h`, the affine equivalence created by combining `e`, `e'`, and `h` (denoted as `‚ü®e, e', h‚ü©`) when applied as a function from `P‚ÇÅ` to `P‚ÇÇ`, is identical to the original equivalence `e`."}
{"id": 510, "formal_statement": "theorem dummy (s t u : Finset Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=", "nl_statement": "This theorem concerns the operation of union on finite sets, specifically within the context of a type `Œ±`. The statement can be read as: For any three finite sets `s`, `t`, and `u`, the union of `s` with the union of `t` and `u` is equivalent to the union of `s` with `t` and then taking the union of that result with the union of `s` and `u`."}
{"id": 511, "formal_statement": "theorem dummy : s ‚äª t ‚äª u = s ‚äª (t ‚äª u) :=", "nl_statement": "The given statement concerns the associativity of a certain operation, denoted by \"‚äª\", on three sets \\(s\\), \\(t\\), and \\(u\\). The theorem asserts that applying this operation in a sequential manner from left to right \\((s ‚äª t) ‚äª u\\) yields the same result as grouping the last two sets before applying the operation \\(s ‚äª (t ‚äª u)\\)."}
{"id": 512, "formal_statement": "theorem dummy (hf : Bijective f) (hg : Bijective g) : Bijective (map f g) :=", "nl_statement": "The statement pertains to the concept of bijectivity in the context of functions. Specifically, it considers two functions, \\(f\\) and \\(g\\), each of which is bijective. The theorem asserts that if you take the product of these two functions‚Äîessentially, applying \\(f\\) to the first component of a pair and \\(g\\) to the second component‚Äîthis resulting function is also bijective."}
{"id": 513, "formal_statement": "theorem dummy (b : ‚Ñï) (r : R) : clog b r‚Åª¬π = -log b r :=", "nl_statement": "The statement to be proved is about the relationship between the logarithm of the inverse of a real number \\(r\\) to a base \\(b\\), and the negative of the logarithm of \\(r\\) to the same base. Specifically, it claims that for any natural number \\(b\\) and any real number \\(r\\), the \"clog\" (a certain logarithmic function) of the inverse of \\(r\\) to the base \\(b\\) is equal to the negative of the \"log\" (another logarithmic function) of \\(r\\) to the base \\(b\\)."}
{"id": 514, "formal_statement": "theorem dummy (f : Lp E p Œº) : snorm f p Œº < ‚àû :=", "nl_statement": "The theorem named `snorm_lt_top` asserts that for any function `f` that is a member of `Lp E p Œº`, the semi-norm of `f` (denoted as `snorm f p Œº`) is less than infinity. In more accessible terms, this theorem is about functions that are part of the Lp space‚Äîa mathematical space of functions that allows for the integration of functions raised to the power `p` with respect to a measure `Œº`. The semi-norm of such a function, considering its p-th power and the given measure, is always finite.\n\nIn essence, the theorem assures us that within the framework of measure theory, specifically in the context of Lp spaces, the semi-norm of any function belonging to such a space is guaranteed to be finite, underscoring a fundamental property of these functions with respect to their integrability and the behavior of their norms.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 515, "formal_statement": "theorem dummy (a : Œ±) : 0 ‚â§ fract a :=", "nl_statement": "The theorem named `fract_nonneg` asserts that for any real number \\(a\\), the fractional part of \\(a\\) (denoted as `fract a`) is non-negative. In mathematical terms, this can be expressed as \\(0 \\leq \\text{fract}(a)\\)."}
{"id": 516, "formal_statement": "theorem dummy (n : ‚Ñï) : sqrt (n ^ 2) = n :=", "nl_statement": "The statement to be proven is that the square root of the square of any natural number \\(n\\) is equal to \\(n\\) itself."}
{"id": 517, "formal_statement": "theorem dummy (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=", "nl_statement": "The problem states that if `x` and `y` are nilpotent elements, then their sum `x + y` is also a nilpotent element. An element is considered nilpotent if there exists a positive integer `n` such that the element raised to the power of `n` equals zero."}
{"id": 518, "formal_statement": "theorem dummy (a : M) (m n : ‚Ñï) : (a ^ m) ^ n = (a ^ n) ^ m :=", "nl_statement": "The statement to be proven is that, for any element \\(a\\) of a monoid \\(M\\) and any natural numbers \\(m\\) and \\(n\\), the operation of raising \\(a\\) to the power of \\(m\\) and then raising the result to the power of \\(n\\) yields the same result as raising \\(a\\) to the power of \\(n\\) and then raising the result to the power of \\(m\\). In other words, the operation of taking powers in a certain order is commutative with respect to the base \\(a\\), which can be written as \\((a^m)^n = (a^n)^m\\)."}
{"id": 519, "formal_statement": "theorem dummy : (‚àë i in s, f i) ^ 2 ‚â§ s.card * ‚àë i in s, f i ^ 2 :=", "nl_statement": "The theorem `sq_sum_le_card_mul_sum_sq` states that the square of the sum of a function `f` applied to each element `i` in a set `s` is less than or equal to the product of the size of the set `s` and the sum of the square of the function `f` applied to each element in the set. In mathematical terms, this can be expressed as:\n\\[ (\\sum_{i \\in s} f(i))^2 \\leq |s| \\cdot \\sum_{i \\in s} f(i)^2 \\]\nwhere \\(|s|\\) represents the cardinality of the set `s`, or the number of elements in the set."}
{"id": 520, "formal_statement": "theorem dummy (f : R[X]) : reverse (-f) = -reverse f :=", "nl_statement": "The theorem states that if you take a polynomial \\( f \\) over a real number field \\( R \\), and then reverse the polynomial and negate it, this is the same as negating the polynomial first and then reversing it."}
{"id": 521, "formal_statement": "theorem dummy [Zero Œ±] [One Œ±] : (G.adjMatrix Œ±).IsSymm :=", "nl_statement": "The statement concerns a property of the adjacency matrix of a graph \\(G\\). Specifically, it asserts that the adjacency matrix of \\(G\\), when defined over some type \\(\\alpha\\) that has a notion of zero and one (to represent the absence and presence of edges, respectively), is symmetric. This property is fundamental in graph theory, as the adjacency matrix of an undirected graph is always symmetric. The symmetry of the adjacency matrix means that if there is an edge from vertex \\(i\\) to vertex \\(j\\), then there must also be an edge from vertex \\(j\\) to vertex \\(i\\), reflecting the undirected nature of the graph."}
{"id": 522, "formal_statement": "theorem dummy : b.reindex (Equiv.refl _) = b :=", "nl_statement": "The theorem named `reindex_refl` is about an operation on a mathematical object referred to as `b`, which is of some type that supports a reindexing operation. The operation `reindex` is applied to `b` using an equivalence relation `Equiv.refl _`, which represents the identity relation, meaning each element is related to itself and no others. The statement claims that performing this reindexing operation on `b` using the identity relation as the mapping does not change `b` at all, i.e., `b.reindex (Equiv.refl _) = b`."}
{"id": 523, "formal_statement": "theorem dummy : ball x 0 = ‚àÖ :=", "nl_statement": "The theorem named `ball_zero` asserts that the ball centered at any point `x` with a radius of `0` is equivalent to the empty set."}
{"id": 524, "formal_statement": "theorem dummy [Nontrivial R] : ¬¨Separable (0 : R[X]) :=", "nl_statement": "The theorem `not_separable_zero` states that in a nontrivial ring \\(R\\), the zero polynomial is not separable. This means that there exists no polynomial which, when combined with its derivative through a certain linear combination, equals 1. This condition is critical in the context of field theory and algebra, especially concerning the separability of polynomials, which affects the structure of field extensions."}
{"id": 525, "formal_statement": "theorem dummy {f : Œ†‚ÇÄ i, Finset (Œ± i)} {g : Œ†‚ÇÄ i, Œ± i} : g ‚àà f.pi ‚Üî ‚àÄ i, g i ‚àà f i :=", "nl_statement": "The statement concerns a property about elements in the product of finitely supported functions, specifically dealing with a scenario where we have a finitely supported function `f` that assigns to each index `i` a finite set `Œ± i`, and another finitely supported function `g` that assigns to each index `i` an element of the set `Œ± i`. The theorem states that an element `g` belongs to the product of the sets defined by `f` if and only if, for every index `i`, the element `g i` belongs to the set `f i`."}
{"id": 526, "formal_statement": "theorem dummy (A B : unitaryGroup n Œ±) : toGL (A * B) = toGL A * toGL B :=", "nl_statement": "The theorem states that for any two elements \\(A\\) and \\(B\\) of the unitary group of degree \\(n\\) over a field \\(\\alpha\\), the function `toGL` applied to the product of \\(A\\) and \\(B\\) is equal to the product of `toGL A` and `toGL B`. In other words, the function `toGL` preserves multiplication within the unitary group."}
{"id": 527, "formal_statement": "theorem dummy (x : ‚Ñï) : (x : PartENat) ‚â† ‚ä§ :=", "nl_statement": "The theorem stated is about the type casting of a natural number (denoted by ‚Ñï) to a type called `PartENat`, which represents partially defined natural numbers (that is, natural numbers plus a symbol for infinity, denoted by ‚ä§). The statement asserts that when a natural number `x` is typecast to `PartENat`, it cannot be equal to the symbol for infinity (‚ä§)."}
{"id": 528, "formal_statement": "theorem dummy : Ioc (a : WithTop Œ±) ‚ä§ = insertNone (Ioi a) :=", "nl_statement": "The statement defines a relationship between intervals on the extended real number line, where `Œ±` represents any type that can be ordered. `WithTop Œ±` refers to the type `Œ±` extended with an element representing infinity (denoted as `‚ä§` in Lean4). The interval `Ioc (a : WithTop Œ±) ‚ä§` refers to the interval of numbers that are greater than `a` but less than or equal to infinity. The function `insertNone (Ioi a)` constructs a set that includes all elements greater than `a`, along with infinity. The theorem states that for any `a` of type `WithTop Œ±`, the interval of numbers greater than `a` and up to infinity is exactly the set that contains all elements greater than `a`, inclusive of infinity itself."}
{"id": 529, "formal_statement": "theorem dummy (e : Œ± ‚âÉo Œ≤) : e.toEquiv.symm = e.symm.toEquiv :=", "nl_statement": "The statement involves a theorem concerning ordered equivalences between two types, `Œ±` and `Œ≤`. It asserts that converting an ordered equivalence (`‚âÉo`) to a regular equivalence (`toEquiv`) and then taking the symmetry (`symm`) of this equivalence yields the same result as first taking the symmetry of the ordered equivalence and then converting it to a regular equivalence."}
{"id": 530, "formal_statement": "theorem dummy (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=", "nl_statement": "The theorem named `IsBaseChange.lift_eq` is concerned with a scenario in a linear algebra context over a ring \\(R\\). Given a linear map \\(g: M \\rightarrow Q\\), where \\(M\\) and \\(Q\\) are modules over \\(R\\), and another map \\(f: M \\rightarrow S\\), where \\(S\\) is presumably another \\(R\\)-module, the theorem states that for any element \\(x\\) in \\(M\\), applying \\(g\\) directly to \\(x\\) is equivalent to first applying \\(f\\) to \\(x\\), then lifting the result through a certain function \\(h.lift\\), which seems to construct a new linear map based on \\(g\\) and the action of \\(f\\)."}
{"id": 531, "formal_statement": "theorem dummy : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ :=", "nl_statement": "The statement in question is about the mathematical concept of a sphere in a metric space, specifically relating to the symmetry of membership within a sphere. The theorem can be stated as follows: \"For any two points \\(x\\) and \\(y\\) in a metric space, and for any non-negative real number \\(\\epsilon\\), \\(x\\) is within the \\(\\epsilon\\)-sphere centered at \\(y\\) if and only if \\(y\\) is within the \\(\\epsilon\\)-sphere centered at \\(x\\).\""}
{"id": 532, "formal_statement": "theorem dummy : @LE.le (WithBot Œ±) _ (Option.some a) (Option.some b) ‚Üî a ‚â§ b :=", "nl_statement": "The theorem `some_le_some` asserts that, within the context of the type `WithBot Œ±` (which represents an option type that can either be \"some value of type Œ±\" or \"bottom,\" indicating no value), the statement that \"some value `a` is less than or equal to some value `b`\" is equivalent to saying \"`a` is less than or equal to `b`\" in the underlying type `Œ±`."}
{"id": 533, "formal_statement": "theorem dummy : Ioc a b \\ Ioi c = Ioc a (min b c) := ext <| by simp (config := { contextual :=", "nl_statement": "The statement concerns the difference between two specific sets of real numbers. It asserts that the difference between the closed-open interval from `a` to `b` (denoted as `Ioc a b`, which includes all real numbers greater than `a` and less than or equal to `b`) and the open interval from `c` to infinity (denoted as `Ioi c`, which includes all real numbers strictly greater than `c`), is equal to the closed-open interval from `a` to the minimum of `b` and `c` (denoted as `Ioc a (min b c)`)."}
{"id": 534, "formal_statement": "theorem dummy : Inducing (UniformFun.ofFun ‚àò (‚áë) : (Œ± ‚Üí·µá Œ≤) ‚Üí Œ± ‚Üí·µ§ Œ≤) :=", "nl_statement": "The statement concerns a mathematical property involving functions in a certain context, likely within the realm of topology or analysis, given the terms used. Specifically, it asserts that a certain mapping, when applied to bounded continuous functions from one space to another, induces a uniform structure on the domain space that is compatible with the uniform structure on the target space. The mapping in question seems to be a composition of two functions: one is the `UniformFun.ofFun` (which is not standard mathematical notation but suggests a function related to uniform spaces), and the other is the coercion function `(‚áë)` that applies a bounded continuous function to its argument."}
{"id": 535, "formal_statement": "theorem dummy (a : Œ±) : a ‚Ä¢ b ‚àà a ‚Ä¢ s ‚Üî b ‚àà s :=", "nl_statement": "The statement you've presented is about scalar multiplication in the context of a set \\( s \\) and an element \\( b \\) within a mathematical structure where scalar multiplication (\\( a \\cdot b \\)) is defined. Specifically, the theorem `smul_mem_smul_finset_iff` asserts a conditional relationship between an element \\( b \\) and a set \\( s \\) under scalar multiplication by \\( a \\). It states that for an element \\( a \\) and a set \\( s \\), the result of scalar multiplying \\( a \\) with \\( b \\) (denoted \\( a \\cdot b \\)) is in the scalar multiplied set \\( a \\cdot s \\) if and only if \\( b \\) is in the original set \\( s \\)."}
{"id": 536, "formal_statement": "theorem dummy [OrderBot Œ±] {a b : Œ±} : min a b = ‚ä• ‚Üî a = ‚ä• ‚à® b = ‚ä• :=", "nl_statement": "The theorem states that for any two elements `a` and `b` in a partially ordered set with a least element (denoted as `‚ä•`), the minimum of `a` and `b` is equal to the least element if and only if at least one of `a` or `b` is equal to the least element."}
{"id": 537, "formal_statement": "theorem dummy {p : Œ±} (hp : Prime p) : Prime (-p) :=", "nl_statement": "The statement to be translated is about prime numbers in a given mathematical structure. The theorem states that if a number \\( p \\) is prime, then its negation \\( -p \\) is also prime."}
{"id": 538, "formal_statement": "theorem dummy : a + c < b ‚Üí a < b - c :=", "nl_statement": "The theorem states that if the sum of `a` and `c` is less than `b`, then `a` is less than the difference of `b` and `c` (i.e., `a + c < b` implies `a < b - c`)."}
{"id": 539, "formal_statement": "theorem dummy (k : ‚Ñï) : p.radius ‚â§ (p.changeOriginSeries k).radius :=", "nl_statement": "This theorem relates to the field of functional analysis, specifically dealing with the properties of power series within the context of the Lean4 theorem prover. The statement asserts that for any power series \\(p\\) and a non-negative integer \\(k\\), the radius of convergence of the original series \\(p\\) is less than or equal to the radius of convergence of the series obtained by changing its origin to \\(k\\)."}
{"id": 540, "formal_statement": "theorem dummy (hs : s ‚àà f) : s ‚â† ‚àÖ :=", "nl_statement": "The theorem states that if a set `s` is an element of a filter `f`, then `s` cannot be empty."}
{"id": 541, "formal_statement": "theorem dummy {f g : Œ± ‚Üí+* Œ≤} (h : f = g) (x : Œ±) : f x = g x :=", "nl_statement": "The given statement is a theorem about function congruence in the context of ring homomorphisms. Specifically, it states that if two ring homomorphism functions `f` and `g` from a domain `Œ±` to a codomain `Œ≤` are equal (`f = g`), then the application of these functions to any element `x` in the domain `Œ±` will yield the same result (`f x = g x`)."}
{"id": 542, "formal_statement": "theorem dummy : ‚Äñf‚Äñ = ‚®Ü x : Œ±, ‚Äñf x‚Äñ :=", "nl_statement": "The statement describes a theorem regarding the norm of a function \\(f\\). Specifically, it states that the norm of \\(f\\) is equal to the supremum (denoted by \\(\\sup\\)) of the norms of \\(f(x)\\) for all \\(x\\) in the domain \\(\\alpha\\).\n\nIn essence, the proof demonstrates that, by considering \\(f\\) as part of a compact (or appropriately constrained) setting and utilizing the framework of continuous mappings, one can establish the equality between the norm of \\(f\\) and the supremum of the norms of \\(f(x)\\) over all \\(x\\). This connection is crucial in translating the abstract notion into a concrete equality statement about norms, leveraging the structured environment provided by continuous maps.\n\nTo understand the mathematical reasoning in more natural language:\n1. We start with a function \\(f\\) which is assumed to be part of a compact or well-behaved space, allowing for the application of compactness-related properties.\n2. The statement \\(\\|f\\| = \\sup_{x \\in \\alpha} \\|f(x)\\|\\) claims that the overall \"size\" or \"magnitude\" of \\(f\\), captured by its norm, is exactly the greatest of the sizes of its values across its domain. This notion aligns with the intuitive idea that the \"largest\" or \"most extreme\" value dictates the norm of the entire function.\n3. The proof leverages the concept of continuous mappings to solidify this intuitive notion into a formal statement, asserting that such a relationship between the function's norm and the supremum of its values' norms holds true within the realm of continuous functions. The specifics of how `mkOfCompact` and the continuous map properties are used to establish this are not detailed but are implied to provide the necessary mathematical infrastructure for the theorem's validity.\n\nThis explanation translates the lemma and its proof from the domain-specific language of Lean4 into a more accessible form, maintaining the logical and mathematical structure inherent in the original statement and argumentation.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 543, "formal_statement": "theorem dummy {f g : L‚ÇÅ ‚Üí‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ} (h : ‚àÄ x, f x = g x) : f = g :=", "nl_statement": "The statement concerns two linear maps \\( f \\) and \\( g \\) from a Lie algebra \\( L‚ÇÅ \\) to another Lie algebra \\( L‚ÇÇ \\) over a ring \\( R \\). The theorem, named `ext`, asserts that if for every element \\( x \\) in \\( L‚ÇÅ \\), the maps \\( f \\) and \\( g \\) produce the same output (\\( f(x) = g(x) \\)), then \\( f \\) and \\( g \\) are, in fact, the same linear map (\\( f = g \\))."}
{"id": 544, "formal_statement": "theorem dummy : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=", "nl_statement": "The statement to be proven is that two sets, `s` and `t`, are disjoint if and only if for every element `a` in set `s` and every element `b` in set `t`, `a` is not equal to `b`."}
{"id": 545, "formal_statement": "theorem dummy : (aevalTower g y : MvPolynomial œÉ R ‚Üí+* A).comp C = g :=", "nl_statement": "The lemma `aevalTower_comp_C` states that if you compose (combine) the evaluation map `aevalTower` with the constant polynomial map `C` in a certain way, the result is equivalent to the original function `g`. The `aevalTower` is a function that evaluates multivariate polynomials over some ring `R` with variables from the set `œÉ`, at a given point in a ring `A` using the function `g`. The constant polynomial map `C` turns elements of the ring `R` into constant polynomials in `MvPolynomial œÉ R`, which is the set of multivariate polynomials over `R` with variables from `œÉ`."}
{"id": 546, "formal_statement": "theorem dummy : lift R f ‚àò Œπ R = f :=", "nl_statement": "The theorem named \"Œπ_comp_lift\" states that the composition of the \"lift\" function with the function \"Œπ\" (iota) applied to a ring \"R\" and a function \"f\" is equal to the function \"f\" itself. In the context of universal enveloping algebras, this theorem suggests a certain kind of compatibility or a preservation property between the \"lift\" operation and the embedding denoted by \"Œπ\"."}
{"id": 547, "formal_statement": "theorem dummy [Subsingleton Œ±] (s : Finset Œ±) : s.card ‚â§ 1 :=", "nl_statement": "The statement given is about a property of finite sets (Finsets) in a specific context defined by a type `Œ±`. Specifically, it addresses the scenario where `Œ±` is a type with the property of being a \"subsingleton.\" In mathematics, a subsingleton is a set that contains at most one element. The statement, or theorem, asserts that for any finite set (`s`) of elements of type `Œ±`, if `Œ±` is a subsingleton, then the number of elements (`card`) in `s` is less than or equal to one."}
{"id": 548, "formal_statement": "theorem dummy (c : E) : Convex ùïú ({c} : Set E) :=", "nl_statement": "The statement concerns the property of convexity in a mathematical context, specifically applied to a singleton set. The theorem asserts that a singleton set containing a single element \\(c\\) in a vector space \\(E\\) is convex. Convexity, in this sense, refers to the idea that, for any two points within the set, any point on the straight line segment that joins these two points also lies within the set. Since a singleton set contains only one element, this property is trivially satisfied."}
{"id": 549, "formal_statement": "theorem dummy {x : ‚Ñù} {n : ‚Ñï} : ENNReal.ofReal (n ‚Ä¢ x) = n ‚Ä¢ ENNReal.ofReal x :=", "nl_statement": "The statement concerns the operation of scaling a real number \\(x\\) by a natural number \\(n\\), and its relationship with the function `ENNReal.ofReal`, which maps a real number to its equivalent in the type `ENNReal`. Specifically, the theorem asserts that applying the `ENNReal.ofReal` function to \\(n\\) times the real number \\(x\\) (\\(n \\cdot x\\)) is the same as multiplying \\(n\\) by the `ENNReal.ofReal` value of \\(x\\)."}
{"id": 550, "formal_statement": "theorem dummy {f : Œ± ‚Üí Œ≤} {s t : Multiset Œ±} (h : s < t) : s.map f < t.map f :=", "nl_statement": "The statement we are considering can be described as follows: Given two multisets `s` and `t` and a function `f` from type `Œ±` to type `Œ≤`, if `s` is strictly less than `t`, then the multiset resulting from applying `f` to each element of `s` is strictly less than the multiset resulting from applying `f` to each element of `t`. Here, \"strictly less than\" refers to the notion that one multiset is a sub-multiset of another but not equal to it."}
{"id": 551, "formal_statement": "theorem dummy : (-s).length = s.length :=", "nl_statement": "The statement concerns the length of a string (or sequence) `s` and its negated version `-s`. It asserts that the length of `-s` is equal to the length of `s`."}
{"id": 552, "formal_statement": "theorem dummy : Monotone (ùìù : Filter Œ± ‚Üí Filter (Filter Œ±)) :=", "nl_statement": "The theorem named `monotone_nhds` asserts that the function that maps each filter to its neighborhood filter is monotone. In the context of topology, a filter on a set `Œ±` is a mathematical structure that allows the formalization of concepts such as convergence, neighborhoods, and limits. The neighborhood filter of a point (or in a more abstract sense, an element of the filter) captures the idea of all the sets that contain \"close\" elements to that point. Saying that this mapping is monotone means that if you have two filters, and one is a subset of the other, then the neighborhood filter of the first is also a subset of the neighborhood filter of the second. This property is crucial for understanding how the topology of a space behaves under various operations."}
{"id": 553, "formal_statement": "theorem dummy : unpair 0 = 0 :=", "nl_statement": "The theorem named `unpair_zero` asserts that the result of an `unpair` operation on `0` yields `0`. This involves a specific function or operation, presumably named `unpair`, being applied to the number `0`, and the statement claims that this operation will result in `0`."}
{"id": 554, "formal_statement": "theorem dummy : e.permCongr (Equiv.refl _) = Equiv.refl _ :=", "nl_statement": "This problem involves a theorem concerning permutation congruence and its reflexivity property, framed within the context of mathematical structures, possibly groups, and equivalence relations in Lean4, a theorem prover used for formal verification of mathematical theorems and proofs.\n\nThe theorem, `permCongr_refl`, asserts that if you apply the permutation congruence function to the reflexive equivalence (the identity equivalence, `Equiv.refl _`), you get back the same reflexive equivalence. This statement is about the invariance of the identity under the permutation congruence operation."}
{"id": 555, "formal_statement": "theorem dummy [Nonempty Œπ] : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ b, ‚Äñf b‚Äñ ‚â§ r :=", "nl_statement": "The theorem states that, given a non-empty index set \\( \\mathbb{\\iota} \\) and a function \\( f \\) from \\( \\mathbb{\\iota} \\) to a normed vector space, the norm of \\( f \\), denoted as \\( \\lVert f \\rVert \\), is less than or equal to some real number \\( r \\), if and only if for every element \\( b \\) in the index set \\( \\mathbb{\\iota} \\), the norm of \\( f(b) \\), \\( \\lVert f(b) \\rVert \\), is less than or equal to \\( r \\)."}
{"id": 556, "formal_statement": "theorem dummy {a : Œ±} {n} {l : List Œ±} : replicate n a ‚â§ l ‚Üî List.replicate n a <+ l :=", "nl_statement": "The statement concerns the relationship between list replication and the sublist ordering in the context of a list `l` of type `List Œ±`, where `Œ±` is any type, `a` is an element of type `Œ±`, and `n` is an integer. The theorem states that replicating the element `a` `n` times (denoted as `replicate n a`) is less than or equal to the list `l` (in the sense of sublist ordering, denoted by `‚â§`) if and only if the replicated list is a sub-permutation of `l`."}
{"id": 557, "formal_statement": "theorem dummy : Partrec fun n => ppred n := have : Primrec‚ÇÇ fun n m => if n = Nat.succ m then 0 else 1 :=", "nl_statement": "The theorem presented states that the partial predecessor function (ppred) is partially recursive. In simpler terms, it's about proving that there exists a computable function that, given a natural number `n`, returns its predecessor (the number that comes before `n`) if `n` is not zero, and is undefined (or does not return a result) if `n` is zero. This concept is fundamental in the theory of computation, illustrating how certain basic functions can be computed or not computed based on their definitions."}
{"id": 558, "formal_statement": "theorem dummy : b ‚àà erase s a ‚Üí b ‚àà s :=", "nl_statement": "The theorem named `mem_of_mem_erase` asserts that if an element `b` is present in a set from which an element `a` has been removed (`erase s a`), then `b` must also have been present in the original set `s`."}
{"id": 559, "formal_statement": "theorem dummy : minpoly R (toLin' M) = minpoly R M :=", "nl_statement": "The problem statement given refers to a theorem concerning the minimal polynomial of a linear transformation and its representation matrix. Specifically, the theorem states that the minimal polynomial of a linear transformation when represented as a matrix (denoted as `toLin' M`) is equal to the minimal polynomial of the matrix `M` itself. In mathematical terms, the minimal polynomial of a matrix or linear map is the monic polynomial of least degree that annihilates the matrix or linear map."}
{"id": 560, "formal_statement": "theorem dummy (x : R) : (X + C x).natDegree = 1 :=", "nl_statement": "The statement concerns the natural degree of a specific polynomial in a ring \\(R\\). The polynomial in question is \\(X + Cx\\), where \\(X\\) represents a variable and \\(C x\\) represents a constant polynomial generated by some element \\(x\\) in \\(R\\). The theorem asserts that the natural degree of this polynomial is 1."}
{"id": 561, "formal_statement": "theorem dummy (z w : ‚Ñ§‚àöd) : (z * w).re = z.re * w.re + d * z.im * w.im :=", "nl_statement": "The theorem concerns the multiplication of two complex numbers of a specific form, where each complex number is represented as `z` and `w`, belonging to a set denoted by ‚Ñ§‚àöd. This set consists of numbers that can be expressed as a combination of a real part and an imaginary part multiplied by a square root of `d`, where `d` is an integer. The theorem states that the real part of the product of `z` and `w` (`(z * w).re`) is equal to the product of their real parts plus `d` times the product of their imaginary parts (`z.re * w.re + d * z.im * w.im`)."}
{"id": 562, "formal_statement": "theorem dummy : Bijective arsinh :=", "nl_statement": "The statement asserts that the function `arsinh` (inverse hyperbolic sine) is bijective, which means it is both injective (one-to-one) and surjective (onto)."}
{"id": 563, "formal_statement": "theorem dummy (h : HasDerivAt f f' x) : ContinuousAt f x :=", "nl_statement": "The theorem states that if a function \\(f\\) has a derivative at a point \\(x\\) (denoted as `HasDerivAt f f' x`), then \\(f\\) is continuous at \\(x\\)."}
{"id": 564, "formal_statement": "theorem dummy {c : E} (f : ContDiffBump c) : 0 < f.rOut :=", "nl_statement": "The theorem is about a mathematical concept or function named `ContDiffBump` centered at a point `c` in some space `E`. It states that the outer radius (`rOut`) of `ContDiffBump` is greater than zero."}
{"id": 565, "formal_statement": "theorem dummy [Finite œÉ] : range (eval·µ¢ œÉ K) = ‚ä§ :=", "nl_statement": "The theorem `range_eval·µ¢` asserts that for any finite type `œÉ` and some given `K`, the range of the function `eval·µ¢ œÉ K` is the entire space, denoted by `‚ä§`."}
{"id": 566, "formal_statement": "theorem dummy (f : Œ± √ó Œ≤ ‚Üío Œ≥) (x : Œ±) (y : Œ≤) : curry f x y = f (x, y) :=", "nl_statement": "The given statement involves a theorem related to the concept of \"currying\" in the context of order-preserving functions (denoted by `‚Üío` in the Lean4 syntax). Specifically, it states that for any order-preserving function `f` that takes a pair of elements `(x, y)` of types `Œ±` and `Œ≤` respectively and produces an element of type `Œ≥`, the curried version of `f` applied to `x` and then `y` yields the same result as applying `f` directly to the pair `(x, y)`."}
{"id": 567, "formal_statement": "theorem dummy (hU : IsOpen U) (h‚ÇÄ : Œº U = 0) : U = ‚àÖ :=", "nl_statement": "The statement we're examining is a theorem regarding measure theory, a branch of mathematics that studies ways to assign a number to indicate the size of a set, which can be thought of as a generalization of length, area, and volume. The theorem can be phrased as follows:\n\n\"If a set \\(U\\) is open and has a measure of zero, then \\(U\\) must be empty.\"\n\nIn this context, being \"open\" is a property of sets in a topological space that intuitively means there is a \"buffer\" around each point within the set. The \"measure\" of a set quantifies its size, and a measure of zero suggests the set contains no \"space\"."}
{"id": 568, "formal_statement": "theorem dummy : 0 < a * a := le_trans (le_of_lt a1) (by have :=", "nl_statement": "The statement is asserting that for a positive integer \\(a\\), the square of \\(a\\) (\\(a * a\\)) is also positive."}
{"id": 569, "formal_statement": "theorem dummy {x : ùïú'} (hx : x ‚â† 0) {n} : ContDiffAt ùïú n Inv.inv x :=", "nl_statement": "This theorem states that if `x` is a non-zero element of a field `ùïú'`, then the function `Inv.inv`, which calculates the multiplicative inverse of `x`, is continuously differentiable at `x` for any differentiation order `n`."}
{"id": 570, "formal_statement": "theorem dummy {P : PartENat ‚Üí Prop} : ‚àÄ a : PartENat, P ‚ä§ ‚Üí (‚àÄ n : ‚Ñï, P n) ‚Üí P a :=", "nl_statement": "The theorem at hand involves a type called `PartENat`, which is a partially extended natural number. This type includes all natural numbers (`‚Ñï`) plus an additional element denoted as `‚ä§` to represent infinity or an undefined value. The theorem states that for any property `P` that can apply to elements of `PartENat`, to prove that `P` holds for any element `a` of `PartENat`, it suffices to show that `P` holds for `‚ä§` and that `P` holds for every natural number `n`."}
{"id": 571, "formal_statement": "theorem dummy : (@toBoolRing Œ±).symm = ofBoolRing :=", "nl_statement": "The statement provided is about a mathematical structure or concept related to Boolean rings in a programming context, specifically within the Lean4 theorem prover environment. It claims that the inverse (`symm`) of converting any type `Œ±` into a Boolean ring (`toBoolRing`) is equal to the function that converts back from a Boolean ring to the original type `Œ±` (`ofBoolRing`)."}
{"id": 572, "formal_statement": "theorem dummy (s‚ÇÅ s‚ÇÇ : Finset Œ±) : s‚ÇÇ ‚äÜ s‚ÇÅ ‚à™ s‚ÇÇ :=", "nl_statement": "The statement is about subsets and unions in the context of finite sets (Finsets). Specifically, it asserts that for any two finite sets, \\(s_1\\) and \\(s_2\\), the set \\(s_2\\) is a subset of the union of \\(s_1\\) and \\(s_2\\)."}
{"id": 573, "formal_statement": "theorem dummy (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=", "nl_statement": "The statement asserts that for any subgraph `G'` of a graph `G` and any vertex `v` in `G'`, the set of neighbors of `v` in `G'` is a subset of the vertices of `G'`. In other words, every neighbor of `v` in the subgraph `G'` is also a vertex in `G'`."}
{"id": 574, "formal_statement": "theorem dummy (s t u : Set Œ±) : s ‚à™ (t ‚à™ u) = s ‚à™ t ‚à™ (s ‚à™ u) :=", "nl_statement": "The theorem states that for any three sets \\(s\\), \\(t\\), and \\(u\\), the union of \\(s\\) with the union of \\(t\\) and \\(u\\) is equal to the union of \\(s\\) and \\(t\\) united with the union of \\(s\\) and \\(u\\). In mathematical terms, this can be written as \\(s \\cup (t \\cup u) = (s \\cup t) \\cup (s \\cup u)\\)."}
{"id": 575, "formal_statement": "theorem dummy : (a ‚äî b) ‚äì a ‚áî b = a ‚äì b :=", "nl_statement": "The lemma states that the supremum (least upper bound) of `a` and `b` combined with the infimum (greatest lower bound) of `a` is bi-implicative (or logically equivalent) to `b` being equal to the infimum of `a` and `b`. In symbolic terms, it says (a ‚äî b) ‚äì a ‚áî b = a ‚äì b."}
{"id": 576, "formal_statement": "theorem dummy : arsinh x < arsinh y ‚Üî x < y :=", "nl_statement": "The theorem we're discussing states that the hyperbolic arcsine of \\(x\\) is less than the hyperbolic arcsine of \\(y\\) if and only if \\(x\\) is less than \\(y\\). In simpler terms, it tells us that the order of numbers is preserved when taking the hyperbolic arcsine of those numbers."}
{"id": 577, "formal_statement": "theorem dummy : BddBelow { r : ‚Ñù | 0 < r ‚àß x ‚àà r ‚Ä¢ s } :=", "nl_statement": "The statement provided is a theorem in the context of real numbers and set theory, formulated within the Lean4 theorem proving environment. Let's break down the theorem into a more understandable statement in natural language.\n\nThe theorem, named `gauge_set_bddBelow`, asserts that the set of all real numbers \\( r \\) such that \\( r \\) is positive (\\( 0 < r \\)) and \\( x \\) belongs to the scalar multiplication of \\( r \\) and a set \\( s \\) (\\( x \\in r \\cdot s \\)), is bounded below. In simpler terms, there exists a lower bound for this set of real numbers."}
{"id": 578, "formal_statement": "theorem dummy {x y : Œ±} : x ‚àà span ({y} : Set Œ±) ‚Üî y ‚à£ x :=", "nl_statement": "The statement concerns the relationship between two elements, \\(x\\) and \\(y\\), within a certain mathematical structure, specifically within the context of an algebraic structure like a ring or a field. It asserts that \\(x\\) is an element of the span of the singleton set containing \\(y\\) if and only if \\(y\\) divides \\(x\\). In more formal terms, this can be stated as: \\(x \\in \\text{span}(\\{y\\}) \\iff y \\mid x\\)."}
{"id": 579, "formal_statement": "theorem dummy : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) :=", "nl_statement": "The statement `nhds_top_basis` is about the topology of extended real numbers, denoted by `EReal`. Specifically, it asserts that the neighborhood filter at infinity (denoted `ùìù(‚ä§ : EReal)`) has a basis. A basis for a filter is a collection of sets such that every set in the filter contains one of these basis sets. In this case, the basis sets are of the form `(Ioi x)` for any real number `x`, where `Ioi` stands for the interval open on the left and infinite on the right, `(x, ‚àû)`."}
{"id": 580, "formal_statement": "theorem dummy : IntegrableOn f (s ‚à™ t) Œº ‚Üî IntegrableOn f s Œº ‚àß IntegrableOn f t Œº :=", "nl_statement": "The statement concerns the integrability of a function \\(f\\) over the union of two sets \\(s\\) and \\(t\\) with respect to a measure \\(\\mu\\). Specifically, it posits that \\(f\\) is integrable over \\(s \\cup t\\) if and only if \\(f\\) is integrable over both \\(s\\) and \\(t\\) separately."}
{"id": 581, "formal_statement": "theorem dummy (h : t.WellFoundedOn r) (hst : s ‚äÜ t) : s.WellFoundedOn r :=", "nl_statement": "The theorem states that if a relation `r` is well-founded on a set `t`, and if set `s` is a subset of set `t`, then the relation `r` is also well-founded on set `s`."}
{"id": 582, "formal_statement": "theorem dummy (x y : M‚ÇÄ) (h : IsUnit x) : y * x * inverse x = y :=", "nl_statement": "This statement pertains to the property of multiplicative inverses in a structure (denoted as `M‚ÇÄ`) where multiplication is defined and where the concept of a \"unit\" (an element that has a multiplicative inverse) is meaningful. Specifically, the theorem states that for any two elements `x` and `y` in `M‚ÇÄ`, if `x` is a unit (meaning `x` has a multiplicative inverse), then the product of `y` and `x` followed by the multiplication of the inverse of `x` equals `y`. In formal terms, if `x` is a unit, then \\(y \\times x \\times x^{-1} = y\\)."}
{"id": 583, "formal_statement": "theorem dummy : ‚àÉ œñ : R, Prime œñ :=", "nl_statement": "The statement concerns the existence of a prime element in a given ring \\(R\\). Specifically, it asserts that there exists at least one element, denoted by \\(\\omega\\), in the ring \\(R\\) such that \\(\\omega\\) is prime."}
{"id": 584, "formal_statement": "theorem dummy : Function.Injective (map f) :=", "nl_statement": "The statement concerns the injectivity of a function obtained by mapping another function \\( f \\) over a domain. Specifically, it asserts that if \\( f \\) is injective, then the mapping function \\( \\text{map} \\, f \\) is also injective."}
{"id": 585, "formal_statement": "theorem dummy : pure (1 : Œ±) = 1 :=", "nl_statement": "The given statement is a theorem named `pure_one` which asserts that the operation `pure` applied to the number 1 (within some context `Œ±`) equals the number 1 itself. This theorem is presumably related to a mathematical or computational context where `pure` is a function that, based on the information provided, seems to encapsulate a value within a certain computational or mathematical structure, without altering the value itself."}
{"id": 586, "formal_statement": "theorem dummy {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d :=", "nl_statement": "The statement concerns a function named `K'.elim`, which takes four arguments (a, b, c, d) and produces some result. The theorem, `K'.elim_update_main`, asserts that if you update the first argument (a) of this function with a new value (a'), while keeping the other arguments (b, c, d) unchanged, the result is the same as directly calling `K'.elim` with the new argument a' and the unchanged arguments b, c, and d."}
{"id": 587, "formal_statement": "theorem dummy {x y : ‚Ñù} (hx : x ‚àà I) (hy : y ‚àà I) : x * y ‚àà I :=", "nl_statement": "The statement pertains to a property within the realm of real numbers (‚Ñù), focusing on a specific set `I`, which is not explicitly defined in the given statement but can be inferred to be the interval [0, 1] based on the context of `unit_interval`. The theorem asserts that if you have any two numbers, `x` and `y`, belonging to the interval `I`, then the product of these two numbers, `x * y`, also belongs to `I`."}
{"id": 588, "formal_statement": "theorem dummy : a ‚ôØ 1 = succ a :=", "nl_statement": "The statement `nadd_one : a ‚ôØ 1 = succ a` is a mathematical theorem which, in natural language, asserts that the natural addition (denoted by `‚ôØ`) of an ordinal `a` with `1` (the successor of `0` in ordinal numbers) is equal to the successor of `a` (denoted by `succ a`), where `succ a` represents the next ordinal after `a`."}
{"id": 589, "formal_statement": "theorem dummy : (pullbackConeOfRightIso f g).œÄ.app none = f :=", "nl_statement": "The statement concerns a specific structure in category theory, particularly within the context of pullback cones. A pullback cone is a construct in category theory used to define the pullback of two morphisms (which can be thought of as arrows or functions) that have a common codomain. The theorem named `pullbackConeOfRightIso_œÄ_app_none` is about the projection map (denoted as `œÄ.app none`) of a pullback cone constructed from a right isomorphism (an isomorphism is a mapping that has an inverse, making it reversible; a right isomorphism means this property holds when the function is considered from the right side, often implying certain properties about the morphisms involved). This theorem asserts that this projection map is equal to one of the original morphisms, specifically `f`."}
{"id": 590, "formal_statement": "theorem dummy : (X - C a) * (p / (X - C a)) = p ‚Üî IsRoot p a :=", "nl_statement": "The theorem named `mul_div_eq_iff_isRoot` states a condition related to polynomials. It suggests that the product of the polynomial `(X - C a)` and the division of some polynomial `p` by `(X - C a)` equals `p` if and only if `a` is a root of the polynomial `p`. Essentially, this theorem is about the relationship between division by a monic polynomial, multiplication, and the property of being a root of a polynomial."}
{"id": 591, "formal_statement": "theorem dummy {i : œÉ} : pderiv i (1 : MvPolynomial œÉ R) = 0 :=", "nl_statement": "This theorem states that the partial derivative of the constant polynomial 1, with respect to any variable `i` in a multivariate polynomial ring `MvPolynomial œÉ R` over a ring `R` and indexed by `œÉ`, is equal to 0."}
{"id": 592, "formal_statement": "theorem dummy : a ‚àà s ‚Üí (¬∑ ‚äî ¬∑) a '' t ‚äÜ s ‚äª t :=", "nl_statement": "The theorem named `image_subset_sups_right` asserts that if an element `a` belongs to a set `s`, then the image of the set `t` under the operation `(¬∑ ‚äî ¬∑)` applied to `a` and elements of `t` is a subset of the union of sets `s` and `t`. In more understandable terms, this theorem is about how transforming one set (`t`) based on a specific operation related to another element (`a`) from a different set (`s`), results in a new set that does not extend outside the combined elements of both original sets `s` and `t`.\n\nIn natural language, what this means is that the theorem's proof doesn't explicitly break down the logical steps here but instead points to an existing proof or lemma that has already established the necessary logical framework to conclude that the operation `(¬∑ ‚äî ¬∑)` applied with `a` and any element of `t`, results in elements that, when collected into a set, will always be within the superset formed by combining `s` and `t`. This approach of referencing other proofs is common in mathematical logic and theorem proving, as it allows for building complex proofs from established building blocks without repeating the foundational work each time.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 593, "formal_statement": "theorem dummy (a : Œ±) : const a = a::const a :=", "nl_statement": "The theorem named `const_eq` asserts that for any given element `a` of some type `Œ±`, when you create a stream (an infinite list) that constantly repeats this element `a`, the result is equal to a stream where `a` is the head followed by the rest of the stream which also constantly repeats `a`. In essence, it states that a constant stream generated with an element is the same as a stream with that element followed by a constant stream of the same element."}
{"id": 594, "formal_statement": "theorem dummy : ‚ä• ‚àÜ a = a :=", "nl_statement": "The theorem named `bot_symmDiff` states that the symmetric difference between the bottom element (denoted as `‚ä•`) and any set `a` is equal to the set `a` itself."}
{"id": 595, "formal_statement": "theorem dummy {a b : Œ±} (h : a < b) : ùìù[Ioo a b] a = ùìù[>] a :=", "nl_statement": "The theorem states that for any two elements `a` and `b` of a totally ordered set `Œ±`, where `a` is less than `b` (`a < b`), the neighborhood within the open interval `(a, b)` of `a` is equal to the neighborhood of `a` restricted to the set of elements greater than `a`."}
{"id": 596, "formal_statement": "theorem dummy : y \\ x ‚äî x = y ‚äî x := calc y \\ x ‚äî x = y \\ x ‚äî (x ‚äî x ‚äì y) :=", "nl_statement": "The theorem states that for any two elements \\( y \\) and \\( x \\), the symmetric difference of \\( y \\) and \\( x \\) unioned with \\( x \\) is equal to the union of \\( y \\) and \\( x \\). In mathematical terms, \\( y \\setminus x \\cup x = y \\cup x \\). Here, \\( y \\setminus x \\) represents the set of elements in \\( y \\) that are not in \\( x \\), \\( \\cup \\) is the union operator, and \\( \\setminus \\) is the set difference operator."}
{"id": 597, "formal_statement": "theorem dummy : ¬¨IsCountablyGenerated (ùìù (‚àû : ‚Ñö‚àû)) :=", "nl_statement": "The statement given is a theorem about topological spaces, specifically within the context of the Alexandroff one-point compactification of the rational numbers, denoted as ‚Ñö‚àû. The theorem states that the neighborhood filter of infinity (‚àû) in this compactified space is not countably generated. In simpler terms, the collection of sets that approximate the point at infinity closely enough cannot be described by a countable set of sets."}
{"id": 598, "formal_statement": "theorem dummy (h : a ‚â§ b) : insert b (Ico a b) = Icc a b :=", "nl_statement": "The statement to be proved is that if you have two numbers, `a` and `b`, and `a` is less than or equal to `b`, then adding `b` to the set of integers from `a` to `b` (inclusive of `a` and exclusive of `b`) is the same as the set of integers from `a` to `b` inclusive of both `a` and `b`."}
{"id": 599, "formal_statement": "theorem dummy : ‚àÄ {k‚ÇÅ k‚ÇÇ c n x}, k‚ÇÅ ‚â§ k‚ÇÇ ‚Üí x ‚àà evaln k‚ÇÅ c n ‚Üí x ‚àà evaln k‚ÇÇ c n | 0, k‚ÇÇ, c, n, x, _, h => by simp [evaln] at h | k + 1, k‚ÇÇ + 1, c, n, x, hl, h => by have hl' := Nat.le_of_succ_le_succ hl have : ‚àÄ {k k‚ÇÇ n x : ‚Ñï} {o‚ÇÅ o‚ÇÇ : Option ‚Ñï}, k ‚â§ k‚ÇÇ ‚Üí (x ‚àà o‚ÇÅ ‚Üí x ‚àà o‚ÇÇ) ‚Üí x ‚àà do { guard (n ‚â§ k); o‚ÇÅ } ‚Üí x ‚àà do { guard (n ‚â§ k‚ÇÇ); o‚ÇÇ } :=", "nl_statement": "The theorem `evaln_mono` asserts that if we have two natural numbers `k‚ÇÅ` and `k‚ÇÇ` such that `k‚ÇÅ` is less than or equal to `k‚ÇÇ`, and if a number `x` is in the set of numbers generated by evaluating a certain computation `c` with a limit of `k‚ÇÅ` steps and a parameter `n`, then `x` will also be in the set of numbers generated by evaluating the same computation `c` with a higher limit of `k‚ÇÇ` steps and the same parameter `n`. This theorem essentially states that increasing the step limit for a computation does not lose any results that were obtainable with a smaller step limit."}
{"id": 600, "formal_statement": "theorem dummy (e : Œ≥ ‚âÉ Œ≤) : Summable (f ‚àò e) ‚Üî Summable f :=", "nl_statement": "The statement in question is about the relationship between summability of two functions related by a bijection. Specifically, it asserts that a function \\( f \\) is summable if and only if the function \\( f \\circ e \\), which is the composition of \\( f \\) with a bijection \\( e \\), is summable. Here, \\( \\gamma \\) and \\( \\beta \\) are sets, \\( e: \\gamma \\equiv \\beta \\) is a bijection between these sets, and \\( f \\) is a function from \\( \\beta \\) to some set of summable elements."}
{"id": 601, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) : StrictMono (map f) :=", "nl_statement": "The statement provided describes a theorem in the context of mathematical functions and ordered sets. Specifically, it asserts that if you have a function \\(f\\) from type \\(\\alpha\\) to type \\(\\beta\\), then applying \\(f\\) to the elements of a multiset (a collection of elements that can have duplicates) in a strictly monotone way (meaning that if one element is strictly less than another, then its image under \\(f\\) is also strictly less than the image of the other element) results in a new multiset where the order of elements is preserved according to \\(f\\)."}
{"id": 602, "formal_statement": "theorem dummy (g : G) : Continuous fun h : G => g * h * g‚Åª¬π :=", "nl_statement": "The statement concerns a topological group, which is a mathematical structure that combines the properties of a group with those of a topological space. In this context, the lemma asserts that for any element \\(g\\) in a topological group \\(G\\), the function that takes any element \\(h\\) in \\(G\\) and maps it to \\(g \\cdot h \\cdot g^{-1}\\) is continuous. This function is often referred to as conjugation by \\(g\\), and the lemma essentially states that conjugation by any element in a topological group is a continuous function."}
{"id": 603, "formal_statement": "theorem dummy (k : ‚Ñï) : ((2 : ‚Ñù) * k + 1) / (2 * k + 2) * (œÄ / 2) ‚â§ W k :=", "nl_statement": "The statement provided as a theorem in Lean4 syntax concerns a mathematical inequality related to the Wallis product for œÄ (pi). Specifically, it claims that for any natural number \\(k\\), the expression \\(\\frac{(2k + 1)œÄ}{2(2k + 2)}\\) is less than or equal to \\(W(k)\\), where \\(W(k)\\) represents some function or sequence related to Wallis' formula for œÄ."}
{"id": 604, "formal_statement": "theorem dummy {s : Set Œ±} {a : Œ±} (h : a ‚àà upperBounds s) : sSup s ‚â§ a :=", "nl_statement": "The statement describes a condition involving a set `s` and an element `a` of type `Œ±`. It asserts that if `a` is an upper bound of the set `s`, then the supremum (least upper bound) of `s` is less than or equal to `a`."}
{"id": 605, "formal_statement": "theorem dummy (a : A) : œÉ (star a) = star (œÉ a) :=", "nl_statement": "The statement in question involves a mathematical property related to an operation called \"star\" on some element `a` within a set or structure `A`. This operation, when applied through a function `œÉ`, preserves its structure in such a way that performing the \"star\" operation after applying `œÉ` to `a` yields the same result as applying `œÉ` to `a` after it has undergone the \"star\" operation."}
{"id": 606, "formal_statement": "theorem dummy {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) :=", "nl_statement": "The theorem in question is about self-adjoint elements in a ring \\( R \\). It states that if \\( x \\) and \\( y \\) are self-adjoint elements of \\( R \\), then their sum \\( x + y \\) is also a self-adjoint element. In mathematical terms, given two elements \\( x \\) and \\( y \\) in \\( R \\), if \\( x \\) is self-adjoint (denoted by \\( \\text{IsSelfAdjoint } x \\)) and \\( y \\) is self-adjoint (denoted by \\( \\text{IsSelfAdjoint } y \\)), then \\( x + y \\) is also self-adjoint."}
{"id": 607, "formal_statement": "theorem dummy : H.relindex H = 1 :=", "nl_statement": "The theorem `relindex_self` asserts that the relative index of a subgroup \\(H\\) with respect to itself is \\(1\\). In the context of group theory, the relative index of a subgroup \\(H\\) in itself is a measure of the number of distinct cosets of \\(H\\) in \\(H\\), which intuitively should be \\(1\\) since \\(H\\) is the only coset of itself."}
{"id": 608, "formal_statement": "theorem dummy : M.subsemiringClosure = Subsemiring.closure (M : Set R) :=", "nl_statement": "The statement we're examining asserts that the subsemiring closure of a set \\(M\\) within a ring \\(R\\) is equal to the closure of \\(M\\) treated as a set within the subsemiring. This is a foundational concept in algebra, specifically in the study of subsemirings, which are subsets of a ring that are themselves rings under the same operations. The \"subsemiring closure\" of a set refers to the smallest subsemiring that contains that set, while the \"closure of a set\" in this context refers to the smallest closure under the operations of addition and multiplication that still forms a subsemiring."}
{"id": 609, "formal_statement": "theorem dummy (h : a ‚â§ b) : c \\ b ‚â§ c \\ a :=", "nl_statement": "The theorem named `sdiff_le_sdiff_left` states that if `a` is less than or equal to `b` (`a ‚â§ b`), then the difference of `c` and `b` (`c \\ b`) is less than or equal to the difference of `c` and `a` (`c \\ a`). This concept revolves around the idea of set difference in a mathematical context, though without more context from the Lean4 notation, it's generalized to understanding it as an operation (like subtraction in arithmetic or set difference in set theory) that reflects some form of \"difference\" or \"exclusion.\""}
{"id": 610, "formal_statement": "theorem dummy (a b : Œ±) : toIocMod hp a b ‚àà Set.Ioc a (a + p) :=", "nl_statement": "The statement concerns a theorem involving elements \\(a\\), \\(b\\), and a parameter \\(p\\) within a mathematical setting, possibly related to number theory or algebra. The theorem asserts that for some operation `toIocMod` applied to \\(a\\) and \\(b\\) with parameter \\(p\\), the result is an element of the interval \\( (a, a+p) \\), denoted by `Set.Ioc a (a + p)`. This interval is half-open, meaning it includes \\(a\\) but not \\(a+p\\)."}
{"id": 611, "formal_statement": "theorem dummy (a : ‚Ñ§) : a ‚â° a [ZMOD n] :=", "nl_statement": "The theorem states that for any integer \\(a\\), \\(a\\) is congruent to itself modulo \\(n\\). This is a basic property of modular arithmetic, asserting that every integer is congruent to itself under any modulus."}
{"id": 612, "formal_statement": "theorem dummy : BddBelow s‚Åª¬π ‚Üî BddAbove s :=", "nl_statement": "The theorem states that a set \\(s\\) is bounded below with respect to the inverses of its elements if and only if it is bounded above with respect to the original elements of \\(s\\). This relation is encapsulated within the context of an ordered group, where the inverse operation and the concept of boundedness are well-defined."}
{"id": 613, "formal_statement": "theorem dummy (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=", "nl_statement": "The theorem named `seminorm_one_eq_one_iff_ne_zero` is concerned with a property of a seminorm \\(p\\) applied to the number 1. It states that \\(p(1) = 1\\) if and only if \\(p\\) is not the zero function. This is a significant property because it connects the value of a seminorm at a specific point (in this case, 1) with the general behavior of the seminorm (being non-zero)."}
{"id": 614, "formal_statement": "theorem dummy : Function.Injective ((‚Üë) : (A ‚Üí‚Çê[R] B) ‚Üí A ‚Üí+* B) :=", "nl_statement": "The problem statement asserts that the function which casts an algebra homomorphism (`A ‚Üí‚Çê[R] B`) to a ring homomorphism (`A ‚Üí+* B`) is injective. This means that if two algebra homomorphisms from `A` to `B` over a ring `R` are considered equal when cast to ring homomorphisms, then they were originally equal as algebra homomorphisms."}
{"id": 615, "formal_statement": "theorem dummy (x : Œ≤) (V W : Set (Œ≤ √ó Œ≤)) : ball x (V ‚à© W) ‚äÜ ball x W :=", "nl_statement": "The statement concerns a mathematical property involving the concept of \"balls\" in the context of sets of pairs (Œ≤ √ó Œ≤), where Œ≤ represents a type of elements. Specifically, it states that for any element `x` of type Œ≤ and any two sets `V` and `W` of pairs of type Œ≤, the ball centered at `x` with radius `(V ‚à© W)` (the intersection of V and W) is a subset of the ball centered at `x` with radius `W`."}
{"id": 616, "formal_statement": "theorem dummy (n : ‚Ñï) : (X ^ n).Splits i :=", "nl_statement": "The theorem named `splits_X_pow` is concerning a polynomial, specifically the polynomial \\(X^n\\), where \\(n\\) is a natural number (\\(\\mathbb{N}\\)). The statement asserts that \\(X^n\\) \"splits\" in a particular setting indicated by `i`. The concept of a polynomial \"splitting\" involves the polynomial being expressible as a product of linear factors (polynomials of degree 1) within a certain extension of its coefficient field, often implying that all its roots are contained within that extension."}
{"id": 617, "formal_statement": "theorem dummy : exp x - cosh x = sinh x :=", "nl_statement": "The theorem states that the difference between the exponential function of a variable \\(x\\) (\\(e^x\\)) and the hyperbolic cosine of \\(x\\) (\\(\\cosh(x)\\)) is equal to the hyperbolic sine of \\(x\\) (\\(\\sinh(x)\\))."}
{"id": 618, "formal_statement": "theorem dummy : StrictAntiOn (f ‚àò ofDual) s ‚Üî StrictMonoOn f s :=", "nl_statement": "The statement given is about a relation between two mathematical concepts, strict anti-monotonicity and strict monotonicity, in the context of functions and their composition. Specifically, it asserts that a function \\(f\\) composed with the operation \\(ofDual\\) is strictly anti-monotonic on a set \\(s\\) if and only if \\(f\\) is strictly monotonic on \\(s\\). In simpler terms, it translates to the following natural language statement:\n\n\"Theorem: A function \\(f\\) composed with the operation of taking duals is strictly decreasing on a set \\(s\\) if and only if \\(f\\) is strictly increasing on \\(s\\).\"\n\nHere, \\(ofDual\\) likely refers to an operation that inverts the order of elements, such as taking the negative in the case of real numbers, or more generally, mapping each element to its 'dual' in a way that reverses order."}
{"id": 619, "formal_statement": "theorem dummy : bit1 n % 2 = 1 :=", "nl_statement": "The theorem states that the remainder when any odd number (represented as `bit1 n`, where `n` is any natural number) is divided by 2 is 1."}
{"id": 620, "formal_statement": "theorem dummy {l‚ÇÅ l‚ÇÇ l‚ÇÉ : Lists' Œ± true} (h‚ÇÅ : l‚ÇÅ ‚äÜ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ ‚äÜ l‚ÇÉ) : l‚ÇÅ ‚äÜ l‚ÇÉ :=", "nl_statement": "The statement concerns the transitive property of subsets within a context defined by lists (or some similar structured collection) with elements of an unspecified type `Œ±`. Specifically, it asserts that if list `l‚ÇÅ` is a subset of list `l‚ÇÇ`, and list `l‚ÇÇ` is a subset of list `l‚ÇÉ`, then it logically follows that list `l‚ÇÅ` is a subset of list `l‚ÇÉ`."}
{"id": 621, "formal_statement": "theorem dummy (hs : IsOpen s) : mk ‚Åª¬π' (mk '' s) = s :=", "nl_statement": "The statement to be proven is that the preimage of the image of a set \\(s\\) under a function \\(mk\\) is equal to the set \\(s\\) itself, given that \\(s\\) is an open set. In mathematical terms, this is written as \\(mk^{-1}(mk(s)) = s\\), assuming \\(IsOpen(s)\\) holds true."}
{"id": 622, "formal_statement": "theorem dummy : comap m ‚ä• = ‚ä• :=", "nl_statement": "The theorem states that the preimage of the bottom element (denoted as ‚ä•, representing the smallest or least element in a lattice, often used to signify the empty set in the context of filters) under a map \\(m\\) is equal to the bottom element itself. In other words, when you apply a function \\(m\\) to map elements from one set to another, taking the preimage of the empty set results in the empty set."}
{"id": 623, "formal_statement": "theorem dummy : Ico (‚ä• : WithBot Œ±) b = insertNone (Iio b) :=", "nl_statement": "The theorem named `Ico_bot_coe` is about intervals in a particular context involving the WithBot type constructor in Lean4. The WithBot type adds a 'bottom' element, denoted as `‚ä•`, to an existing type Œ±. This bottom element typically represents something like a \"minimal\" or \"undefined\" value. The theorem states that the interval `Ico (‚ä• : WithBot Œ±) b` is equal to the set obtained by inserting 'None' (a representation of the bottom element) into the interval `Iio b`, where `Ico` is an interval that includes its lower bound but not the upper bound, and `Iio` is an interval that does not include its upper bound."}
{"id": 624, "formal_statement": "theorem dummy (x : p) : ((-x : p) : M) = -x :=", "nl_statement": "The theorem states that for a given element \\(x\\) of type \\(p\\), when we negate \\(x\\) and view the result as an element of type \\(M\\), this is equivalent to directly negating \\(x\\) within type \\(M\\)."}
{"id": 625, "formal_statement": "theorem dummy : StrictMono (f ‚àò ofDual) ‚Üî StrictAnti f :=", "nl_statement": "The theorem `strictMono_comp_ofDual_iff` can be translated to the following natural language statement:\n\n\"The composition of a function `f` with the `ofDual` function is strictly monotonic if and only if `f` is strictly antitonic.\"\n\nIn simpler terms, this theorem is about understanding the relationship between two properties of functions. A function is \"strictly monotonic\" if it preserves the order strictly (i.e., if `a < b`, then `f(a) < f(b)` for all `a` and `b`), and it's \"strictly antitonic\" if it reverses the order strictly (i.e., if `a < b`, then `f(a) > f(b)` for all `a` and `b`). The `ofDual` function is a bit more specific and requires understanding the context in which it's defined, but generally, it involves some form of inversion or duality principle.\n\nTranslating this into a natural language explanation would require inferring a bit about the content of the proof since the actual logical steps aren't detailed here. Generally, a proof of an \"if and only if\" statement involves proving two directions:\n\n1. **First Direction (‚áí):** If the composition `f ‚àò ofDual` is strictly monotonic, then `f` must be strictly antitonic. This would involve showing that the strict increase (or decrease, depending on the exact nature of `ofDual`) in the outputs of the composition implies a strict decrease in the outputs of `f` when its inputs are ordered.\n\n2. **Second Direction (‚áê):** If `f` is strictly antitonic, then the composition `f ‚àò ofDual` is strictly monotonic. Here, one would demonstrate that reversing the order of inputs by `f` (due to it being strictly antitonic) is somehow corrected or maintained by the composition with `ofDual`, resulting in a strict monotonic behavior.\n\nThe `forall_swap` hint suggests that the proof might involve swapping the order of quantifiers or elements to facilitate the demonstration of these properties, highlighting the symmetric nature of the \"if and only if\" relationship in this context.\n\nWithout more specific details on the functions and the logical steps taken in the proof, this is as close to a translation and explanation as we can get based on the information provided.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 626, "formal_statement": "theorem dummy (h : ‚àÉ x : V, ‚Äñx‚Äñ ‚â† 0) : ‚Äñid V‚Äñ = 1 := le_antisymm (norm_id_le V) <| by let ‚ü®x, hx‚ü© := h have :=", "nl_statement": "The statement concerns the norm of the identity function in a vector space \\(V\\) equipped with a seminorm. Specifically, it asserts that if there exists a non-zero vector \\(x\\) in \\(V\\) such that its norm is not zero (\\(\\exists x : V, \\|x\\| \\neq 0\\)), then the norm of the identity function on \\(V\\) is equal to 1 (\\(\\|id V\\| = 1\\))."}
{"id": 627, "formal_statement": "theorem dummy : QuasiMeasurePreserving Prod.fst (Œº.prod ŒΩ) Œº :=", "nl_statement": "The problem states that the function `Prod.fst`, which takes a product of two elements and returns the first element, is \"quasi measure preserving\" from the product measure `(Œº.prod ŒΩ)` to the measure `Œº`. In measure theory, a function is considered quasi measure preserving if it is measurable and if the pre-image of any set of measure zero also has a measure zero in the source space, with respect to the specified measures."}
{"id": 628, "formal_statement": "theorem dummy : StrictConvex ùïú (‚àÖ : Set E) :=", "nl_statement": "Strict Convexity of an Empty Set\n\nThe theorem states that an empty set is strictly convex in a vector space over a field ùïú.\n\nIn mathematical terms, a set \\(S\\) in a vector space is strictly convex if, for any two distinct points \\(x\\) and \\(y\\) in \\(S\\), and for any \\(t\\) in the open interval (0, 1), the point \\(tx + (1-t)y\\) is in the interior of \\(S\\). The concept of strict convexity is important in optimization and analysis, as it ensures uniqueness of solutions to optimization problems and has implications for the behavior of functions on the set."}
{"id": 629, "formal_statement": "theorem dummy (D1 D2 : Derivation R A M) : ‚áë(D1 + D2) = D1 + D2 :=", "nl_statement": "The statement is about a property involving the sum of two derivations, where `D1` and `D2` are derivations in some context related to rings (`R`), algebra (`A`), and modules (`M`). Specifically, it asserts that applying the sum of `D1` and `D2` directly is equivalent to adding `D1` and `D2` first and then applying the result.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 630, "formal_statement": "theorem dummy : a ‚â† ‚àû ‚Üí b + a ‚â§ c + a ‚Üí b ‚â§ c :=", "nl_statement": "The theorem states that if the sum of `b` and `a` is less than or equal to the sum of `c` and `a`, and `a` is not infinity, then `b` is less than or equal to `c`. This theorem operates within a context where the values can include extended real numbers, which is why the condition that `a` is not infinity is significant. Extended real numbers include all real numbers plus two symbolic values: positive infinity (‚àû) and negative infinity (-‚àû)."}
{"id": 631, "formal_statement": "theorem dummy (n : ‚Ñ§) : ‚àÄ a ‚àà Set.Ico (n : Œ±) (n + 1), (‚åäa‚åã : Œ±) = n :=", "nl_statement": "The given statement is a theorem about the mathematical floor function. Specifically, it states that for any integer \\(n\\) and for any real number \\(a\\) that is in the half-open interval from \\(n\\) to \\(n + 1\\), not including \\(n + 1\\) itself, the floor of \\(a\\) (denoted as \\(‚åäa‚åã\\)) is equal to \\(n\\)."}
{"id": 632, "formal_statement": "theorem dummy (f g : M ‚ÜíSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) : ‚áë(f - g) = f - g :=", "nl_statement": "The statement given is a theorem concerning continuous linear maps between two modules, denoted as `M` and `M‚ÇÇ`, over a common scalar field. It asserts that the operation of taking the difference (subtraction) of two such maps, when applied to an element, is equivalent to subtracting the results of each map applied individually to that element."}
{"id": 633, "formal_statement": "theorem dummy {s : Set Œ±} : s.Subsingleton ‚Üí Subsingleton s :=", "nl_statement": "The statement concerns a concept in mathematics related to the notion of a \"subsingleton\" within the context of set theory. A subsingleton, in this scenario, refers to a set that contains at most one element. The theorem posits that if a set `s` is a subsingleton, then the type (or sort) associated with that set is also a subsingleton. This concept ties the property of being a subsingleton to both the set itself and to the type derived from the set."}
{"id": 634, "formal_statement": "theorem dummy (e : M‚ÇÅ ‚âÉSL[œÉ‚ÇÅ‚ÇÇ] M‚ÇÇ) (x y : M‚ÇÅ) : e (x + y) = e x + e y :=", "nl_statement": "The theorem states that for a continuous linear equivalence `e` between two modules `M‚ÇÅ` and `M‚ÇÇ` over a semiring, with a linear map respecting a certain structure denoted by `œÉ‚ÇÅ‚ÇÇ`, the image of the sum of two elements `x` and `y` from `M‚ÇÅ` under `e` is equal to the sum of the images of `x` and `y` under `e`. In simpler terms, applying the equivalence `e` to the sum of two elements is the same as summing the images of the elements under `e`."}
{"id": 635, "formal_statement": "theorem dummy (h : IsComplement' H K) : Disjoint H K :=", "nl_statement": "The theorem in question asserts that if two subgroups, \\(H\\) and \\(K\\), are complements of each other in a specific sense (denoted by `IsComplement'`), then \\(H\\) and \\(K\\) are disjoint. This means that the only element they share is the identity element of the group they are part of."}
{"id": 636, "formal_statement": "theorem dummy {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=", "nl_statement": "The theorem states that for any nonzero rational number \\(q\\), the constant sequence defined by the \\(p\\)-adic norm of \\(q\\) is not equivalent to the zero sequence in the context of \\(p\\)-adic sequences."}
{"id": 637, "formal_statement": "theorem dummy {n m : ‚Ñï} : n % 2 = 1 ‚Üí m % 2 = 1 ‚Üí n * m % 2 = 1 :=", "nl_statement": "The statement asserts that if you multiply two odd numbers together, the result will also be odd. In more formal mathematical terms, given two natural numbers \\(n\\) and \\(m\\), if \\(n\\) modulo 2 equals 1 (which means \\(n\\) is odd) and \\(m\\) modulo 2 equals 1 (which means \\(m\\) is odd), then the product \\(n \\times m\\) modulo 2 will also equal 1, confirming that the product is odd as well."}
{"id": 638, "formal_statement": "theorem dummy : ‚áë(punitProd Œ±) = Prod.snd :=", "nl_statement": "The theorem named `coe_punitProd` states that the coercion function of `punitProd Œ±` is equal to the `Prod.snd` function. In more understandable terms, this theorem is about a specific type of function related to product types in the context of type theory and functional programming. Specifically, `punitProd Œ±` refers to a function that, given a type `Œ±`, produces a product type where the first component is a `punit` (a type with exactly one value, often used to signify \"unit\" in programming) and the second component is of type `Œ±`. The theorem asserts that when this product type is coerced (or converted) into a function, that function is equivalent to taking the second component of a pair (which is what `Prod.snd` does)."}
{"id": 639, "formal_statement": "theorem dummy {z : ‚Ñ§} (h‚ÇÄ : z ‚â† 0) : 1 ‚â§ |z| :=", "nl_statement": "The theorem states that for any integer \\(z\\) that is not zero, the absolute value of \\(z\\) is greater than or equal to 1."}
{"id": 640, "formal_statement": "theorem dummy (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 :=", "nl_statement": "The statement to be proven is that the logarithm of x is non-positive (less than or equal to zero) if and only if x is less than or equal to 1, given that x is a non-negative number (greater than or equal to zero)."}
{"id": 641, "formal_statement": "theorem dummy (a b : Œ±) : toIcoDiv hp a b = ‚åä(b - a) / p‚åã :=", "nl_statement": "The theorem `toIcoDiv_eq_floor` asserts that for any two given numbers `a` and `b` (with `a` less than `b`), and a positive number `p`, the function `toIcoDiv` applied to `a` and `b` is equal to the floor of the division of `b - a` by `p`. In mathematical terms, this can be interpreted as dividing the interval from `a` to `b` into segments of length `p` and then counting how many such full segments fit into this interval, disregarding any partial segment at the end."}
{"id": 642, "formal_statement": "theorem dummy {f g : A ‚Üí+[M] B} (h : (f : A ‚Üí+ B) = (g : A ‚Üí+ B)) : f = g :=", "nl_statement": "The statement given is about the injectivity of a function transformation in a mathematical structure, specifically within the context of homomorphisms. In simpler terms, it states that if two additive monoid homomorphisms (functions that preserve the additive structure from one algebraic structure, A, to another, B) are equivalent when viewed as mere functions (ignoring the additional structure they carry), then they are indeed the same homomorphism."}
{"id": 643, "formal_statement": "theorem dummy : (Measure.pi Œº).ae ‚â§ Filter.pi fun i => (Œº i).ae :=", "nl_statement": "The theorem named `ae_pi_le_pi` states that for a product measure \\( \\mu \\) defined on a finite or countably infinite product of measure spaces, the almost everywhere filter associated with the product measure is less than or equal to the product of the almost everywhere filters associated with each of the individual measures. \n\nIn simpler terms, if you have a set of measure spaces and you take the product measure (a way of combining these measures for the combined space), then the set of properties that hold \"almost everywhere\" (true everywhere except on a set of measure zero) for this combined measure is less restrictive than or equal to those that hold \"almost everywhere\" for each of the component measures individually. \"Almost everywhere\" is a concept in measure theory that allows for exceptions within a set of measure zero, acknowledging that these exceptions do not affect the outcome of integration and other measure-theoretic operations."}
{"id": 644, "formal_statement": "theorem dummy (C : Type u) [Groupoid C] : (of C : Type u) = C :=", "nl_statement": "The statement to be translated is about a concept from category theory, specifically within the context of groupoids. The theorem states that the coercive (implicit conversion) operation of a type `C`, when `C` is considered within a structure called a `Groupoid`, results in the same type `C`. This is a formal way to express that the type-level representation of a groupoid, when explicitly coerced to a type, remains unchanged."}
{"id": 645, "formal_statement": "theorem dummy {X : C} (Y : Subobject X) : Simple (Y : C) ‚Üî IsAtom Y :=", "nl_statement": "The statement concerns the relationship between the concepts of simplicity in a category and atomicity of subobjects within that category, specifically for a given object \\(X\\) and its subobject \\(Y\\). It claims that a subobject \\(Y\\) of \\(X\\) is simple in the categorical sense if and only if it is an atom in the context of subobject hierarchy."}
{"id": 646, "formal_statement": "theorem dummy (h3 : 3 ‚â§ card Œ±) : Nontrivial (alternatingGroup Œ±) :=", "nl_statement": "The problem statement asserts that if a set Œ± has a cardinality (size) of 3 or more, then the alternating group formed with the elements of Œ± is nontrivial. This means there are elements in the alternating group that do not act as the identity permutation."}
{"id": 647, "formal_statement": "theorem dummy {r : R} {a : A} : r ‚àâ œÉ a ‚Üî IsUnit (‚Üë‚Çê r - a) :=", "nl_statement": "The theorem states a condition about an element `r` from a ring `R` and an element `a` from a set `A`. It claims that `r` is not an element of a certain set `œÉ(a)` if and only if the element `r` subtracted by `a` (denoted as `‚Üë‚Çê r - a`) is a unit. In mathematical terms, a unit is an element that has a multiplicative inverse within the same set or structure."}
{"id": 648, "formal_statement": "theorem dummy (S : AddSubgroup M) : Function.Surjective (normedMk S) :=", "nl_statement": "The statement is about the concept of surjectivity in the context of a normed group. Specifically, it claims that the function `normedMk`, when applied to a subgroup `S` of a group `M`, is surjective. Surjectivity here means that for every element in the target space (the quotient group formed by `M` modulo `S`), there is at least one element in the domain (the group `M`) that maps to it through the `normedMk` function."}
{"id": 649, "formal_statement": "theorem dummy (u v : Œ±) (s : Finset Œ±) : (ùìí u v s).card = s.card :=", "nl_statement": "The statement concerns a mathematical object, specifically a `Finset` (a finite set) of elements of some type `Œ±`. It introduces a function `ùìí u v s` which represents the operation of \"compression\" on the finite set `s`, with respect to two elements `u` and `v` of the same type `Œ±`. The theorem, `card_compression`, claims that the cardinality (the number of elements) of the compressed set `ùìí u v s` is equal to the cardinality of the original set `s`."}
{"id": 650, "formal_statement": "theorem dummy {a b c : ‚Ñ§} : Fermat42 a b c ‚Üî Fermat42 b a c :=", "nl_statement": "The statement concerns a property of a mathematical statement referred to as `Fermat42`, involving three integer variables `a`, `b`, and `c`. The property in question is the commutativity of the first two variables in the `Fermat42` statement, suggesting that swapping `a` and `b` does not change the truth of the `Fermat42` statement about `a`, `b`, and `c`."}
{"id": 651, "formal_statement": "theorem dummy (x : Œ±) : scanl f b (x ::·µ• v) = b ::·µ• scanl f (f b x) v :=", "nl_statement": "The statement concerns the function `scanl`, which is a function that applies a binary function `f` to an accumulator `b` and each element of a vector `(x ::·µ• v)`, sequentially. The vector notation `x ::·µ• v` denotes a vector that results from prepending an element `x` to the front of vector `v`. The theorem `scanl_cons` asserts that when you apply `scanl` to a binary function `f`, an initial accumulator value `b`, and a vector created by prepending `x` to `v`, the result is a new vector starting with `b`, followed by the result of applying `scanl` to `f`, the result of applying `f` to `b` and `x` (i.e., `f b x`), and the rest of the original vector `v`."}
{"id": 652, "formal_statement": "theorem dummy (f : Œ≤ ‚Üí Œ± ‚Üí Œ≤) (H b) : foldl f H b 0 = b :=", "nl_statement": "The theorem `foldl_zero` concerns the behavior of a fold operation, specifically `foldl`, when applied to an empty collection (denoted by `0` in this context, which typically represents the empty list or multiset in functional programming languages). The theorem states that if you perform a fold operation with a function `f` of type `Œ≤ ‚Üí Œ± ‚Üí Œ≤` (which takes an accumulator of type `Œ≤` and an element of type `Œ±` and returns a new accumulator of type `Œ≤`), starting with an initial accumulator value `b`, over an empty collection, then the result of this operation is simply the initial accumulator value `b`."}
{"id": 653, "formal_statement": "theorem dummy {f : A ‚Üí+* B} {g : B ‚Üí+* C} (h : (g.comp f).Finite) : g.Finite :=", "nl_statement": "Given three rings \\(A\\), \\(B\\), and \\(C\\), and two ring homomorphisms \\(f: A \\rightarrow B\\) and \\(g: B \\rightarrow C\\), if the composition of \\(g\\) and \\(f\\) (denoted as \\(g \\circ f\\)) is finite, then \\(g\\) is finite."}
{"id": 654, "formal_statement": "theorem dummy (u a : Œ±) : compress u u a = a :=", "nl_statement": "The statement given as `theorem compress_self (u a : Œ±) : compress u u a = a` is about a function named `compress`. This theorem states that when the `compress` function is called with the first two arguments being the same entity (denoted by `u`) and the third argument as any entity `a`, the result of this function will be the same entity `a`. In other words, applying the `compress` function on any element `a` with the same 'compression parameters' `u` does not change the element."}
{"id": 655, "formal_statement": "theorem dummy {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=", "nl_statement": "The problem states a theorem regarding elements and their relation within a set and its complement in the context of a partially ordered set (P). Specifically, the theorem involves two elements, x and y, of a partially ordered set P, an ideal I of P, and it relates the ordering of x and y (x ‚â§ y) to their membership in the complement of I (denoted as I·∂ú).\n\nThe theorem can be expressed as follows: Given two elements x and y in a partially ordered set P, if x is less than or equal to y (x ‚â§ y) and x is not in the ideal I (x ‚àà I·∂ú), then y is also not in the ideal I (y ‚àà I·∂ú)."}
{"id": 656, "formal_statement": "theorem dummy {u : V} : (nil : G.Walk u u).IsPath :=", "nl_statement": "The theorem stated in Lean4 syntax asserts the existence of a specific kind of path, namely a \"nil\" path, within a graph structure. This path is from a vertex \\(u\\) to itself in the graph \\(G\\). In essence, the theorem is saying that a path that starts and ends at the same vertex \\(u\\), and contains no edges, is considered a valid path according to a certain definition of paths in the graph \\(G\\)."}
{"id": 657, "formal_statement": "theorem dummy (r : R) : algebraMap R A r ‚àà Set.center A :=", "nl_statement": "The statement concerns an algebraic structure where \\(A\\) is a set with algebraic operations (like addition and multiplication) defined on it, and \\(R\\) is a ring. The theorem claims that for any element \\(r\\) from the ring \\(R\\), when \\(r\\) is mapped into \\(A\\) through a function called the algebra map (denoted as `algebraMap R A r`), the result is an element of the set called the center of \\(A\\). The center of \\(A\\) is defined as the set of all elements in \\(A\\) that commute with every other element in \\(A\\); that is, for any element \\(x\\) in the center and any element \\(y\\) in \\(A\\), \\(xy = yx\\)."}
{"id": 658, "formal_statement": "theorem dummy (u : ‚Ñï ‚Üí Œ±) : (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü i, u i := calc (u 0 ‚äî ‚®Ü i, u (i + 1)) = ‚®Ü x ‚àà {0} ‚à™ range Nat.succ, u x :=", "nl_statement": "The statement in question expresses a property related to supremum operations over a sequence of elements indexed by natural numbers in some partially ordered set (denoted by `Œ±`). It asserts that the supremum (least upper bound) of the union of the first element of a sequence `u` (denoted as `u 0`) and the supremum of the rest of the elements in the sequence (starting from the second element, denoted as `‚®Ü i, u (i + 1)`) is equal to the supremum of the entire sequence (denoted as `‚®Ü i, u i`)."}
{"id": 659, "formal_statement": "theorem dummy (n x y : ‚Ñ§) : sqrtd * (n : ‚Ñ§‚àöd) * ‚ü®x, y‚ü© = ‚ü®d * n * y, n * x‚ü© :=", "nl_statement": "The theorem `smuld_val` deals with the multiplication of a specific type of integer tuple by an integer `n` in a domain related to the square root of an integer `d` (notated as ‚Ñ§‚àöd). The statement can be interpreted as follows: When you multiply the square root of `d` (sqrtd) by an integer `n`, and then by a tuple represented by ‚ü®x, y‚ü© (which can be thought of as a complex number where `x` is the real part and `y` is the imaginary part, with the imaginary unit being the square root of `d`), the result is a new tuple ‚ü®d * n * y, n * x‚ü©.\n\nIn simpler terms, this theorem states how a complex number (in this special domain related to the square root of `d`) is transformed when multiplied by the square root of `d` and an integer `n`."}
{"id": 660, "formal_statement": "theorem dummy (d : Disjoint l‚ÇÅ l‚ÇÇ) : Disjoint l‚ÇÇ l‚ÇÅ :=", "nl_statement": "Given two lists `l‚ÇÅ` and `l‚ÇÇ`, if `l‚ÇÅ` is disjoint from `l‚ÇÇ` (meaning there are no elements common to both `l‚ÇÅ` and `l‚ÇÇ`), then `l‚ÇÇ` is also disjoint from `l‚ÇÅ`."}
{"id": 661, "formal_statement": "theorem dummy (n) : succ' (pred' n) = n :=", "nl_statement": "The statement is about the functions `succ'` and `pred'`, which likely stand for the successor and predecessor functions, respectively. The theorem `succ'_pred'` claims that for any number `n`, applying the successor function to the predecessor of `n` yields `n` itself.\n\nThe essence of the proof lies in demonstrating the reversibility of the successor and predecessor operations for natural numbers, ensuring that applying these operations in sequence (pred' followed by succ') on any number returns the original number, under the condition that these operations are defined (i.e., the number is within the domain where pred' and succ' make sense).\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 662, "formal_statement": "theorem dummy (f : C(Œ±, Œ≤)) {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < f.modulus Œµ h :=", "nl_statement": "The theorem named `modulus_pos` is concerned with a continuous function `f` that maps from one topological space `Œ±` to another `Œ≤`. It states that for any positive real number `Œµ` (denoted as `{Œµ : ‚Ñù}` where `0 < Œµ`), there exists a positive modulus of continuity for the function `f`. In simpler terms, it's saying that if you pick any small positive distance `Œµ`, you can find a small enough distance around any point in the domain of `f`, such that `f` doesn't change by more than `Œµ` within that small distance. This is a way to formally define what it means for a function to be continuous in a mathematical sense."}
{"id": 663, "formal_statement": "theorem dummy (h : coeff p n ‚â† 0) : (n : WithBot ‚Ñï) ‚â§ degree p :=", "nl_statement": "The statement concerns a polynomial `p` and a natural number `n`. It asserts that if the coefficient of the term of degree `n` in `p` is not zero, then `n` (when considered as an element of `WithBot ‚Ñï`, which extends the natural numbers with a bottom element representing \"minus infinity\") is less than or equal to the degree of the polynomial `p`."}
{"id": 664, "formal_statement": "theorem dummy : Continuous (infDist ¬∑ s) :=", "nl_statement": "The statement concerns a mathematical property of a function, specifically about continuity. The function in question is `infDist ¬∑ s`, where `infDist` refers to the infimum distance (the greatest lower bound of distances) from a point to a set `s` in a metric space. The theorem `continuous_infDist_pt` asserts that the function mapping any point to the infimum distance from that point to the set `s` is continuous."}
{"id": 665, "formal_statement": "theorem dummy (l : Language Œ±) : 1 + l * l‚àó = l‚àó :=", "nl_statement": "The theorem states that for any language `l`, the expression `1 + l * l*` is equal to `l*`, where `1` represents the empty language (i.e., a language containing only the empty string), `l` is any given language, and `l*` denotes the Kleene star of `l`, which is the set of all strings that can be composed by concatenating zero or more strings from `l`."}
{"id": 666, "formal_statement": "theorem dummy (D1 D2 : Derivation R A M) : ‚Üë(D1 + D2) = (D1 + D2 : A ‚Üí‚Çó[R] M) :=", "nl_statement": "The statement provided is a theorem regarding derivations in the context of a mathematical structure, involving rings and modules. Specifically, it states that the coercion of the sum of two derivations, `D1` and `D2`, to a linear map is equal to the sum of `D1` and `D2` when considered as a linear map from `A` to `M` over a ring `R`."}
{"id": 667, "formal_statement": "theorem dummy (f : Lp ‚Ñù p Œº) : ‚áë(posPart f) =·µê[Œº] fun a => max (f a) 0 :=", "nl_statement": "The theorem states that for any function `f` belonging to the space `Lp` over the real numbers `‚Ñù` with a norm `p` and measured by `Œº`, the almost everywhere (a.e.) application of the positive part function to `f` is equal to the function that takes any argument `a` and returns the maximum between `f(a)` and 0. In simpler terms, if you apply the positive part operation to any `Lp` function, the result, almost everywhere, is a function that outputs either the original value if it's positive or zero if the original value is negative."}
{"id": 668, "formal_statement": "theorem dummy (p : R[X]) (ha : a ‚â† 0) : (C a * p).roots = p.roots :=", "nl_statement": "The theorem states that for any polynomial \\( p \\) with coefficients in the real numbers \\( R \\), if \\( a \\) is a non-zero real number, then the roots of the polynomial \\( C a * p \\) (where \\( C a \\) represents the constant polynomial with value \\( a \\)) are the same as the roots of the polynomial \\( p \\)."}
{"id": 669, "formal_statement": "theorem dummy (n : ‚Ñï) : cos (n * (2 * œÄ) + œÄ) = -1 :=", "nl_statement": "The statement to be proven is: For any natural number \\(n\\), the cosine of \\(n\\) times \\(2\\pi\\) plus \\(\\pi\\) equals \\(-1\\)."}
{"id": 670, "formal_statement": "theorem dummy : Ico a b ‚äÜ Icc a b :=", "nl_statement": "The theorem `Ico_subset_Icc_self` states that the half-open interval `[a, b)` is a subset of the closed interval `[a, b]`."}
{"id": 671, "formal_statement": "theorem dummy {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=", "nl_statement": "The theorem concerns a category theory concept within the context of functors between categories. Specifically, it states that for any two objects \\(X\\) and \\(Y\\) in a category \\(C\\), a morphism \\(f\\) from \\(X\\) to \\(Y\\), and a natural number \\(n\\), the functor \\(F\\) maps the \\(n\\)-fold scalar multiplication of \\(f\\) (denoted as \\(n \\cdot f\\)) to the \\(n\\)-fold scalar multiplication of the mapped morphism \\(F.map(f)\\). In simpler terms, applying the functor \\(F\\) to \\(n\\) times the morphism \\(f\\) is the same as multiplying the functor-applied morphism \\(F.map(f)\\) by \\(n\\)."}
{"id": 672, "formal_statement": "theorem dummy (F : J ‚•§ C) [HasLimit F.op] : HasColimit F := HasColimit.mk { cocone := (limit.cone F.op).unop isColimit :=", "nl_statement": "The statement we're considering is about the relationship between limits and colimits in a category \\(C\\) under the presence of a functor \\(F\\) from an index category \\(J\\) to \\(C\\). Specifically, it asserts that if the functor \\(F\\) has a limit when considered as a contravariant functor (denoted \\(F.op\\)), then \\(F\\) itself must have a colimit."}
{"id": 673, "formal_statement": "theorem dummy {k : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=", "nl_statement": "The given statement is a theorem concerning the \"big O\" notation, which is a formal way to describe the asymptotic behavior of functions. The theorem states that for any two functions \\(f\\) and \\(g\\), a mapping function \\(k\\), and a filter \\(l\\), the function \\(f\\) is in big O of \\(g\\) under the transformation of \\(l\\) by \\(k\\) if and only if the composition of \\(f\\) with \\(k\\) is in big O of the composition of \\(g\\) with \\(k\\) under the filter \\(l\\).\n\nThis can be expressed as: \\(f = O_{\\text{map } k \\, l}(g) \\leftrightarrow (f \\circ k) = O_l (g \\circ k)\\)."}
{"id": 674, "formal_statement": "theorem dummy (h : RightInvOn f' f t) : EqOn (f ‚àò f') id t :=", "nl_statement": "The statement involves a mathematical theorem regarding functions and sets. It states that if there is a right inverse function `f'` for a function `f` on a set `t`, then the composition of `f` and `f'` is equivalent to the identity function on the set `t`. In simpler terms, applying `f'` and then `f` to any element in the set `t` results in the original element."}
{"id": 675, "formal_statement": "theorem dummy : Continuous abs :=", "nl_statement": "The statement to prove is that the absolute value function is continuous."}
{"id": 676, "formal_statement": "theorem dummy : Nat.card Œ± = 1 ‚Üî Subsingleton Œ± ‚àß Nonempty Œ± :=", "nl_statement": "The theorem `card_eq_one_iff_unique` states a condition about the cardinality (or the number of elements) of a type `Œ±` in the context of natural numbers (`Nat`). Specifically, it asserts that the cardinality of `Œ±` equals 1 if and only if two conditions are met: `Œ±` is a subsingleton, and `Œ±` is nonempty.\n\n- Being a **subsingleton** means that there is at most one element of that type; any two elements of that type must be identical.\n- Being **nonempty** means that there exists at least one element of that type.\n\nIn simpler terms, the theorem is saying that for any type `Œ±`, it has exactly one element if and only if it is both a subsingleton and nonempty."}
{"id": 677, "formal_statement": "theorem dummy (hs : IsLowerSet s) : s.Nonempty ‚Üí ¬¨BddBelow s :=", "nl_statement": "The statement concerns a property of a set `s` that is a \"lower set\" in the context of order theory. A set `s` is a lower set if, for any element `x` in `s`, all elements less than `x` are also in `s`. The theorem claims that if `s` is a nonempty lower set, then `s` cannot be bounded below. In other words, there is no element `b` such that every element of `s` is greater than or equal to `b`."}
{"id": 678, "formal_statement": "theorem dummy : x ‚àà p ‚äî p' ‚Üî ‚àÉ y ‚àà p, ‚àÉ z ‚àà p', y + z = x :=", "nl_statement": "The theorem `mem_sup` is concerning the elements of the sum of two mathematical objects (typically, submodules, groups, or vector spaces) denoted by `p` and `p'`. It states that an element `x` belongs to the sum (`‚äî`) of `p` and `p'` if and only if there exists an element `y` in `p` and another element `z` in `p'` such that `y + z = x`."}
{"id": 679, "formal_statement": "theorem dummy : a ‚à£ b ‚Üî ‚àÉ c, b = c * a :=", "nl_statement": "The theorem `dvd_iff_exists_eq_mul_left` states that a number \\(a\\) divides another number \\(b\\) if and only if there exists some number \\(c\\) such that \\(b\\) equals \\(c\\) multiplied by \\(a\\)."}
{"id": 680, "formal_statement": "theorem dummy (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=", "nl_statement": "The statement we're looking at is about the order of an element \\(x\\) in a group under multiplication. Specifically, it says that if \\(x\\) raised to the power of \\(p\\) equals 1, and \\(x\\) is not equal to 1 itself, then the order of \\(x\\) is \\(p\\). The order of an element \\(x\\) in this context refers to the smallest positive integer \\(p\\) such that \\(x^p = 1\\), where 1 represents the identity element of the group."}
{"id": 681, "formal_statement": "theorem dummy (I J : HomogeneousIdeal ùíú) : (I ‚äî J).toIdeal = I.toIdeal ‚äî J.toIdeal :=", "nl_statement": "The theorem named `toIdeal_sup` concerns the operation of taking the supremum (or least upper bound) of two homogeneous ideals, `I` and `J`, within a certain algebraic structure `ùíú`. Specifically, it states that when you take the supremum of these two ideals in the context of the homogeneous ideal structure and then convert it to a regular ideal, this is equivalent to converting each homogeneous ideal to a regular ideal first and then taking their supremum in the context of regular ideals."}
{"id": 682, "formal_statement": "theorem dummy {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=", "nl_statement": "The theorem named `ennreal_mass` concerns a finite measure `\\mu` over a space `Œ©`. It states that the total mass of `\\mu` when considered as an extended non-negative real number (notated as `‚Ñù‚â•0‚àû`) is equal to the measure of the entire space `Œ©` (`univ` stands for the universal set, meaning the whole space in this context)."}
{"id": 683, "formal_statement": "theorem dummy {s t : Submonoid N} {x : N} : x ‚àà s ‚äî t ‚Üî ‚àÉ y ‚àà s, ‚àÉ z ‚àà t, y * z = x :=", "nl_statement": "The statement concerns the membership of an element \\(x\\) in the supremum (least upper bound) of two submonoids \\(s\\) and \\(t\\) of a monoid \\(N\\). Specifically, it asserts that \\(x\\) belongs to the supremum of \\(s\\) and \\(t\\) if and only if there exist elements \\(y\\) in \\(s\\) and \\(z\\) in \\(t\\) such that \\(y\\) multiplied by \\(z\\) equals \\(x\\)."}
{"id": 684, "formal_statement": "theorem dummy : x \\ y ‚äì y \\ x = ‚ä• := Eq.symm <| calc ‚ä• = x ‚äì y ‚äì x \\ y :=", "nl_statement": "The theorem stated is about the symmetric difference and intersection of two sets, \\(x\\) and \\(y\\), and it claims that the intersection of the set difference of \\(x\\) and \\(y\\) with the set difference of \\(y\\) and \\(x\\) is the empty set. Symbolically, this can be written as \\((x \\setminus y) \\cap (y \\setminus x) = \\emptyset\\)."}
{"id": 685, "formal_statement": "theorem dummy (x : M) : x ‚àà torsion R M ‚Üî ‚àÉ a : R‚Å∞, a ‚Ä¢ x = 0 :=", "nl_statement": "The theorem named `mem_torsion_iff` concerns an element \\(x\\) of a module \\(M\\) over a ring \\(R\\). It states that \\(x\\) belongs to the torsion submodule of \\(M\\) if and only if there exists a nonzero element \\(a\\) in \\(R\\) such that \\(a\\) times \\(x\\) equals zero."}
{"id": 686, "formal_statement": "theorem dummy [SupSet Œ±] [SupSet Œ≤] (s : Set (Œ± √ó Œ≤)) : (sSup s).swap = sSup (Prod.swap '' s) :=", "nl_statement": "The statement concerns a property of sets in a mathematical structure that supports the notion of supremum (`SupSet`) for two types, Œ± and Œ≤. It states that if you have a set `s` consisting of pairs from Œ± √ó Œ≤, then swapping the elements of each pair in the supremum of `s` (denoted as `sSup s`) results in the same set as if you took the supremum of `s` after swapping the elements of each pair in `s` first. This operation of swapping elements in each pair can be seen as applying a function `Prod.swap` to each element of `s`, where `Prod.swap` is a function that takes a pair and returns a pair with its elements reversed."}
{"id": 687, "formal_statement": "theorem dummy (a : Œ±) (n : ‚Ñ§) : (1 / a) ^ n = 1 / a ^ n :=", "nl_statement": "The theorem states that for any number \\(a\\) (except when \\(a = 0\\) to avoid division by zero) and any integer \\(n\\), the \\(n\\)th power of the inverse of \\(a\\) is equal to the inverse of the \\(n\\)th power of \\(a\\). In other words, if you take the reciprocal of \\(a\\) and then raise it to the power of \\(n\\), this is the same as raising \\(a\\) to the power of \\(n\\) and then taking the reciprocal of the result."}
{"id": 688, "formal_statement": "theorem dummy (s : Set Œ±) : ‚Üë(upperClosure s) = ‚ãÉ a ‚àà s, Ici a :=", "nl_statement": "The theorem states that the upper closure of a set \\( s \\) is equal to the union of the intervals \\( [a, \\infty) \\) for each element \\( a \\) in \\( s \\)."}
{"id": 689, "formal_statement": "theorem dummy (i : œÉ) : (X i : MvPolynomial œÉ R) /·µê·µí‚Åø·µí·µê‚Å±·µÉÀ° Finsupp.single i 1 = 1 :=", "nl_statement": "The theorem named `X_divMonomial` involves division of a monomial by another monomial within the context of multivariate polynomials over some ring \\(R\\) and indexed by \\(\\sigma\\). Specifically, it states that dividing the polynomial \\(X(i)\\), which represents a monomial where the variable indexed by \\(i\\) has a coefficient of 1 and is raised to the power of 1, by the monomial represented as `Finsupp.single i 1`, results in the constant polynomial 1. Here, `Finsupp.single i 1` constructs a function (in this context, a monomial) that maps \\(i\\) to 1 and all other inputs to 0, effectively representing the variable \\(X_i\\) raised to the power of 1 in the polynomial notation."}
{"id": 690, "formal_statement": "theorem dummy : I.target = range (I : H ‚Üí E) :=", "nl_statement": "The statement we are discussing asserts that the target of a particular mapping \\(I\\), which maps from a space \\(H\\) to a space \\(E\\), is exactly the range of the mapping \\(I\\) when applied over the entire space \\(H\\)."}
{"id": 691, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) : (0 : Measure Œ±).map f = 0 :=", "nl_statement": "The problem states a theorem regarding the mapping of a measure, specifically the zero measure, through any function \\( f \\) from one space \\( \\alpha \\) to another space \\( \\beta \\). The theorem asserts that if you apply the mapping function \\( f \\) to the zero measure in space \\( \\alpha \\), the resulting measure in space \\( \\beta \\) is also zero. This can be intuitively understood as the measure of \"nothing\" in one space remains \"nothing\" even when mapped to another space."}
{"id": 692, "formal_statement": "theorem dummy {S : ConvexCone ùïú E} (hS : S.Flat) : S.Pointed :=", "nl_statement": "The statement in question is a theorem about convex cones, specifically it states that if a convex cone is flat, then it is also pointed. In the context of this theorem, a convex cone within a vector space is considered flat if it contains a vector `x` and its negative `-x`, and it's considered pointed if it contains the zero vector. The theorem formally asserts that the flatness property of a convex cone implies its pointedness."}
{"id": 693, "formal_statement": "theorem dummy {f g : M ‚Üí[L] N} : f = g ‚Üî ‚àÄ x, f x = g x :=", "nl_statement": "The statement provided defines a theorem concerning two mathematical functions, `f` and `g`, which map elements from a set `M` to a set `N` within a specific language `L`. The theorem states that `f` equals `g` if and only if, for every element `x` in the domain `M`, the value of `f` at `x` is equal to the value of `g` at `x`. This is a common form of an extensionality theorem in mathematics, which in this context, applies to functions within a specific formal language.\n\nIn natural language, the proof would proceed by showing both directions of the equivalence:\n\n1. **(‚Üí)** If `f` equals `g`, then by the definition of function equality, it must be that for every `x` in `M`, `f(x)` is equal to `g(x)`. This is a straightforward implication because function equality means their outputs are identical for identical inputs.\n\n2. **(‚Üê)** Conversely, to show that if for every `x` in `M`, `f(x)` equals `g(x)`, then `f` must equal `g`, one would typically rely on the principle of extensionality for functions. This principle states that two functions are considered equal if they produce the same output for every possible input from their domain. The proof would involve taking an arbitrary element `x` from `M` and showing that since `f(x)` equals `g(x)`, and this is true for all `x` in `M`, `f` and `g` must be the same function.\n\nThe reference to `DFunLike.ext_iff` suggests that this specific proof is a direct application of a more general extensionality principle that has been established elsewhere in the Lean4 framework or its libraries, which covers a wide range of function-like structures, possibly including functions in the context of first-order logic and homomorphisms.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 694, "formal_statement": "theorem dummy (E : C ‚âå D) : E.functor.inv = E.inverse :=", "nl_statement": "The statement asserts that for an equivalence `E` between two categories `C` and `D`, the inverse of the functor associated with `E` is equal to the inverse functor of `E`. In more concrete terms, if `E` establishes an equivalence between categories `C` and `D`, then the inverse of the functor that is part of `E` is the same as the inverse functor defined by `E`."}
{"id": 695, "formal_statement": "theorem dummy (h : a‚ÇÅ ‚â§ a‚ÇÇ) : Icc a‚ÇÇ b ‚äÜ Icc a‚ÇÅ b :=", "nl_statement": "The theorem `Icc_subset_Icc_left` states that if `a‚ÇÅ` is less than or equal to `a‚ÇÇ`, then the interval `[a‚ÇÇ, b]` is a subset of the interval `[a‚ÇÅ, b]`. Here, `Icc a b` denotes the closed interval from `a` to `b`, inclusive of both `a` and `b`."}
{"id": 696, "formal_statement": "theorem dummy (n : ‚Ñï) : (id : M ‚Üí‚Çó[R] M) ^ n = id :=", "nl_statement": "The statement concerns a theorem related to linear algebra, specifically dealing with the identity linear map on a module \\(M\\) over a ring \\(R\\). The theorem asserts that raising the identity map to any natural number power \\(n\\) yields the identity map itself."}
{"id": 697, "formal_statement": "theorem dummy (f : (‚ä§ : SimpleGraph V) ‚Üíg G') : Function.Injective f :=", "nl_statement": "The theorem states that if you have a function \\( f \\) which is a graph homomorphism from the complete graph on a set \\( V \\) (denoted as \\( \\top : SimpleGraph V \\)) to another graph \\( G' \\), then this function \\( f \\) is injective. An injective function is one where different inputs always result in different outputs."}
{"id": 698, "formal_statement": "theorem dummy : ‚àÉ f : X ‚Üí ‚Ñï ‚Üí·µá ‚Ñù, Embedding f := let ‚ü®f, hf‚ü© :=", "nl_statement": "The theorem `exists_embedding_l_infty` states that there exists a function `f` from some set `X` to the set of bounded functions from the natural numbers `‚Ñï` to the real numbers `‚Ñù`, such that `f` is an embedding."}
{"id": 699, "formal_statement": "theorem dummy {p : Submodule R M} : p = ‚ä§ ‚Üî ‚àÄ x, x ‚àà p :=", "nl_statement": "The statement concerns a property of submodules within the context of ring theory and linear algebra. Specifically, it is about determining when a given submodule, `p`, is equal to the whole space, denoted as `‚ä§` (top). The theorem states that a submodule `p` of a module `M` over a ring `R` is equal to the whole space if and only if every element `x` in the module `M` is contained within the submodule `p`."}
{"id": 700, "formal_statement": "theorem dummy [InvolutiveStar Œ±] {s : Set Œ±} (h : s.Nonempty) : s‚ãÜ.Nonempty :=", "nl_statement": "The statement concerns a mathematical concept related to sets in the context of an algebraic structure that might have an operation defined as \"star\" (‚ãÜ). Specifically, it deals with a property of sets within an environment where an operation called \"involutive star\" applies to elements of a type `Œ±`. The theorem asserts that if a set `s` of type `Œ±` is nonempty, then the set obtained by applying the star operation to `s` (`s‚ãÜ`) is also nonempty. This theorem is formulated within the Lean4 theorem prover environment, leveraging its syntax and types."}
{"id": 701, "formal_statement": "theorem dummy (hb : b ‚â† ‚àû) : a + b - b = a :=", "nl_statement": "The statement given is a mathematical theorem concerning operations on numbers (or possibly more abstract entities like elements of a mathematical structure) that asserts: given two elements `a` and `b`, if `b` is not equal to infinity (`‚àû`), then adding `b` to `a` and then subtracting `b` results in `a`. This can be expressed as `a + b - b = a`."}
{"id": 702, "formal_statement": "theorem dummy : (LinearMap.id : E ‚Üí‚Çó[ùïú] E).IsSymmetric :=", "nl_statement": "The theorem named `isSymmetric_id` asserts that the identity linear map (denoted as `LinearMap.id`) on a vector space `E` over a field `ùïú` is symmetric. This means that for any two elements in the vector space, the operation of the identity map respects a symmetry condition."}
{"id": 703, "formal_statement": "theorem dummy (x : ‚Ñù) : x ^ (2 : ‚Ñù) = x ^ 2 :=", "nl_statement": "The theorem states that for any real number x, raising x to the power of 2, where 2 is treated as a real number, is the same as raising x to the power of 2 in the usual sense (as an integer exponent)."}
{"id": 704, "formal_statement": "theorem dummy : Injective fun (Œº : OuterMeasure Œ±) (s : Set Œ±) => Œº s :=", "nl_statement": "The theorem `coe_fn_injective` states that the function mapping an outer measure Œº to its application on a set s (denoted as Œº s) is injective. In simpler terms, if we have two outer measures, Œº‚ÇÅ and Œº‚ÇÇ, and they agree on every set s (meaning for all sets s, Œº‚ÇÅ s = Œº‚ÇÇ s), then Œº‚ÇÅ must be equal to Œº‚ÇÇ. This is an important property in measure theory as it ensures the uniqueness of the outer measures based on their action on sets."}
{"id": 705, "formal_statement": "theorem dummy : IsMaxOn f univ a ‚Üî ‚àÄ x, f x ‚â§ f a :=", "nl_statement": "The theorem `isMaxOn_univ_iff` states that a function `f` has its maximum at `a` over the universe (i.e., for all possible inputs) if and only if for every `x`, `f(x)` is less than or equal to `f(a)`."}
{"id": 706, "formal_statement": "theorem dummy (f : R ‚Üí+* MvPolynomial œÉ S) (r : R) : bind‚ÇÇ f (C r) = f r :=", "nl_statement": "The statement provided asserts that when you apply the function `bind‚ÇÇ` to the constant polynomial `C r` (where `r` is an element of some ring `R`), using a ring homomorphism `f` from `R` to the ring of multivariate polynomials `MvPolynomial œÉ S`, the result is the same as applying `f` directly to `r`. Essentially, this theorem explores the interaction between a specific type of polynomial (the constant polynomial) and the operation of binding a ring homomorphism to the coefficients of a polynomial."}
{"id": 707, "formal_statement": "theorem dummy (K : Submodule ùïú E) : StarConvex ùïú (0 : E) K :=", "nl_statement": "The theorem states that a given submodule \\( K \\) of a vector space \\( E \\) over a field \\( ùïú \\) is star-convex with respect to the origin (0 in \\( E \\))."}
{"id": 708, "formal_statement": "theorem dummy (h : dist x y < infDist x s) : y ‚àâ s :=", "nl_statement": "The theorem named `not_mem_of_dist_lt_infDist` states that if the distance between two points `x` and `y` is less than the infimum distance from `x` to a set `s`, then `y` is not a member of `s`."}
{"id": 709, "formal_statement": "theorem dummy (x : R) : algebraMap R P x ‚àà (1 : FractionalIdeal S P) :=", "nl_statement": "The theorem named `coe_mem_one` concerns elements of a type `R` and their relationship to a specific kind of object in algebra known as a `FractionalIdeal`. This theorem states that when you take any element `x` from the type `R` and apply a function called `algebraMap` (which maps elements from `R` to `P`), the result is an element of the `FractionalIdeal` denoted by `1` in the context of a ring `S` and a field `P`."}
{"id": 710, "formal_statement": "theorem dummy {f : F} : mrange f = (‚ä§ : Submonoid N) ‚Üî Function.Surjective f :=", "nl_statement": "The theorem stated involves a function `f` from a type `F` to a monoid `N`, and it discusses the relationship between the image of `f` (denoted as `mrange f`) and the entirety of `N` (denoted as `‚ä§`, or the top element in lattice theory, representing the whole set in this context). Specifically, it claims that the image of `f` is equal to the entire set `N` if and only if `f` is a surjective function, meaning every element in `N` is an output from `f` for at least one input from `F`."}
{"id": 711, "formal_statement": "theorem dummy (K : Œπ ‚Üí Ideal S) : (iInf K).comap f = ‚®Ö i, (K i).comap f :=", "nl_statement": "The statement concerns the relationship between the operations of taking the infimum (iInf) of a family of ideals in a ring S, and the comap (preimage under a ring homomorphism f) of these ideals. Specifically, it states that the comap of the infimum of a family of ideals \\(K\\) indexed by \\(\\iota\\) is equal to the infimum of the comaps of the ideals in the family."}
{"id": 712, "formal_statement": "theorem dummy {z : ‚Ñ§} (h : 0 ‚â§ z) : normalize z = z :=", "nl_statement": "The theorem named `normalize_of_nonneg` concerns an integer `z`. It states that if `z` is non-negative (meaning `z` is greater than or equal to 0), then the \"normalize\" function applied to `z` will simply return `z` itself."}
{"id": 713, "formal_statement": "theorem dummy : ‚Ñµ‚ÇÄ ‚â† 0 :=", "nl_statement": "The statement we're examining is a mathematical theorem regarding cardinal numbers, specifically the cardinality of the set of natural numbers, often denoted by ‚Ñµ‚ÇÄ (aleph-null). The theorem asserts that ‚Ñµ‚ÇÄ is not equal to 0. In plain language, this means that the set of natural numbers (0, 1, 2, 3, ...) is not an empty set, and it has a cardinality (size of the set) that is greater than zero."}
{"id": 714, "formal_statement": "theorem dummy (a : ‚Ñù) : frontier { z : ‚ÑÇ | z.re ‚â§ a } = { z | z.re = a } :=", "nl_statement": "The theorem states that the boundary (frontier) of the set of complex numbers whose real part is less than or equal to a given real number \\(a\\) is exactly the set of complex numbers whose real part is equal to \\(a\\)."}
{"id": 715, "formal_statement": "theorem dummy (f : R ‚Üí+* S) (n : ‚Ñï) : map f (W n) = W n :=", "nl_statement": "The theorem `map_wittPolynomial` is about the behavior of a particular function, `map`, when applied to a specific mathematical object, the `Witt polynomial` denoted as `W n`, where `n` is a natural number (an element of ‚Ñï). The function `f` is a ring homomorphism from ring `R` to ring `S`, which means it respects addition and multiplication. The statement claims that applying the `map` function, with this homomorphism `f`, to the Witt polynomial `W n` yields the same Witt polynomial `W n`. This is a statement about the invariance of Witt polynomials under such mapping by ring homomorphisms.\n\nThe logical structure of the proof involves expanding the Witt polynomial into a form that can be directly manipulated, applying the mapping operation to each part of this form, and then demonstrating that the operation does not change the polynomial. This is achieved through the application of properties of ring homomorphisms and the specific structure of Witt polynomials.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 716, "formal_statement": "theorem dummy : ((‚ä• : NonUnitalSubsemiring R) : Set R) = {0} :=", "nl_statement": "The statement concerns a mathematical structure within the context of rings in algebra. Specifically, it's about the smallest possible subsemiring of a given ring \\(R\\), often denoted as \\(‚ä•\\), and how this smallest subsemiring is represented when considered as a set of elements from \\(R\\). The theorem asserts that when you consider the smallest subsemiring (\\(‚ä•\\)) of a ring \\(R\\) as a set, it is exactly equal to the set containing only the zero element of \\(R\\)."}
{"id": 717, "formal_statement": "theorem dummy {a : Œ±} {s : Finset Œ±} : s.val = {a} ‚Üî s = {a} :=", "nl_statement": "The theorem states a condition under which a given finite set \\(s\\) of type `Finset Œ±`, where `Œ±` is any type, can be considered equal to a singleton set containing only the element \\(a\\). Specifically, it asserts that the internal representation (often implemented as a list without duplicates for efficiency) of \\(s\\), denoted as `s.val`, is equal to the singleton set containing \\(a\\), if and only if \\(s\\) itself is equal to the singleton set `{a}`."}
{"id": 718, "formal_statement": "theorem dummy (œÜ : L.BoundedFormula Œ± (n + 1)) : ¬¨œÜ.all.IsAtomic :=", "nl_statement": "The theorem `not_all_isAtomic` asserts that for any bounded formula `œÜ` in the first-order language `L` with arity `n + 1`, it is not the case that the universal closure of `œÜ` is an atomic formula."}
{"id": 719, "formal_statement": "theorem dummy [LocallyFiniteOrder Œπ] (i : Œπ) (hi : succFn i ‚â§ i) : IsMax i :=", "nl_statement": "The theorem states that in a locally finite order \\( \\mathcal{L} \\) of elements of type \\( \\iota \\), for any element \\( i \\) in \\( \\mathcal{L} \\), if the successor function applied to \\( i \\) is less than or equal to \\( i \\) itself, then \\( i \\) is a maximal element in \\( \\mathcal{L} \\)."}
{"id": 720, "formal_statement": "theorem dummy (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=", "nl_statement": "The statement concerns polynomials over a ring \\(R\\) and involves the operation of taking the remainder of one polynomial when divided by another, denoted as \\(p \\%‚Çò q\\), where \\(p\\) and \\(q\\) are polynomials in \\(R[X]\\). The theorem asserts that if \\(q\\) is not a monic polynomial (meaning its leading coefficient is not 1), then the remainder of \\(p\\) when divided by \\(q\\) is simply \\(p\\) itself."}
{"id": 721, "formal_statement": "theorem dummy {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=", "nl_statement": "The statement provided essentially says that for a certain property `p` that applies to elements of type `Œ≤`, the property holds for all elements in the set `e.target` if and only if it holds for all elements in `e.source` after being transformed by `e`. In more intuitive terms, consider `e` as a function or transformation from a set called `source` to another set called `target`. The theorem is stating that a property `p` is true for every element in `target` if and only if that property is also true for every element in `source` once it has been transformed by `e`."}
{"id": 722, "formal_statement": "theorem dummy {m : Multiset A} (h : ‚àÄ x ‚àà m, x ‚àà S) : m.sum ‚àà S :=", "nl_statement": "The statement concerns a mathematical concept within the context of multiset operations and set membership. Specifically, it states that if every element of a multiset \\(m\\) belongs to a set \\(S\\), then the sum of all elements in the multiset \\(m\\) also belongs to \\(S\\)."}
{"id": 723, "formal_statement": "theorem dummy (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v :=", "nl_statement": "The theorem `tr_eval` states that the evaluation of a Turing machine's step function, when applied to the initial configuration of the Turing machine (constructed from a given computation `c` and input value `v`), is equivalent to the result of evaluating the computation `c` on the input `v`, with the evaluation result being in a halted state. This is captured in the expression: `eval (TM2.step tr) (init c v) = halt <$> Code.eval c v`, where `tr` represents a specific Turing machine translation function, `eval` is a function evaluating the computation, `init` initializes the Turing machine's configuration, and `halt <$> Code.eval c v` denotes the application of the halt state to the result of the computation `c` evaluated on input `v`."}
{"id": 724, "formal_statement": "theorem dummy (s‚ÇÅ : Finset Œ±) : s‚ÇÅ \\ s‚ÇÅ = ‚àÖ :=", "nl_statement": "The theorem in question states that for any finite set \\( s_1 \\), the difference between \\( s_1 \\) and itself is the empty set. In mathematical terms, this is represented as \\( s_1 \\setminus s_1 = \\emptyset \\)."}
{"id": 725, "formal_statement": "theorem dummy : InfinitePos œâ :=", "nl_statement": "The given theorem, `infinitePos_omega`, asserts the infiniteness in a positive sense of a particular mathematical entity denoted by `œâ` (omega). In mathematical contexts, especially within the realm of non-standard analysis, `œâ` often symbolizes a type of number or quantity that surpasses all finite numbers, typically understood as an \"infinitely large\" value."}
{"id": 726, "formal_statement": "theorem dummy {p : Box Œπ ‚Üí Prop} : J ‚àà œÄ.filter p ‚Üî J ‚àà œÄ ‚àß p J :=", "nl_statement": "The statement concerns a property of filtering a set (or prepartition) in the context of box integrals. Specifically, it states that an element (a box, denoted as `J`) belongs to the filtered set (or filtered prepartition, denoted as `œÄ.filter p`) if and only if it belongs to the original set (`œÄ`) and satisfies a certain property (`p`)."}
{"id": 727, "formal_statement": "theorem dummy {s t : SetSemiring Œ±} : SetSemiring.down s ‚äÇ SetSemiring.down t ‚Üî s < t :=", "nl_statement": "The statement concerns two elements, `s` and `t`, belonging to a structure called `SetSemiring`. It claims that the \"downward closure\" (denoted as `SetSemiring.down`) of `s` is a proper subset of the downward closure of `t` if and only if `s` is less than `t` in some ordering."}
{"id": 728, "formal_statement": "theorem dummy (m : M) : b.toDualEquiv m = b.toDual m :=", "nl_statement": "The statement concerns a function or transformation named `toDualEquiv` applied to an element `m` of a set or space `M`, with the assertion that applying this function to `m` results in the same outcome as applying another function named `toDual` to `m`. The context suggests that `b` represents a basis or some structured entity related to `M`, and both `toDualEquiv` and `toDual` are operations or transformations associated with `b`."}
{"id": 729, "formal_statement": "theorem dummy : Primrec (@List.join Œ±) :=", "nl_statement": "The theorem named `list_join` is about proving that the operation of joining a list of lists into a single list is a primitive recursive function. In simpler terms, it aims to show that the process of combining multiple lists into one, where each list is an element of a bigger list, can be accomplished by a function that is fundamentally simple and computable in a step-by-step manner, without needing any complex operations or infinite loops."}
{"id": 730, "formal_statement": "theorem dummy (S T : Submonoid G) : S‚Åª¬π ‚â§ T‚Åª¬π ‚Üî S ‚â§ T :=", "nl_statement": "The statement concerns the relationship between the inverses of two submonoids \\(S\\) and \\(T\\) of a group \\(G\\). Specifically, it asserts that the inverse of \\(S\\) is a subset of the inverse of \\(T\\) if and only if \\(S\\) itself is a subset of \\(T\\). In mathematical terms, this can be expressed as \\(S^{-1} \\leq T^{-1} \\iff S \\leq T\\), where \\(S^{-1}\\) and \\(T^{-1}\\) denote the sets of inverses of elements in \\(S\\) and \\(T\\), respectively, and the symbol \\(\\leq\\) denotes the subset relation between these sets."}
{"id": 731, "formal_statement": "theorem dummy (p : Nat.Primes) : (ofPrime p : Multiset ‚Ñï+) = {(p : ‚Ñï+)} :=", "nl_statement": "The statement you've given asserts that for any prime number `p` which belongs to a collection of prime numbers (denoted by `Nat.Primes`), when this prime number `p` is converted into an element of a multiset of positive natural numbers (`Multiset ‚Ñï+`), the result is a multiset containing exactly one element, which is `p` itself represented as a positive natural number (`‚Ñï+`)."}
{"id": 732, "formal_statement": "theorem dummy {a b : Cardinal} (h : b ‚â† 0) : a ‚â§ a * b :=", "nl_statement": "The statement we are discussing asserts that for any two cardinal numbers \\(a\\) and \\(b\\), if \\(b\\) is not equal to zero, then \\(a\\) is less than or equal to \\(a\\) multiplied by \\(b\\)."}
{"id": 733, "formal_statement": "theorem dummy (X : C) : (X : Karoubi C).p = ùüô X :=", "nl_statement": "The given theorem states that for any object \\(X\\) in a category \\(C\\), when \\(X\\) is considered as an object in the Karoubi envelope of \\(C\\) (denoted as \\(Karoubi C\\)), the idempotent endomorphism associated with \\(X\\) (denoted as \\(.p\\)) is equal to the identity morphism on \\(X\\) (denoted as \\(ùüô X\\))."}
{"id": 734, "formal_statement": "theorem dummy : @DenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) := letI : TopologicalSpace Œ± :=", "nl_statement": "The theorem named `denseInducing_pure` states that the function `pure : Œ± ‚Üí Ultrafilter Œ±` is a dense inducing function. In the context of topology, a dense inducing function between two topological spaces implies a certain richness or completeness of the image of the function within the target space. Specifically, it means that the closure of the image of the function is the whole space, and the function has a topology-related property that is inherited from the codomain."}
{"id": 735, "formal_statement": "theorem dummy : P.parts.Nonempty ‚Üî a ‚â† ‚ä• :=", "nl_statement": "The statement concerns the non-emptiness of a certain set called `P.parts` in the context of a mathematical structure, possibly a partition of some sort, denoted by `P`. The theorem states that `P.parts` is non-empty if and only if a certain element `a` is not the bottom element (denoted by `‚ä•`). In mathematical terms, this can be interpreted as a condition on the structure `P` that relates the non-emptiness of its parts to a specific property of an element `a`."}
{"id": 736, "formal_statement": "theorem dummy (a : Œ±) : IsOpen { b : Œ± | b < a } :=", "nl_statement": "The theorem `isOpen_gt'` states that for any element `a` from a set of type `Œ±`, the set of all elements `b` of type `Œ±` such that `b < a` is open. This is a statement about the openness of a set, which in the context of topology, means intuitively that for every point within the set, there is a neighborhood around that point which is also entirely contained within the set."}
{"id": 737, "formal_statement": "theorem dummy (x‚ÇÅ x‚ÇÇ) (y : S) : f.mk' x‚ÇÇ y * f.toMap x‚ÇÅ = f.mk' (x‚ÇÅ * x‚ÇÇ) y :=", "nl_statement": "The statement concerns the behavior of a specific operation, denoted as `f.mk'`, within a mathematical structure, where `f` is a map that has a `toMap` operation and a `mk'` operation. The theorem, `mk'_mul_eq_mk'_of_mul`, asserts that for any elements `x‚ÇÅ` and `x‚ÇÇ`, and another element `y` belonging to a set `S`, the operation `f.mk' x‚ÇÇ y` multiplied by `f.toMap x‚ÇÅ` is equivalent to `f.mk' (x‚ÇÅ * x‚ÇÇ) y`. This is a formal way to express a property about how these operations interact, specifically focusing on the multiplication and the `mk'` operation."}
{"id": 738, "formal_statement": "theorem dummy {k n : ‚Ñï} : œÉ k n = ‚àë d in divisors n, d ^ k :=", "nl_statement": "The statement in question defines a relationship between the sum of powers of the divisors of a number and a specific arithmetic function, œÉ, applied to two natural numbers, k and n. In particular, it asserts that the value of the œÉ function applied to k and n equals the sum of the kth powers of all divisors of n. In simpler terms, it means if you take every number that divides n, raise each of these divisors to the power of k, and then sum all these powered divisors up, you'll get the same result as if you applied this œÉ function to k and n."}
{"id": 739, "formal_statement": "theorem dummy : StrictMono fun n => fib (n + 2) :=", "nl_statement": "The statement concerns the strict monotonicity of a function that, for any natural number \\(n\\), computes the \\(n+2\\)nd Fibonacci number, denoted by `fib (n + 2)`. Specifically, the theorem named `fib_add_two_strictMono` asserts that this function is strictly monotonic, meaning that if you take any natural number \\(n\\) and then consider the next natural number \\(n+1\\), the Fibonacci number at position \\(n+2\\) will always be strictly less than the Fibonacci number at position \\(n+3\\)."}
{"id": 740, "formal_statement": "theorem dummy (hA : Balanced ùïú A) (hB : Balanced ùïú B) : Balanced ùïú (A ‚à© B) :=", "nl_statement": "The statement concerns the concept of a \"Balanced\" set within the context of some mathematical space, likely a vector space over a field ùïú. It asserts that if two sets, A and B, are balanced, then their intersection (A ‚à© B) is also balanced."}
{"id": 741, "formal_statement": "theorem dummy : Respects (TM2.step M) (TM1.step (tr M)) TrCfg :=", "nl_statement": "The statement to be proven concerns the relationship between the stepping function of a Turing machine in the TM2 model (`TM2.step M`) and the stepping function in the transformed TM1 model (`TM1.step (tr M)`) through a function `TrCfg`. Specifically, it asserts that the `TM2.step` function respects the `TM1.step` function under transformation `TrCfg`, meaning that if one configuration transitions to another in the TM2 model, then their transformed counterparts in the TM1 model also exhibit a transition relationship."}
{"id": 742, "formal_statement": "theorem dummy (s : Submodule R M) : Module.rank R s ‚â§ Module.rank R M :=", "nl_statement": "The statement asserts that the rank of a submodule \\( s \\) of a module \\( M \\) over a ring \\( R \\) is less than or equal to the rank of the module \\( M \\)."}
{"id": 743, "formal_statement": "theorem dummy : sInf (‚àÖ : Set ‚Ñù‚â•0) = 0 :=", "nl_statement": "The theorem named `sInf_empty` asserts that the infimum (greatest lower bound) of an empty set, when considered within the non-negative real numbers (notated as ‚Ñù‚â•0), is equal to 0."}
{"id": 744, "formal_statement": "theorem dummy [Fact (1 ‚â§ p)] : Continuous fun f : Lp ‚Ñù p Œº => posPart f :=", "nl_statement": "The statement concerns a theorem about a function defined within the context of \\(L^p\\) spaces over the real numbers (\\(\\mathbb{R}\\)) under a measure \\(\\mu\\), where \\(p \\geq 1\\). It asserts that the function which takes another function \\(f\\) in the \\(L^p\\) space (\\(L^p(\\mathbb{R}, p, \\mu)\\)) and returns its positive part (denoted as \\(posPart f\\)) is continuous."}
{"id": 745, "formal_statement": "theorem dummy : WalkingPair.swap.symm left = right :=", "nl_statement": "The given theorem states that applying the inverse (or symmetrical operation) of a swap function on the element 'left' results in 'right'. This is in the context of Category Theory, particularly within the scope of limits and walking pairs, which are simplified diagram shapes used to describe universal properties in category theory."}
{"id": 746, "formal_statement": "theorem dummy : ‚àÄ {a b : WithBot Œ±}, a < b ‚Üî ‚àÉ p : Œ±, b = p ‚àß a < p | a, some b => by simp [coe_eq_coe] | a, ‚ä• => iff_of_false (not_lt_none _) <| by simp :=", "nl_statement": "The statement is about the relationship between two elements `a` and `b` of a type `WithBot Œ±`, where `Œ±` is an arbitrary type, and `WithBot Œ±` represents either an element of type `Œ±` or a bottom element (denoted as `‚ä•`), which can be thought of as representing \"infinity\" or an \"undefined\" element in this context. The theorem states that `a` is less than `b` if and only if there exists some element `p` of type `Œ±` such that `b` is equal to `p` and `a` is less than `p`."}
{"id": 747, "formal_statement": "theorem dummy {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=", "nl_statement": "The problem presents a theorem about an element \\(x\\) of a Lie algebra \\(L\\) over a ring \\(R\\), concerning its membership in the Lie span of a subset \\(s\\) of \\(L\\). The theorem states that \\(x\\) is in the Lie span of \\(s\\) if and only if, for every Lie subalgebra \\(K\\) of \\(L\\) that contains \\(s\\), \\(x\\) is also in \\(K\\)."}
{"id": 748, "formal_statement": "theorem dummy : (‚àè _x in s, (1 : Œ≤)) = 1 :=", "nl_statement": "The statement to be proven is that the product of a constant number \\(1\\) over any finite set \\(s\\) (within a certain type \\(\\beta\\)) is equal to \\(1\\)."}
{"id": 749, "formal_statement": "theorem dummy {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=", "nl_statement": "The theorem `meas_snormEssSup_lt` concerns a function `f` from some domain `Œ±` to a Banach space `F`, and a measure `Œº`. It states that the measure of the set of points `y` in `Œ±` where the essential supremum norm of `f` with respect to `Œº`, denoted as `snormEssSup f Œº`, is less than the non-negative norm of `f(y)`, is equal to zero. In simpler terms, almost everywhere in the domain of `f` (according to the measure `Œº`), the value of `f` at any point does not exceed the essential supremum norm of `f`."}
{"id": 750, "formal_statement": "theorem dummy : Function.Injective (@Fin.val n) :=", "nl_statement": "The statement to be proven is that the `val` function from the `Fin` type in Lean4 is injective for a given `n`. In simpler terms, if we have a type `Fin n` which represents the set of natural numbers less than `n`, the `val` function, which returns the value of an element of this set, is injective. An injective function, also known as a one-to-one function, is a function where every element of the function's domain maps to a distinct element of its codomain. In this context, it means that no two different elements of `Fin n` have the same value when the `val` function is applied to them."}
{"id": 751, "formal_statement": "theorem dummy {Œ±} [Primcodable Œ±] (p : Œ± ‚Üí Prop) : p ‚â§‚ÇÅ p :=", "nl_statement": "The theorem states that any property \\(p\\) of elements of a type \\(\\alpha\\), where \\(\\alpha\\) is a type that can be encoded (as specified by `[Primcodable Œ±]`), is one-one reducible to itself. In simpler terms, it's saying that any computable property you can define on elements of a certain type can be transformed in a way that preserves uniqueness (injectivity) when you're comparing it to the same property. This is a formal way to express that any property or problem is, in a very straightforward sense, equivalent to itself in terms of computational complexity and uniqueness of solutions."}
{"id": 752, "formal_statement": "theorem dummy (v w : V) : (‚ä• : SimpleGraph V).Adj v w ‚Üî False :=", "nl_statement": "The theorem named `bot_adj` concerns a simple graph denoted as `(‚ä• : SimpleGraph V)` involving vertices `v` and `w` of some type `V`. It asserts that there is no adjacency between any two vertices `v` and `w` in the empty graph, symbolized by `(‚ä• : SimpleGraph V)`. In other words, for any vertices `v` and `w`, the statement that `v` is adjacent to `w` in the empty graph is equivalent to `False`."}
{"id": 753, "formal_statement": "theorem dummy : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK :=", "nl_statement": "The theorem states that the real part of the product of two quaternions \\(a\\) and \\(b\\) is equal to the product of their real parts minus the products of their respective imaginary parts \\(i\\), \\(j\\), and \\(k\\). In formula terms, this can be expressed as:\n\\[(a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK\\]"}
{"id": 754, "formal_statement": "theorem dummy : G·∂ú = (‚ä§ : SimpleGraph V).deleteEdges G.edgeSet :=", "nl_statement": "The theorem named `compl_eq_deleteEdges` states that the complement of a graph `G` (denoted as `G·∂ú`) is equal to the complete graph on the same vertex set as `G` (denoted as `‚ä§ : SimpleGraph V`), with the edges of `G` removed (this operation is represented by `.deleteEdges G.edgeSet`)."}
{"id": 755, "formal_statement": "theorem dummy {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) :=", "nl_statement": "The theorem states that for any real number \\( x \\), if \\( x \\) is self-adjoint (a property often related to matrices or operators in linear algebra, meaning \\( x \\) is equal to its own adjoint), then the negation of \\( x \\) (denoted as \\( -x \\)) is also self-adjoint."}
{"id": 756, "formal_statement": "theorem dummy (n : ‚Ñï) (hn : 0 < n) : wittOne p n = 0 :=", "nl_statement": "The statement given is a theorem concerning the mathematical object known as a \"Witt vector.\" Specifically, it asserts that for any positive natural number \\(n\\) (i.e., \\(n > 0\\)), a certain function `wittOne p n` evaluates to zero. The function `wittOne p n` is defined within the context of Witt vectors and is dependent on a prime \\(p\\) and the natural number \\(n\\)."}
{"id": 757, "formal_statement": "theorem dummy (f : m ‚Üí n ‚Üí Œ±) (i j) : of f i j = f i j :=", "nl_statement": "The statement given is about a function `f` that takes two arguments, an element `i` from some type `m`, and an element `j` from some type `n`, to produce an output of type `Œ±`. The theorem named `of_apply` asserts that for this function `f`, when applied to specific values `i` and `j`, the operation `of f i j` is exactly equal to directly applying the function `f` to these same values `i` and `j`."}
{"id": 758, "formal_statement": "theorem dummy [FiniteDimensional k V] (b : AffineBasis Œπ k P) : Finite Œπ :=", "nl_statement": "The theorem in question states that if we have a vector space \\(V\\) over a field \\(k\\) that is finite-dimensional (as indicated by `[FiniteDimensional k V]`), and if \\(b\\) is an affine basis of a set \\(P\\) with index set \\(\\iota\\) (denoted as `AffineBasis Œπ k P`), then the index set \\(\\iota\\) is finite."}
{"id": 759, "formal_statement": "theorem dummy [LE Œ±] [LE Œ≤] {x‚ÇÅ x‚ÇÇ : Œ±} {y‚ÇÅ y‚ÇÇ : Œ≤} : (x‚ÇÅ, y‚ÇÅ) ‚â§ (x‚ÇÇ, y‚ÇÇ) ‚Üî x‚ÇÅ ‚â§ x‚ÇÇ ‚àß y‚ÇÅ ‚â§ y‚ÇÇ :=", "nl_statement": "The statement defines a theorem regarding the order of pairs in a given structure where `Œ±` and `Œ≤` are types with a defined less-than-or-equal-to (`‚â§`) relation. Specifically, it states that for any four elements `x‚ÇÅ`, `x‚ÇÇ` of type `Œ±` and `y‚ÇÅ`, `y‚ÇÇ` of type `Œ≤`, the pair `(x‚ÇÅ, y‚ÇÅ)` is less than or equal to the pair `(x‚ÇÇ, y‚ÇÇ)` if and only if `x‚ÇÅ ‚â§ x‚ÇÇ` and `y‚ÇÅ ‚â§ y‚ÇÇ`."}
{"id": 760, "formal_statement": "theorem dummy (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=", "nl_statement": "The statement concerns the behavior of product filters in the context of ordered filters. Specifically, it asserts that if you have two filters on the same set, say `f‚ÇÅ` and `f‚ÇÇ`, and `f‚ÇÅ` is less than or equal to `f‚ÇÇ` (denoted as `f‚ÇÅ ‚â§ f‚ÇÇ`), then the product of `f‚ÇÅ` with another filter `g` (on a potentially different set) is also less than or equal to the product of `f‚ÇÇ` with `g`. In other words, increasing one component of a product filter (while keeping the other constant) results in an increase of the product filter itself."}
{"id": 761, "formal_statement": "theorem dummy (s : Finset Œ±) (a : Œ±) : s.erase a = ‚àÖ ‚Üî s = ‚àÖ ‚à® s = {a} :=", "nl_statement": "The statement concerns a finite set `s` of some type `Œ±`, and an element `a` of that type. It asserts that the condition of removing the element `a` from the set `s` (denoted as `s.erase a`) resulting in an empty set (denoted as `‚àÖ`) is equivalent to one of two possibilities: either the set `s` was already empty to begin with, or the set `s` consisted solely of the element `a`."}
{"id": 762, "formal_statement": "theorem dummy (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=", "nl_statement": "The statement you're asking about asserts that the closure of the union of two sets, \\(s\\) and \\(t\\), within a certain context (likely a ring \\(R\\) given the use of `Set R`), is equal to the supremum (least upper bound) of the closures of \\(s\\) and \\(t\\) individually. In simpler terms, if you take two sets within a ring, unite them, and then find the smallest closed set that contains this union, this will be the same as finding the closure of each set individually and then finding the smallest closed set that contains both closures."}
{"id": 763, "formal_statement": "theorem dummy : LeftInverse (fun a : G ‚Ü¶ a‚Åª¬π) fun a ‚Ü¶ a‚Åª¬π :=", "nl_statement": "Prove that the function that takes an element to its inverse is its own left inverse in a group \\(G\\).\n\nThis theorem states that in a group \\(G\\), the function that assigns to each element \\(a\\) its inverse \\(a^{-1}\\) is its own left inverse. This means that applying this function twice to any element of the group will return the original element."}
{"id": 764, "formal_statement": "theorem dummy (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r :=", "nl_statement": "The statement `theorem smul_sphere (c : G) (x : X) (r : ‚Ñù) : c ‚Ä¢ sphere x r = sphere (c ‚Ä¢ x) r` expresses that if you scale (or multiply) all points on a sphere centered at `x` with radius `r` by a constant `c`, the result is a sphere of the same radius `r` but centered at `c ‚Ä¢ x`, where `c ‚Ä¢ x` denotes the scaling of `x` by `c`."}
{"id": 765, "formal_statement": "theorem dummy {Œ± : Type u} (a : m (m (m Œ±))) : joinM (joinM <$> a) = joinM (joinM a) :=", "nl_statement": "The statement in question is about the behavior of a particular function, `joinM`, when applied to nested monadic structures in a specific programming context (likely in functional programming). The type `Œ±` represents an arbitrary type, and `m` represents a monadic structure. The expression `m (m (m Œ±))` indicates a three-level nested monadic structure. The theorem `joinM_map_joinM` asserts that applying `joinM` to the result of mapping `joinM` over a nested monadic structure is equivalent to just applying `joinM` twice to the nested structure."}
{"id": 766, "formal_statement": "theorem dummy : tsupport (f.normed Œº) = Metric.closedBall c f.rOut :=", "nl_statement": "The theorem named `tsupport_normed_eq` asserts that the topological support of the normed function `f` with respect to a measure `Œº` is equal to the closed ball centered at `c` with radius `f.rOut`."}
{"id": 767, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) : (s.bind fun x => ({f x} : Multiset Œ≤)) = map f s :=", "nl_statement": "The theorem named `bind_singleton` is about transforming a multiset using a function in a specific way. It states that if you have a multiset `s` and a function `f` that maps elements from type `Œ±` to type `Œ≤`, then taking each element of `s`, applying `f` to it, and then creating a new multiset where each element is now the result of applying `f`, is equivalent to directly mapping `f` over the multiset `s`. In other words, individually transforming each element of `s` into a singleton multiset with `f` and then combining these singletons is the same as applying `f` to each element of `s` to get a new multiset."}
{"id": 768, "formal_statement": "theorem dummy : s.disjSum (0 : Multiset Œ≤) = s.map inl :=", "nl_statement": "The theorem named `disjSum_zero` is stating a property about operations on multisets, specifically using the `disjSum` operation with a multiset `s` of type `Œ±` and an empty multiset of type `Œ≤`. The theorem asserts that when you perform the disjoint sum of multiset `s` with an empty multiset `(0 : Multiset Œ≤)`, the result is equivalent to applying a function `map inl` to the multiset `s`, effectively transforming each element of `s` from type `Œ±` to type `Œ± + Œ≤` (where `inl` is the function that injects elements of `Œ±` into the sum type `Œ± + Œ≤`)."}
{"id": 769, "formal_statement": "theorem dummy {t : ‚Ñù} : 2 * t - 1 ‚àà I ‚Üî t ‚àà Set.Icc (1 / 2 : ‚Ñù) 1 :=", "nl_statement": "The theorem states that for any real number \\( t \\), the expression \\( 2t - 1 \\) is a member of the interval \\( I \\) if and only if \\( t \\) is a member of the closed interval from \\( \\frac{1}{2} \\) to 1 (denoted as \\([ \\frac{1}{2}, 1 ]\\)). In other words, it's establishing a relationship between a transformed version of \\( t \\) and whether \\( t \\) lies within a specific range."}
{"id": 770, "formal_statement": "theorem dummy (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=", "nl_statement": "The theorem `induce_mono_left` asserts that if `G'` is a subgraph of `G''` (denoted by `G' ‚â§ G'`'), then the induced subgraph of `G'` by a set `s` is also a subgraph of the induced subgraph of `G''` by the same set `s`. This essentially means that the operation of inducing a subgraph by a set of vertices preserves the subgraph relationship."}
{"id": 771, "formal_statement": "theorem dummy : [b].destutter' R a = if R a b then [a, b] else [a] :=", "nl_statement": "The statement provided concerns a function named `destutter'` which operates on lists. Specifically, it focuses on the case where this function is applied to a singleton list `[b]` and examines how the outcome depends on the relationship between `a` and `b`, as determined by a relation `R`. The theorem asserts that the result of `destutter' R a` on the list `[b]` will be a two-element list `[a, b]` if `R a b` holds true (meaning the relation `R` between `a` and `b` is satisfied). If `R a b` does not hold, then the result will simply be the single-element list `[a]`."}
{"id": 772, "formal_statement": "theorem dummy : (Forall‚ÇÇ R ‚áí (R ‚áí Forall‚ÇÇ P) ‚áí Forall‚ÇÇ P) List.bind List.bind :=", "nl_statement": "The theorem `rel_bind` asserts a specific property of the `List.bind` function with respect to a relation `R` and a predicate `P` applied to lists. It states that if there is a relation `R` that holds between two lists, and if for every element `x` in the first list, applying a function that respects `R` to `x` results in a list of elements that satisfy predicate `P`, then the result of applying `List.bind` with this function to the first list will be a list of elements that all satisfy `P`."}
{"id": 773, "formal_statement": "theorem dummy : Ioc (‚ä• : WithBot Œ±) b = (Iic b).map Embedding.some :=", "nl_statement": "The statement provided is a theorem in the context of order theory, specifically dealing with partially ordered sets that have been extended with a bottom element (denoted by ‚ä•). This theorem involves intervals within such sets. In the given theorem, `Ioc (‚ä• : WithBot Œ±) b` and `(Iic b).map Embedding.some` are set to be equal. Here's a breakdown of the components:\n- `WithBot Œ±` refers to a type `Œ±` extended with a bottom element, ‚ä•, which is less than every other element.\n- `Ioc a b` denotes the interval of all elements greater than `a` and less than or equal to `b`.\n- `Iic b` represents the interval of all elements less than or equal to `b`.\n- `Embedding.some` is a function that embeds elements of type `Œ±` into the `WithBot Œ±` type, excluding the bottom element.\n\nThe statement thus asserts that the interval of all elements greater than the bottom element and less than or equal to `b` in the extended type `WithBot Œ±` is equal to the set obtained by mapping all elements less than or equal to `b` (in the original type `Œ±`) into the extended type, using the embedding function."}
{"id": 774, "formal_statement": "theorem dummy (h : s.Nonempty) : s‚Åª¬π.Nonempty :=", "nl_statement": "If a set \\( s \\) is non-empty, then its inverse \\( s‚Åª¬π \\) is also non-empty.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 775, "formal_statement": "theorem dummy {n : ‚Ñï} (g : G) : g ^ n = g ^ (n % exponent G) := calc g ^ n = g ^ (n % exponent G + exponent G * (n / exponent G)) :=", "nl_statement": "The statement to be translated is about the properties of exponentiation in some group \\( G \\). Specifically, it asserts that for any element \\( g \\) of the group and any natural number \\( n \\), the exponentiation of \\( g \\) to the power of \\( n \\) is equivalent to exponentiating \\( g \\) to the power of \\( n \\) modulo the exponent of the group \\( G \\). The \"exponent\" of a group in this context refers to the smallest positive integer \\( m \\) such that for every element \\( g \\) in the group, \\( g^m = e \\), where \\( e \\) is the identity element of the group."}
{"id": 776, "formal_statement": "theorem dummy {f g : Œ± ‚Üí Œ≤} (hf : Integrable f Œº) (h : f =·µê[Œº] g) : Integrable g Œº :=", "nl_statement": "The problem states a theorem about the integrability of functions within a measure space. Specifically, it asserts that if a function `f` is integrable over a measure space with respect to a measure `Œº`, and another function `g` is almost everywhere equal to `f` with respect to the same measure, then `g` is also integrable over the measure space with respect to `Œº`."}
{"id": 777, "formal_statement": "theorem dummy (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b :=", "nl_statement": "The statement `theorem coe_const (b : Œ≤) : ‚áë(const Œ± b) = Function.const Œ± b := rfl` in Lean4 syntax involves a theorem named `coe_const` concerning a type `Œ≤` and a constant function. The theorem asserts that applying a `const` function of type `Œ±` to some element `b` of type `Œ≤` is equivalent to the standard constant function in mathematics that maps any input to the value `b`."}
{"id": 778, "formal_statement": "theorem dummy {P Q : Prop} : IsCompl P Q ‚Üî ¬¨(P ‚Üî Q) :=", "nl_statement": "The statement is about a property related to two propositions, \\(P\\) and \\(Q\\), and it explores the conditions under which these two propositions are considered complementary (IsCompl). Specifically, it examines the equivalence between two propositions being complementary and the negation of the condition that \\(P\\) is equivalent to \\(Q\\)."}
{"id": 779, "formal_statement": "theorem dummy {x : ‚Ñù} : 0 < arcsin x ‚Üî 0 < x :=", "nl_statement": "The statement concerns the positivity of the arcsine function, specifically stating a condition under which the arcsine of a real number \\(x\\) is positive. Formally, the statement is: \"The arcsine of \\(x\\) is greater than 0 if and only if \\(x\\) itself is greater than 0.\""}
{"id": 780, "formal_statement": "theorem dummy (s : Set (OnePoint X)) (x : X) : ùìù[s] ‚Üëx = map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x) :=", "nl_statement": "The statement concerns the topology of a space extended by one point, typically referred to as the Alexandroff extension or the one-point compactification of a space \\(X\\). The lemma states that the neighborhood within a set \\(s\\) of the point \\(x\\) in this extended space, denoted as \\(ùìù[s] ‚Üëx\\), is equivalent to the image under the embedding map \\(‚Üë\\) of the neighborhood within the preimage of \\(s\\) under this embedding, of \\(x\\) in the original space \\(X\\), i.e., \\(map (‚Üë) (ùìù[(‚Üë) ‚Åª¬π' s] x)\\)."}
{"id": 781, "formal_statement": "theorem dummy {q : ‚àÄ x, p x ‚Üí Prop} : (‚àÄ x h, q x h) ‚Üî ‚àÄ x : { a // p a }, q x x.2 :=", "nl_statement": "The theorem stated in the Lean4 syntax addresses a particular kind of universal quantification over a subset of elements from a given set. Specifically, it concerns a scenario where for each element `x` of a set, there exists a property `p` such that `p x` is true, and based on this, a property `q` that takes an element `x` and a proof of `p x` (`h`) and returns a proposition. The theorem asserts that a statement about every such `x` satisfying `p x` can be equivalently expressed in two ways: one directly over elements satisfying `p`, and the other over elements of a subset of the original set where `p` holds, encapsulated as `{a // p a}`."}
{"id": 782, "formal_statement": "theorem dummy (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=", "nl_statement": "The theorem named `id_apply` concerns a mathematical structure in a geometric context, specifically dealing with affine isometries. It states that applying the identity affine isometry to any point `x` in a space `P` results in the same point `x`. In simpler terms, if you have a transformation that does absolutely nothing to the points in a space (that is, it's the identity transformation), then applying this transformation to any point `x` doesn't change that point at all."}
{"id": 783, "formal_statement": "theorem dummy {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=", "nl_statement": "The theorem states that for any two topological spaces \\(t\\) and \\(t'\\) over the same set \\(\\alpha\\), if \\(t\\) is less than or equal to \\(t'\\) (denoted by \\(t \\leq t'\\)), then the identity function (denoted by \\(id\\)) is continuous from \\(t\\) to \\(t'\\)."}
{"id": 784, "formal_statement": "theorem dummy {x y} : Chain' R [x, y] ‚Üî R x y :=", "nl_statement": "The statement `chain'_pair {x y} : Chain' R [x, y] ‚Üî R x y` is about sequences (in this case, a very short sequence consisting of two elements, `x` and `y`) and a relation `R` between elements of that sequence. Specifically, it's saying that a certain property, `Chain'`, holds for the two-element sequence `[x, y]` if and only if the relation `R` holds between `x` and `y`.\n\nIn more intuitive terms, you can think of `Chain'` as a property that sequences can have where each consecutive pair of elements in the sequence satisfies the relation `R`. So, for a two-element sequence `[x, y]`, this property is just checking whether `R x y` is true."}
{"id": 785, "formal_statement": "theorem dummy : cos x ^ 2 = 1 / 2 + cos (2 * x) / 2 :=", "nl_statement": "The theorem states that the square of the cosine function of any angle \\(x\\), denoted as \\(\\cos^2(x)\\), is equal to half the sum of 1 and the cosine of twice that angle, or in formulaic terms: \\[\\cos^2(x) = \\frac{1}{2} + \\frac{\\cos(2x)}{2}.\\]"}
{"id": 786, "formal_statement": "theorem dummy : ‚ãÇ‚ÇÄ (‚àÖ : ZFSet) = ‚àÖ :=", "nl_statement": "The theorem states that the intersection of all sets in an empty collection of sets is equal to the empty set."}
{"id": 787, "formal_statement": "theorem dummy {P Q : C} (f : P ‚ü∂ Q) : Function.Surjective f ‚Üí Epi f :=", "nl_statement": "The problem statement is about proving a property in category theory, specifically within the context of an abstract category `C`. It says that if you have two objects `P` and `Q` in `C`, and a morphism `f` from `P` to `Q` (denoted `P ‚ü∂ Q`), then if `f` is pseudo-surjective (meaning it maps to every element in the target in a certain generalized sense), it implies that `f` is an epimorphism (epi), which in category theory means that `f` is right-cancellable."}
{"id": 788, "formal_statement": "theorem dummy [RatCast Œ±] (q : ‚Ñö) : unop (q : Œ±·µê·µí·µñ) = q :=", "nl_statement": "The statement in question is a theorem regarding a type transformation in the context of mathematical operations within a certain algebraic structure, specifically related to rational numbers (`‚Ñö`) and a generic type `Œ±` that is assumed to have a rational cast (`RatCast`) defined for it. The theorem states that applying a unary operation (`unop`) to the rational number `q` cast into type `Œ±` in the multiplicative opposite (`Œ±·µê·µí·µñ`) or additive opposite context yields the same rational number `q`."}
{"id": 789, "formal_statement": "theorem dummy {s t : WSeq Œ±} (h : s ~ ∑ t) : tail s ~ ∑ tail t :=", "nl_statement": "The statement deals with weak sequences (`WSeq`) in a formal system, specifically addressing the concept of congruence (`~ ∑`) between sequences. The theorem named `tail_congr` asserts that if two weak sequences `s` and `t` of the same type `Œ±` are congruent (`s ~ ∑ t`), then the tails of these sequences (`tail s` and `tail t`) are also congruent."}
{"id": 790, "formal_statement": "theorem dummy (h : a ‚â§ 1) : a ‚â§ a‚Åª¬π :=", "nl_statement": "The statement to be proven is that for any element \\(a\\), if \\(a\\) is less than or equal to 1, then \\(a\\) is less than or equal to its inverse (\\(a^{-1}\\))."}
{"id": 791, "formal_statement": "theorem dummy (a b : Œ±) : Ioc a (pred b) = Ioo a b :=", "nl_statement": "The theorem named `Ioc_pred_right` concerns an interval operation in a mathematical context. It states that the half-open interval from `a` to the predecessor of `b` (`Ioc a (pred b)`) is equal to the open interval from `a` to `b` (`Ioo a b`). Here, `Œ±` represents a type for the elements `a` and `b`, implying that this theorem can be applied to any ordered set where the concepts of predecessor and intervals make sense."}
{"id": 792, "formal_statement": "theorem dummy : ‚àÄ x y : Bool, (x && y) ‚â§ x :=", "nl_statement": "The theorem named `and_le_left` states that for any two boolean values `x` and `y`, the logical AND of `x` and `y` is less than or equal to `x` itself. In the context of boolean algebra, \"less than or equal to\" means that if the AND of `x` and `y` is true, then `x` is also true. This theorem captures a basic property of the logical AND operation."}
{"id": 793, "formal_statement": "theorem dummy {a : WithTop Œ±} : a - ‚ä§ = 0 :=", "nl_statement": "The statement concerns an operation involving an element `a` from a special type `WithTop Œ±`, where `Œ±` is a generic type that could represent numbers or other elements. The operation in question is subtracting an element represented as `‚ä§` (often used to denote an element at the top of a type, possibly infinity or a maximal element in some contexts) from `a`. The theorem claims that for any `a` in `WithTop Œ±`, subtracting `‚ä§` from `a` results in `0`."}
{"id": 794, "formal_statement": "theorem dummy : (pure a : Filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : Filter Œ±) :=", "nl_statement": "The theorem in question states that when you subtract (`-·µ•`) one pure filter from another in a certain space (let's say, for simplicity, within the framework of functional analysis or a similar mathematical context), the result is equivalent to a pure filter formed by the subtraction of the elements these filters are based on. In this statement, `a` and `b` are elements of some sets (possibly different sets, denoted by `Œ≤` and `Œ±`), and the operation `-·µ•` represents the subtraction operation between these elements. A \"pure filter\" can be thought of as a mathematical construct that focuses or \"filters\" attention to a specific element or set of elements within a larger set or space."}
{"id": 795, "formal_statement": "theorem dummy (h : ¬¨a < b) : Ico a b = ‚àÖ :=", "nl_statement": "The theorem states that the half-open interval \\( Ico \\, a \\, b \\) (which includes all numbers greater than or equal to \\( a \\) and less than \\( b \\)) is empty if \\( a \\) is not less than \\( b \\)."}
{"id": 796, "formal_statement": "theorem dummy (f : A ‚Üí+[M] B) (x y : A) : f (x + y) = f x + f y :=", "nl_statement": "The statement provided is a theorem about a function \\(f\\) that is a type of linear transformation between two algebraic structures \\(A\\) and \\(B\\), where both \\(A\\) and \\(B\\) are equipped with an addition operation (\\(+\\)) and \\(f\\) respects this structure in a specific way. Specifically, the theorem states that for any elements \\(x\\) and \\(y\\) in \\(A\\), applying \\(f\\) to the sum of \\(x\\) and \\(y\\) (\\(x + y\\)) is the same as taking the sum of \\(f(x)\\) and \\(f(y)\\). This property is known as the distributive property over addition, indicating that \\(f\\) is a linear or additive map.\n\nIn natural language, this means the theorem's proof is essentially referencing the defining property of \\(f\\) as a distributive map over addition, which is taken as given or previously established. The reasoning is thus straightforward: the theorem is true by the very nature of \\(f\\)'s definition as adhering to this distributive property.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 797, "formal_statement": "theorem dummy : reverse (0 : R[X]) = 0 :=", "nl_statement": "The statement concerns the mathematical object \\(0 : R[X]\\), which represents the zero polynomial in the polynomial ring \\(R[X]\\) over some ring \\(R\\). The theorem `reverse_zero` asserts that reversing the zero polynomial yields the zero polynomial itself."}
{"id": 798, "formal_statement": "theorem dummy : (RatFunc.X : RatFunc K) ‚â† 0 :=", "nl_statement": "The statement concerns a mathematical object called `RatFunc.X` in the context of rational functions over a field `K`. It asserts that this particular rational function, denoted as `RatFunc.X`, is not equal to zero."}
{"id": 799, "formal_statement": "theorem dummy (x y : R) : star (star x * y) = star y * x :=", "nl_statement": "For any two elements \\(x\\) and \\(y\\) in a ring \\(R\\) with an involution operation denoted by \\(star\\), the operation \\(star(star(x) * y)\\) is equal to \\(star(y) * x\\)."}
{"id": 800, "formal_statement": "theorem dummy (f g : M‚ÇÅ ‚ÜíL[R‚ÇÅ] M‚ÇÅ) (x : M‚ÇÅ) : (f * g) x = f (g x) :=", "nl_statement": "The theorem states that for any two continuous linear maps \\(f\\) and \\(g\\) from a module \\(M‚ÇÅ\\) over a ring \\(R‚ÇÅ\\) to itself, the result of applying the composition of \\(f\\) and \\(g\\) to an element \\(x\\) in \\(M‚ÇÅ\\) is the same as applying \\(g\\) to \\(x\\) first and then applying \\(f\\) to the result. In other words, the operation of these two maps in sequence (composition) on an element \\(x\\) is equivalent to first applying \\(g\\) to \\(x\\) and then applying \\(f\\) to the outcome."}
{"id": 801, "formal_statement": "theorem dummy : (C (a - a') : MvPolynomial œÉ R) = C a - C a' :=", "nl_statement": "The theorem in question asserts that when you subtract two elements, \\(a'\\) from \\(a\\), and then apply the polynomial constant function \\(C\\) in the context of multivariate polynomials over a ring \\(R\\) with indeterminates indexed by \\(\\sigma\\), the result is the same as subtracting the constant polynomial of \\(a'\\) from the constant polynomial of \\(a\\). In other words, it states that the operation of subtraction commutes with the application of the constant function \\(C\\) in the realm of multivariate polynomials."}
{"id": 802, "formal_statement": "theorem dummy : h.IsClassified :=", "nl_statement": "The statement to be proved is that a given hypothesis `h` regarding a mathematical property, specifically being classified, holds true. This involves a situation where `h` represents a certain condition or set of conditions that must be satisfied for the theorem named `classified` to be considered proven."}
{"id": 803, "formal_statement": "theorem dummy {F G : HomotopyWith f‚ÇÄ f‚ÇÅ P} (h : ‚àÄ x, F x = G x) : F = G :=", "nl_statement": "The statement asserts that if two homotopies \\(F\\) and \\(G\\) (from \\(f_0\\) to \\(f_1\\) within a path \\(P\\)) are element-wise equal (that is, \\(F(x) = G(x)\\) for all \\(x\\)), then \\(F\\) and \\(G\\) are identical as homotopies. In simpler terms, if two continuous transformations from one function to another are the same at every point along a certain path, then these transformations are considered to be the same."}
{"id": 804, "formal_statement": "theorem dummy : (Inf.inf : Finset Œ± ‚Üí Finset Œ± ‚Üí Finset Œ±) = Inter.inter :=", "nl_statement": "The theorem states that the operation `inf` (infimum) on two finite sets within a given type `Œ±` is identical to the operation `inter` (intersection) on those same two sets. In simpler terms, it's saying that the process of finding the greatest lower bound (infimum) of two finite sets is the same as finding their common elements (intersection).\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 805, "formal_statement": "theorem dummy (m : ‚Ñï) (h : Irrational (m / x)) : Irrational x :=", "nl_statement": "The statement defines a theorem named `of_nat_div` concerning the irrationality of a number `x`. It states that if the division of an integer `m` by `x` (expressed as `m / x`) results in an irrational number, then `x` itself must also be irrational."}
{"id": 806, "formal_statement": "theorem dummy {f g : CauSeq _ abv} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) : ¬¨f * g ‚âà 0 := fun (this : LimZero (f * g - 0)) => by have hlz : LimZero (f * g) :=", "nl_statement": "The problem statement is a theorem concerning Cauchy sequences in the context of a field with an absolute value function (abv). Specifically, it asserts that if two Cauchy sequences `f` and `g` do not converge to zero, then their product `f * g` also does not converge to zero. This is a statement about the stability of non-zero limits under multiplication in the setting of Cauchy sequences."}
{"id": 807, "formal_statement": "theorem dummy (a : Œ±) : ‚åäa + 1‚åã = ‚åäa‚åã + 1 :=", "nl_statement": "The theorem states that the floor of the sum of a real number \\(a\\) and 1 is equal to the floor of \\(a\\) plus 1."}
{"id": 808, "formal_statement": "theorem dummy (i : ‚Ñ§) : lcm 0 i = 0 :=", "nl_statement": "The statement is about the least common multiple (lcm) of two integers, specifically when one of the integers is 0 and the other is any integer \\(i\\). The theorem states that the least common multiple of 0 and any integer \\(i\\) is 0."}
{"id": 809, "formal_statement": "theorem dummy (x y : M‚ÇÅ) : (-B‚ÇÅ) x y = -B‚ÇÅ x y :=", "nl_statement": "The theorem stated is about bilinear forms, specifically about the negation of a bilinear form. A bilinear form is a function that takes two arguments (in this case, `x` and `y` from a module `M‚ÇÅ`) and produces a scalar. The theorem states that if you apply the negation operation to a bilinear form `B‚ÇÅ` and then apply this negated form to the arguments `x` and `y`, you will get the same result as if you applied `B‚ÇÅ` to `x` and `y` and then negated the result."}
{"id": 810, "formal_statement": "theorem dummy [HasCokernel (f - g)] : HasCoequalizer f g := HasColimit.mk { cocone := coforkOfCokernelCofork _ isColimit :=", "nl_statement": "The statement to be translated from Lean4's syntax concerns the existence of a coequalizer in a certain mathematical context. Specifically, it asserts that if there exists a cokernel for the difference between two morphisms `f` and `g`, then there exists a coequalizer for `f` and `g`."}
{"id": 811, "formal_statement": "theorem dummy (h0 : a ‚â† 0) (hI : a ‚â† ‚àû) : b / a * a = b :=", "nl_statement": "The theorem states that if `a` is neither zero nor infinity, then dividing `b` by `a` and then multiplying by `a` will result in `b`."}
{"id": 812, "formal_statement": "theorem dummy (hf : QuotientMap f) : Continuous f :=", "nl_statement": "The statement is about a mathematical concept in the context of topology, specifically regarding continuous functions and quotient maps. It asserts that if a function \\(f\\) is a quotient map, then \\(f\\) is continuous."}
{"id": 813, "formal_statement": "theorem dummy : (‚ä• : SimpleGraph Œ±).IsNClique n s ‚Üî n ‚â§ 1 ‚àß s.card = n :=", "nl_statement": "The:\n theoremThe ` theoremis namedNC `liqueis_botNC_ifflique`_bot states_iff a` is about condition about a a simple simple graph graph. denoted Specifically, as ` it concerns the‚ä• empty graph` ( (denwhichoted represents by the empty ` graph in‚ä• this` context in) Lean and4 its), relationship and to whether being or an n not-cl this graphique. forms an The N statement-cl assertsique an equivalence with a: the set empty of vertices graph ` iss an`. n The-cl statementique of of a the set theorem ` is thats` the if empty graph and is only if an ` Nn-cl`ique is with less the than set or of equal vertices `s to ` if and only if1 ` and the cardinality (nthe ‚â§ number  of elements1`) of and the `s cardinality` is ( equalnumber to of ` elementsn)`.\n\n of# the set Proof `:\nThes` proof proceeds is through equal several to logical ` stepsn`.\n\n, translating# Proof the formal:\nThe Lean4 proof syntax follows to a a few logical natural steps language explanation,:\n\n translating1 the. Lean **4Starting syntax to Point a**: The natural theorem language begins explanation:\n by referencing1 another. ** theorem orRew definitionrite using `isNClique_iff`, ` andisNClique_iff`, which ` likely providesisC alique general_bot characterization of_iff when`: a** The subset first of vertices step in in the a proof graph involves forms an rewriting n the-cl statementique we. want It also to references prove using ` theis definitionsC oflique `_botis_iffNC`, which pertains specifically to thelique` and `isClique empty` graph for's the cli emptyques graph.\n\n.2 This. step ** simplRewifiesrite the Step theorem**: into The components proof that are employs a easier rewriting to step work with (`rw,`) specifically with focusing on these the references, conditions under suggesting that which the an conditions empty graph for being can an n be considered-cl aique clique in or the N empty-clique graph can.\n\n be2 understood. in ** termsRefinement of these with ` more generaland or_congr specific conditions_left`:.\n\n3**. Next, ** theRef proofinement uses and a Condition refinement Introduction**: step The to proof focus then on proving uses a the ` firstref part ofine the'` conjunction (` command,n which ‚â§ introduces  a1`) condition assuming (`and that_con thegr second_left part`) (` thats the.card argument = to n follow`) will holds apply. This to is the left done side by of using the the ` `andand_con` conjunctiongr in_left` the tactic theorem statement,. which This allows us means to the equivalence temporarily to assume one be part proved is of focused an on \" theand\" first part statement of is true the while conjunction (` wen prove the ‚â§  other1.\n\n`).\n\n3. **4.Introduction ** ofIntroduction ` ofr afl Specific` Case and**: conclusion with By using `card `rint_lero_one.sym rfl`,m the`: proof** introduces Finally a, specific by case introducing ` or assumptionrfl into` the ( reasoning.which This stands for is \" a formreflex ofivity pattern\", matching or a case principle analysis that, something where is ` equalr to itselffl),` the suggests proof reflexivity asserts or that a if specific case ` wheres.card both = sides of n`, an then it equation are the must be same the. In case that this ` context,n ‚â§ it might  mean1 considering`. This the scenario assertion where is backed the by the lemma cardinality of ` `cards`_le_one matches`, ` usedn in` its exactly symmetric form.\n\n5 to. conclude ** thatFinal the Step - cardinality Applying of a the Lemma set**: ` Thes proof` concludes by can only applying be the lemma one ` orcard zero,_le align_one.symingm with the`. requirement This lemma for, `n suggested ‚â§ by its  name1 and`.\n\nIn usage, essence likely, asserts the that proof the logically cardinal deducesity that being for equal the to empty one graph is equivalent to ( be ansymmetric N)-clique to with a the conditions set under of which vertices the ` emptys graph`, can it be is considered necessary an and n-cl sufficientique that under the the set ` theorem'ss` initial has statement.\n\n aIn cardinal essenceity that, the matches ` theoremn and`, its proof and establish that ` a precisen` condition is under which less the than empty graph or can equal to be one considered. to form This is because, in the context of the empty an n-cl graphique with respect, to a set of having vertices more `s than`: this is one vertex cannot possible form a exactly when proper ` clique duen to` the is absence  of1 or edges less., and the number of vertices in `s` matches `n`. The proof links general definitions and specific conditions through logical rewriting and refinement, concluding by applying a symmetry principle regarding cardinality.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 814, "formal_statement": "theorem dummy (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=", "nl_statement": "The theorem in question states that a subtype defined by a property \\(p\\) over a type \\(\\alpha\\) is empty if and only if, for every element \\(x\\) of type \\(\\alpha\\), the property \\(p(x)\\) does not hold. In other words, there are no elements \\(x\\) in \\(\\alpha\\) for which \\(p(x)\\) is true."}
{"id": 815, "formal_statement": "theorem dummy (a : Œ±) (f : Œ± ‚Üí‚ÇÄ G) : erase a (-f) = -erase a f :=", "nl_statement": "The theorem `erase_neg` concerns the operation of \"erasing\" a particular element `a` from a formal sum (a finite support function, `f`, mapping elements from a type `Œ±` to a group `G`) and then negating the result. It states that if you erase an element `a` from the negative of a formal sum `f`, this is equivalent to first erasing `a` from `f` and then taking the negative of the resulting formal sum."}
{"id": 816, "formal_statement": "theorem dummy : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) :=", "nl_statement": "The theorem named `nhds_bot_basis` concerns the topology of extended real numbers, specifically focusing on the behavior near the bottom element (`‚ä•`) of the extended real number line `EReal`. It asserts that the neighborhood filter at the bottom element (`ùìù(‚ä• : EReal)`) has a basis consisting of sets of the form `Iio x` (intervals open to the right, extending to minus infinity, up to but not including `x`), for any real number `x`. This means that every neighborhood of `‚ä•` in the extended real numbers can be represented by such intervals."}
{"id": 817, "formal_statement": "theorem dummy (x : M) : polar Q x x = 2 * Q x :=", "nl_statement": "The theorem named `polar_self` concerns a mathematical structure `M` and a function `Q` defined on elements of `M`. The statement asserts that for any element `x` in `M`, the value of a function called `polar` applied to `x` twice (`polar Q x x`) is equal to twice the value obtained by applying the function `Q` to `x` (`2 * Q x`)."}
{"id": 818, "formal_statement": "theorem dummy (f : C(X, Y)) (hf : P f) : HomotopicWith f f P :=", "nl_statement": "The theorem, labeled `refl`, concerns the concept of homotopy within a certain context, specifically dealing with continuous maps between two spaces, X and Y. The statement involves a function `f` that is a continuous map from X to Y (denoted as `C(X, Y)`) and is subject to a property `P`. The theorem asserts that `f` is homotopic to itself under the condition defined by `P`."}
{"id": 819, "formal_statement": "theorem dummy (n : ‚Ñï) : (n : HomogeneousLocalization ùíú x).val = n :=", "nl_statement": "The statement to be proven is that for any natural number \\( n \\), when \\( n \\) is considered as an element of a Homogeneous Localization of some algebraic structure \\( \\mathcal{A} \\) at some element \\( x \\), the value of \\( n \\) in this localization is just \\( n \\) itself.\n\nHomogeneous Localization here refers to a process or structure in algebra, particularly in the context of rings and modules, where we \"localize\" a given algebraic structure with respect to a particular element or subset, often to simplify or focus on certain properties."}
{"id": 820, "formal_statement": "theorem dummy [h : IsSemisimple R L] : center R L = ‚ä• :=", "nl_statement": "The theorem states that for a semisimple Lie algebra \\(L\\) over a ring \\(R\\), the center of \\(L\\) is trivial, i.e., it equals the bottom element \\(\\bot\\) (which usually denotes the {0} subspace in this context)."}
{"id": 821, "formal_statement": "theorem dummy (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) :=", "nl_statement": "The theorem `lift'_bot` states that if you have a monotone function `h`, then lifting the bottom (`‚ä•`) filter through `h` using the `lift'` operation results in the principal filter generated by applying `h` to the empty set.\n\nIn more detail, it deals with the concept of filters in mathematics, specifically in the context of order theory and topology. A filter on a set provides a way to talk about \"closeness\" or \"convergence\" without necessarily having a metric. The bottom (`‚ä•`) filter is the minimal filter, which, in most contexts, can be thought of as the empty set or the filter that converges to nothing. The `lift'` operation is a way to transform one filter into another using a function, and a principal filter (`ùìü`) generated by a set is the collection of all supersets of that set. The function `h` is monotone if it preserves the order (i.e., if `x ‚â§ y` then `h(x) ‚â§ h(y)` for all `x` and `y`)."}
{"id": 822, "formal_statement": "theorem dummy : toLex x < toLex (update x i a) ‚Üî x i < a :=", "nl_statement": "The statement concerns a function `toLex` that, given some context about `x`, `i`, and `a`, compares `x` with a version of itself where the `i`-th element has been updated to `a`. Specifically, it claims that `toLex x` is less than `toLex (update x i a)` if and only if the `i`-th element of `x` is less than `a`."}
{"id": 823, "formal_statement": "theorem dummy {i j} : (1 : Matrix n n Œ±) i j = if i = j then 1 else 0 :=", "nl_statement": "The statement is about a property of the identity matrix (denoted as \\(1\\) in the context) in the field of linear algebra, specifically for matrices of size \\(n \\times n\\) over a general type \\(\\alpha\\). The identity matrix is a special kind of matrix where all the diagonal elements are \\(1\\), and all off-diagonal elements are \\(0\\). The theorem `one_apply` asserts that for any given indices \\(i\\) and \\(j\\), the \\(i,j\\)-th element of the identity matrix is \\(1\\) if \\(i = j\\) (meaning, it's on the diagonal), and \\(0\\) otherwise (meaning, it's off the diagonal)."}
{"id": 824, "formal_statement": "theorem dummy (a b : Œ±) (m : ‚Ñ§) : toIocDiv hp a (m ‚Ä¢ p + b) = m + toIocDiv hp a b :=", "nl_statement": "The statement concerns a function `toIocDiv` applied to three arguments: a parameter `hp`, and two variables `a` and `(m ‚Ä¢ p + b)`, where `a` and `b` are of type `Œ±` (which might represent some mathematical objects), `m` is an integer (`‚Ñ§`), `p` is implicitly understood from the context, and `‚Ä¢` represents scalar multiplication. The theorem claims that applying the `toIocDiv` function to these inputs yields a result of `m + toIocDiv hp a b`, effectively showing how the function linearly distributes over a combination of scalar multiplication and addition."}
{"id": 825, "formal_statement": "theorem dummy {Œπ} [Unique Œπ] (f : Œπ ‚Üí Ordinal) : sup f = f default :=", "nl_statement": "This theorem states that for any type `Œπ` which is unique (meaning it has exactly one element), and a function `f` from `Œπ` to the ordinal numbers, the supremum (or the least upper bound) of the set of ordinals obtained by applying `f` to the elements of `Œπ` is equal to the value of `f` applied to the default (and only) element of `Œπ`."}
{"id": 826, "formal_statement": "theorem dummy [LinearOrderedRing Œ±] (h : Odd n) : 0 < ‚àë i in range n, x ^ i :=", "nl_statement": "The statement concerns a scenario within a linear ordered ring (a mathematical structure that combines the properties of rings and linear orders, allowing for the consideration of ordering of elements). The theorem asserts that for any odd natural number \\(n\\), the sum of the geometric series \\(\\sum_{i=0}^{n-1} x^i\\) is positive, given any element \\(x\\) of the ring."}
{"id": 827, "formal_statement": "theorem dummy {f g : Œ± ‚ÜíCo Œ≤} (h : ‚àÄ a, f a = g a) : f = g :=", "nl_statement": "The theorem states that if two continuous order homomorphisms \\( f \\) and \\( g \\), from type \\( \\alpha \\) to \\( \\beta \\), are equal at every point \\( a \\) in their domain, then the two functions \\( f \\) and \\( g \\) are identical."}
{"id": 828, "formal_statement": "theorem dummy {s : Set (Sigma œÉ)} : IsOpen s ‚Üî ‚àÄ i, IsOpen (Sigma.mk i ‚Åª¬π' s) :=", "nl_statement": "The statement concerns the property of openness of a set within the context of topology, specifically relating to a sigma type (or dependent sum type). The sigma type combines elements from possibly different types, indexed by another type. The statement asserts a condition for a set `s` of sigma type elements to be considered open. It proposes that a set `s` is open if and only if for every index `i`, the preimage of `s` under the function that constructs sigma type elements (`Sigma.mk i`) is open. This essentially translates to the criterion that for a set of sigma type elements to be open, it must be the case that for each possible index, the set of elements that, when combined with that index, fall into `s`, must also be an open set."}
{"id": 829, "formal_statement": "theorem dummy : Function.Injective natPred :=", "nl_statement": "The theorem `natPred_injective` asserts that the function `natPred` (which stands for \"natural predecessor\") is injective.\n\nIn mathematics, a function \\(f: A \\rightarrow B\\) is said to be injective (or one-to-one) if it assigns distinct outputs to distinct inputs. That is, whenever \\(f(x) = f(y)\\), it must be the case that \\(x = y\\).\n\nThe `natPred` function can be understood as a function that takes a natural number \\(n\\) (excluding 0, since 0 has no predecessor in the natural numbers) and returns its predecessor \\(n-1\\). The statement of the theorem, therefore, claims that if two natural numbers have the same predecessor, then they must be the same number."}
{"id": 830, "formal_statement": "theorem dummy (f : R[X]) (N : ‚Ñï) : reflect N (-f) = -reflect N f :=", "nl_statement": "The lemma states that for any polynomial \\(f\\) over a ring \\(R\\) and a non-negative integer \\(N\\), reflecting \\(f\\) across the \\(N\\)-th term and then negating it is the same as first negating \\(f\\) and then reflecting it across the \\(N\\)-th term. The reflection of a polynomial \\(f\\) across the \\(N\\)-th term, denoted as `reflect N f`, is a transformation that involves reordering the coefficients of \\(f\\) in a manner that depends on \\(N\\)."}
{"id": 831, "formal_statement": "theorem dummy (r : Œ± ‚Üí Œ± ‚Üí Prop) [IsTrans Œ± r] : Transitive r :=", "nl_statement": "The problem statement provided defines a theorem named `transitive_of_trans` regarding a binary relation `r` on a type `Œ±`. This theorem asserts that if `r` is a transitive relation (as per some context or condition provided by `[IsTrans Œ± r]`), then the function `Transitive r` is satisfied. In other words, the theorem states that given a binary relation `r` on elements of type `Œ±` which is transitive, the property of being transitive can be confirmed or instantiated for `r`."}
{"id": 832, "formal_statement": "theorem dummy : Function.Injective (Coe.coe : MvPolynomial œÉ R ‚Üí MvPowerSeries œÉ R) :=", "nl_statement": "The theorem `coe_injective` states that the coercion function from `MvPolynomial œÉ R` to `MvPowerSeries œÉ R` is injective. In other words, if two multivariate polynomials are coerced into multivariate power series and the results are the same, then the original polynomials must be identical."}
{"id": 833, "formal_statement": "theorem dummy (f : sSupHom Œ≤ Œ≥) (g : sSupHom Œ± Œ≤) : ‚áë(f.comp g) = f ‚àò g :=", "nl_statement": "The statement you're referring to is a theorem in the context of category theory or algebra, specifically dealing with a kind of structure called `sSupHom`, which seems to represent some form of homomorphisms (structure-preserving maps) between sup-semilattices or similar algebraic structures, denoted by `Œ±`, `Œ≤`, and `Œ≥`. The theorem, named `coe_comp`, asserts that the composition of two such homomorphisms, `f` from `Œ≤` to `Œ≥` and `g` from `Œ±` to `Œ≤`, when applied (coerced to a function application via `‚áë`) is equivalent to the composition of the functions represented by `f` and `g` directly (`f ‚àò g`)."}
{"id": 834, "formal_statement": "theorem dummy (a : Œ±) (s t) : append (cons a s) t = cons a (append s t) :=", "nl_statement": "The theorem named \"cons_append\" is about lists in a general context (where the type of list elements is denoted by Œ±). It states that if you have an element 'a' and two lists 's' and 't', then appending the list formed by adding 'a' at the beginning of 's' (denoted as 'cons a s') to the list 't' is the same as adding 'a' at the beginning of the list obtained by appending 's' and 't'. In simpler terms, it's asserting the consistency of the append and cons operations on lists."}
{"id": 835, "formal_statement": "theorem dummy (h : a = c * b‚Åª¬π) : a * b = c :=", "nl_statement": "The statement is about a property of multiplication in the context of algebra. Specifically, it asserts that if a certain relationship involving multiplication and inversion holds between three elements (let's call them a, b, and c), then a particular equality involving these elements is true. The precise statement is: If a equals c times the inverse of b (a = c * b‚Åª¬π), then the product of a and b equals c (a * b = c)."}
{"id": 836, "formal_statement": "theorem dummy : not ‚â† id :=", "nl_statement": "The lemma states that the negation function (`not`) is not equal to the identity function (`id`)."}
{"id": 837, "formal_statement": "theorem dummy (x : t Œ±) : traverse pure x = (pure x : F (t Œ±)) :=", "nl_statement": "The lemma states that for a given type `t` with a traversable structure and a type `Œ±`, applying the `traverse` function with the `pure` function from an applicative functor `F` to an object `x` of type `t Œ±` is equivalent to applying the `pure` function to `x` and then lifting the result to the functor `F` of type `t Œ±`."}
{"id": 838, "formal_statement": "theorem dummy (s : CommSq f g h i) : s.cone.snd = g :=", "nl_statement": "This statement is about a specific setup in category theory, involving a commutative square (`CommSq`). Given functions `f`, `g`, `h`, and `i` that form this square, the theorem concerns the second element (`snd`) of a cone constructed from the square. Specifically, it asserts that the second element of the cone is equal to the function `g`.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 839, "formal_statement": "theorem dummy : (‚ä• : Seminorm ùïú E) = 0 :=", "nl_statement": "The statement is about a seminorm in a mathematical context. A seminorm is a function that assigns a nonnegative real number to each element in a vector space, capturing the \"length\" or \"magnitude\" of vectors in a way that satisfies certain conditions similar to a norm but without the requirement that only the zero vector is assigned a magnitude of zero. The symbol \"‚ä•\" represents the bottom element in the lattice of seminorms, which is the smallest seminorm according to the ordering of seminorms. This theorem states that this bottom seminorm is equal to the zero function, which assigns the value 0 to every vector in the space."}
{"id": 840, "formal_statement": "theorem dummy {x : OnePoint X} : x ‚â† ‚àû ‚Üî ‚àÉ y : X, (y : OnePoint X) = x :=", "nl_statement": "The statement to be translated from the Lean4 theorem prover language involves a type `X` and a type `OnePoint X`, which extends `X` by adding an additional element denoted as `‚àû` (infinity). The theorem named `ne_infty_iff_exists` asserts a condition about the elements of `OnePoint X`, specifically concerning their relationship to this added element `‚àû`. It states that an element `x` of `OnePoint X` is not equal to `‚àû` if and only if there exists an element `y` in the original type `X` such that when `y` is considered as an element of `OnePoint X`, it is equal to `x`."}
{"id": 841, "formal_statement": "theorem dummy (a : Associates Œ±) : Associates.mk a.out = a :=", "nl_statement": "The statement is about an entity called `Associates Œ±`, which is a type or category in a mathematical or computational context related to the Lean4 theorem prover. The theorem, named `mk_out`, asserts that when you take an element `a` of type `Associates Œ±` and apply a certain operation `mk` to `a.out`, you get back the original element `a`."}
{"id": 842, "formal_statement": "theorem dummy : p ‚â† 0 :=", "nl_statement": "The theorem being discussed asserts that a certain number `p` is not equal to zero. This statement is foundational in many areas of mathematics, where ensuring a value is not zero is crucial for definitions, proofs, and operations that involve division or ratios."}
{"id": 843, "formal_statement": "theorem dummy (s : Multiset Œ±) : ‚àÄ t u : Multiset Œ≤, s √óÀ¢ (t + u) = s √óÀ¢ t + s √óÀ¢ u :=", "nl_statement": "The statement concerns the operation of taking the product of a multiset \\(s\\) with the sum of two other multisets \\(t\\) and \\(u\\). Specifically, it asserts that the product of \\(s\\) with the sum of \\(t\\) and \\(u\\) (\\(s \\times (t + u)\\)) is equal to the sum of the product of \\(s\\) with \\(t\\) and the product of \\(s\\) with \\(u\\) (\\(s \\times t + s \\times u\\))."}
{"id": 844, "formal_statement": "theorem dummy {x y : ‚Ñï} (hp : x * x - d a1 * y * y = 1) : ‚àÉ n, x = xn a1 n ‚àß y = yn a1 n := have : (1 : ‚Ñ§‚àö(d a1)) ‚â§ ‚ü®x, y‚ü© := match x, hp with | 0, (hp : 0 - _ = 1) => by rw [zero_tsub] at hp; contradiction | x + 1, _hp => Zsqrtd.le_of_le_le (Int.ofNat_le_ofNat_of_le <| Nat.succ_pos x) (Int.ofNat_zero_le _) let ‚ü®m, e‚ü© :=", "nl_statement": "The given theorem states that for any non-negative integers \\(x\\) and \\(y\\), if \\(x^2 - d \\cdot a_1 \\cdot y^2 = 1\\) for some given \\(d\\) and \\(a_1\\), then there exists an integer \\(n\\) such that \\(x\\) and \\(y\\) can be represented as \\(xn(a_1, n)\\) and \\(yn(a_1, n)\\), respectively. These functions \\(xn\\) and \\(yn\\) presumably generate sequences of integers related to the Pell equation under certain conditions determined by \\(a_1\\)."}
{"id": 845, "formal_statement": "theorem dummy {x : A} (hx : x ‚àà S) (r : R) : r ‚Ä¢ x ‚àà S :=", "nl_statement": "The theorem states that if you have an element \\(x\\) belonging to a set \\(S\\), and if you scale \\(x\\) by a scalar \\(r\\) (denoted as \\(r \\cdot x\\) or \\(r \\) ‚Äúsmul‚Äù \\( x\\)), then this scaled element also belongs to the set \\(S\\). This is a property often required in the context of algebraic structures like vector spaces, modules, or algebras, where \\(S\\) can represent a substructure (like a subspace or subalgebra) and \\(R\\) represents the scalars over which the structure is defined."}
{"id": 846, "formal_statement": "theorem dummy (v : V) (hv : v ‚â† 0) : IsAtom (span K {v} : Submodule K V) :=", "nl_statement": "The statement concerns the mathematical concept of atomic submodules in the context of linear algebra over a field \\(K\\) and vector space \\(V\\). Specifically, it declares that the span of a non-zero vector \\(v\\) in \\(V\\) forms an \"atom\" in the lattice of submodules of \\(V\\). In simpler terms, it asserts that if you have a non-zero vector \\(v\\), the collection of all possible linear combinations of \\(v\\) (which is called the span of \\(v\\)) is indivisible in a certain sense, except by trivial submodules."}
{"id": 847, "formal_statement": "theorem dummy [LE Œ±] [LE Œ≤] {a : Œ±} {b : Œ≤} : ¬¨inl b ‚â§ inr a :=", "nl_statement": "This theorem states that in a certain context involving types and ordering, an element of type Œ± cannot be less than or equal to an element of type Œ≤ when these elements are encapsulated within two different constructors, specifically `inl` for type Œ≤ and `inr` for type Œ±. Here, `[LE Œ±]` and `[LE Œ≤]` signify that the types Œ± and Œ≤ are equipped with a less-than-or-equal-to relation, making it meaningful to compare elements of each type under this relation. The statement `{a : Œ±} {b : Œ≤}` introduces specific elements `a` of type Œ± and `b` of type Œ≤. The key part of the theorem, `¬¨inl b ‚â§ inr a`, asserts that it's not possible for `inl b` (b encapsulated by the constructor `inl`, making it a value of a sum type) to be less than or equal to `inr a` (a encapsulated by the constructor `inr`)."}
{"id": 848, "formal_statement": "theorem dummy {a : Œ±} (h : a ‚â† 0) : ContinuousAt SignType.sign a :=", "nl_statement": "The statement is about the continuity of the sign function at a point \\(a\\) that is not zero. Specifically, it asserts that if \\(a\\) is a nonzero value, then the sign function is continuous at \\(a\\)."}
{"id": 849, "formal_statement": "theorem dummy (f : CocompactMap Œ± Œ≤) : (CocompactMap.id _).comp f = f :=", "nl_statement": "The theorem being stated here is about the composition of a certain type of map, known as a \"CocompactMap,\" in some context (likely in topology or a related field). Specifically, the theorem states that if you take a cocompact map `f` from some space `Œ±` to another space `Œ≤`, and compose it with the identity cocompact map on `Œ±`, the result is just the original map `f`."}
{"id": 850, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ±) (x : Œ±) : IsPeriodicPt f (minimalPeriod f x) x :=", "nl_statement": "The theorem states that for any function `f` from a set `Œ±` to itself and any element `x` in `Œ±`, `x` is a periodic point of `f` with the period being the minimal period of `x` under `f`."}
{"id": 851, "formal_statement": "theorem dummy (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=", "nl_statement": "The statement concerns a mathematical property related to the powers of an element \\(x\\) in a group. Specifically, it addresses the scenario where the order of \\(x\\) is zero. The theorem states that for any natural numbers \\(n\\) and \\(m\\), \\(x\\) raised to the power of \\(n\\) equals \\(x\\) raised to the power of \\(m\\) if and only if \\(n\\) equals \\(m\\), given that the order of \\(x\\) is zero."}
{"id": 852, "formal_statement": "theorem dummy {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=", "nl_statement": "The statement involves category theory within the context of the Lean4 theorem prover. The theorem asserts that for any two objects \\(X\\) and \\(Y\\) in the opposite category \\(C^{op}\\), given an isomorphism \\(f: X \\to Y\\), the operation of first taking the opposite (unop) of \\(f\\) and then taking the opposite (op) of that result yields \\(f\\) itself. In simpler terms, if you reverse the direction of an isomorphism in the opposite category and then reverse it back, you end up with the original isomorphism."}
{"id": 853, "formal_statement": "theorem dummy ‚¶Éi j : ‚Ñï‚¶Ñ (hij : i ‚â§ j) : approx f i ‚â§ approx f j :=", "nl_statement": "The statement concerns a function `approx` that takes two arguments: a function `f` and a natural number (`‚Ñï`). The theorem, named `approx_mono`, asserts that for any two natural numbers `i` and `j`, if `i` is less than or equal to `j`, then `approx f i` is less than or equal to `approx f j`. This essentially claims that `approx` is a monotonically increasing function with respect to its second argument when the first argument `f` is held constant."}
{"id": 854, "formal_statement": "theorem dummy (a : Œ±) [Invertible a] : ‚Öü a = a‚Åª¬π :=", "nl_statement": "The statement asserts that for any element \\(a\\) in a set with an invertible structure (meaning \\(a\\) has an inverse under some operation), the \"inverse of operation\" applied to \\(a\\) (denoted as \\(‚Öü a\\)) is equal to the traditional mathematical inverse of \\(a\\) (denoted as \\(a‚Åª¬π\\))."}
{"id": 855, "formal_statement": "theorem dummy {x : R} (hx : x ‚àà M) : mk' S x ‚ü®x, hx‚ü© = 1 :=", "nl_statement": "The theorem stated in the Lean4 syntax concerns the concept of localization in algebra, specifically within the context of a ring \\(R\\) and a subset \\(M\\) of \\(R\\). The theorem is about the function `mk'`, which maps an element \\(x\\) from \\(R\\), that is also a member of the subset \\(M\\), to an element in the localization of \\(R\\) with respect to \\(S\\), a multiplicative subset of \\(R\\). The theorem asserts that for any element \\(x\\) in \\(M\\), the result of this mapping operation, when applied to \\(x\\) and a proof of \\(x\\) being in \\(M\\), equals 1 in the localized ring."}
{"id": 856, "formal_statement": "theorem dummy : m '' (s * t) = m '' s * m '' t :=", "nl_statement": "This theorem states that the image of the product of two sets under a mapping `m` is equal to the product of the images of these two sets under the same mapping. In more familiar terms, if you have two sets `s` and `t`, and you apply a function `m` to each element in the product set `s * t`, this is the same as first applying `m` to each element in `s` and `t` separately and then taking the product of these two images."}
{"id": 857, "formal_statement": "theorem dummy {i} (h : i = i) : cast R M h = LinearEquiv.refl _ _ :=", "nl_statement": "The statement presents a theorem named `cast_refl`, which concerns the scenario where a certain type of casting operation, specifically `cast R M h`, is equivalent to the identity operation on linear equivalences, denoted as `LinearEquiv.refl _ _`. Here, `i` is a parameter or variable, and `h` is a hypothesis stating that `i` equals itself (`i = i`). The theorem asserts that under these conditions, performing the cast operation with the hypothesis `h` results in an operation that is essentially doing nothing, i.e., it's equivalent to the identity linear equivalence."}
{"id": 858, "formal_statement": "theorem dummy : ‚àÄ l : List Œ±, l √óÀ¢ (@nil Œ≤) = [] | [] => rfl | _ :: l => by simp [product_cons, product_nil l] :=", "nl_statement": "The theorem named `product_nil` asserts that for any list of elements of type `Œ±`, when this list is paired (in the sense of forming the Cartesian product) with an empty list of elements of type `Œ≤`, the result is an empty list."}
{"id": 859, "formal_statement": "theorem dummy (x : X) {r : ‚Ñù‚â•0‚àû} (hr : r ‚â† 0) : 0 < Œº (ball x r) :=", "nl_statement": "The theorem states that for any point \\(x\\) in a space \\(X\\) and for any radius \\(r\\) greater than zero (denoted as \\(r \\neq 0\\) and \\(r\\) is a non-negative extended real number), the measure (denoted as \\(\\mu\\)) of the ball centered at \\(x\\) with radius \\(r\\) is greater than zero. In simpler terms, if you take a ball (a round shape in space) with any positive radius around a point, the space it covers is always more than zero."}
{"id": 860, "formal_statement": "theorem dummy {u : Œπ ‚Üí UniformSpace Œ≥} : ùí∞(Œ±, Œ≥, (‚®Ö i, u i)) = ‚®Ö i, ùí∞(Œ±, Œ≥, u i) :=", "nl_statement": "The theorem states that for any family of uniform spaces \\(u\\) indexed by \\(\\iota\\) over a fixed set \\(\\gamma\\), the uniformity filter of the infimum of these uniform spaces, when considered as a function space from \\(\\alpha\\) to \\(\\gamma\\), is equal to the infimum of the uniformity filters of each uniform space in the family, again considered as function spaces from \\(\\alpha\\) to \\(\\gamma\\). In formal terms, if \\(\\mathcal{U}(\\alpha, \\gamma, (\\inf_i u_i))\\) denotes the uniformity filter of the function space from \\(\\alpha\\) to \\(\\gamma\\) with the uniform space being the infimum of the \\(u_i\\), then this is equal to the infimum of the uniformity filters of the function spaces from \\(\\alpha\\) to \\(\\gamma\\) with each uniform space \\(u_i\\), i.e., \\(\\inf_i \\mathcal{U}(\\alpha, \\gamma, u_i)\\)."}
{"id": 861, "formal_statement": "theorem dummy (Œ± : X ‚âÖ Y) {f : Y ‚ü∂ X} : f ‚â´ Œ±.hom = ùüô Y ‚Üî f = Œ±.inv :=", "nl_statement": "The statement concerns a scenario in the context of category theory, specifically dealing with isomorphisms between categories. It asserts that for any isomorphism `Œ±` from category `X` to category `Y`, and for a morphism `f` from `Y` to `X`, the composition of `f` with the homomorphism of `Œ±` (denoted as `f ‚â´ Œ±.hom`) is equal to the identity morphism on `Y` (denoted as `ùüô Y`) if and only if `f` is equal to the inverse of `Œ±` (denoted as `Œ±.inv`)."}
{"id": 862, "formal_statement": "theorem dummy : f.comp id = f :=", "nl_statement": "The theorem states that the composition of a function \\(f\\) with the identity function (\\(id\\)) is equal to the function \\(f\\) itself. In mathematical terms, for any function \\(f\\), applying \\(f\\) after applying the identity function to any argument gives the same result as just applying \\(f\\) to that argument."}
{"id": 863, "formal_statement": "theorem dummy : encode false = 0 :=", "nl_statement": "The statement at hand is that the encoding of the boolean value `false` results in the numeral `0`. This is presented within the context of the Lean4 theorem prover, which is a tool for creating and verifying mathematical proofs and statements formally."}
{"id": 864, "formal_statement": "theorem dummy (R) [CommRing R] [IsDomain R] [Finite R] : IsField R :=", "nl_statement": "This theorem states that if \\(R\\) is a commutative ring (CommRing \\(R\\)) with no zero divisors (IsDomain \\(R\\)) and is finite (Finite \\(R\\)), then \\(R\\) is a field (IsField \\(R\\))."}
{"id": 865, "formal_statement": "theorem dummy (A : E ‚Üí‚Çó[ùïú] E) : star A = LinearMap.adjoint A :=", "nl_statement": "The theorem states that for a given linear map \\(A\\) from a vector space \\(E\\) over a field \\(\\mathbb{K}\\) to itself, the operation \\(star\\) applied to \\(A\\) is equal to the adjoint of \\(A\\)."}
{"id": 866, "formal_statement": "theorem dummy {x : R} (hx : x ‚àà I) (n : ‚Ñï) : x ^ n ‚àà I ^ n :=", "nl_statement": "The statement pertains to an element \\(x\\) belonging to a structure \\(I\\), often referred to as an ideal in the context of ring theory, and a natural number \\(n\\). The theorem asserts that if \\(x\\) is an element of \\(I\\), then \\(x\\) raised to the power \\(n\\) also belongs to the power of \\(I\\) raised to \\(n\\)."}
{"id": 867, "formal_statement": "theorem dummy : ((¬∑ ‚äÜ ¬∑) ‚áí (¬∑ ‚äÜ ¬∑)) r.image r.image :=", "nl_statement": "The theorem states that if a relation \\( r \\) has its image within a set, then applying the image operation under \\( r \\) to this set results in a subset that adheres to the same condition. In simpler terms, if you have a set and you transform all elements of this set through a relation \\( r \\), the transformed elements (the image of the set under \\( r \\)) will still form a subset under the same transformation."}
{"id": 868, "formal_statement": "theorem dummy (f : E ‚ÜíSL[œÉ‚ÇÅ‚ÇÉ] F ‚ÜíSL[œÉ‚ÇÇ‚ÇÉ] G) : f.flip.flip = f :=", "nl_statement": "The given statement is a theorem regarding the behavior of a certain operation, `flip`, applied to a continuous linear map `f`. Specifically, the map `f` is from a space `E` to a space of continuous linear maps from `F` to `G`. The spaces `E`, `F`, and `G` can be thought of as vector spaces, and the maps are linear transformations that are also continuous with respect to certain topologies (not explicitly mentioned, but implied by the notation `‚ÜíSL[œÉ‚ÇÅ‚ÇÉ]` and `‚ÜíSL[œÉ‚ÇÇ‚ÇÉ]`). The operation `flip` reverses the order in which `f` takes its two arguments from spaces `E` and `F`. The theorem states that if you apply the `flip` operation twice to a continuous linear map `f`, you get back the original map `f`."}
{"id": 869, "formal_statement": "theorem dummy : ‚àÄ {n : ‚Ñ§}, n.toNat = 0 ‚Üî n ‚â§ 0 | (n : ‚Ñï) => calc _ ‚Üî n = 0 := ‚ü®(toNat_coe_nat n).symm.trans, (toNat_coe_nat n).trans‚ü© _ ‚Üî _ :=", "nl_statement": "The statement in question is a theorem regarding the conversion of integers (‚Ñ§) to natural numbers (‚Ñï) using a function called `toNat`. Specifically, the theorem states that for any integer `n`, `n.toNat = 0` if and only if `n ‚â§ 0`. This means that the only integers whose natural number representation is 0 are those that are less than or equal to 0."}
{"id": 870, "formal_statement": "theorem dummy : (s * t).Nonempty ‚Üî s.Nonempty ‚àß t.Nonempty :=", "nl_statement": "The statement concerns the non-emptiness of the product of two sets, \\(s\\) and \\(t\\). It asserts that the product set \\(s * t\\) is non-empty if and only if both sets \\(s\\) and \\(t\\) are non-empty."}
{"id": 871, "formal_statement": "theorem dummy (x : M) : refl L M x = x :=", "nl_statement": "The theorem named `refl_apply` is about an operation called `refl` in the context of a language `L` and a model `M` with an element `x`. It states that applying the `refl` operation to `x` results in `x` itself."}
{"id": 872, "formal_statement": "theorem dummy {n : ‚Ñï} (hn : 2 < n) : Even n.totient :=", "nl_statement": "The theorem states that for any natural number \\( n \\) greater than 2, the Euler totient function of \\( n \\) (denoted \\( \\varphi(n) \\)) is an even number."}
{"id": 873, "formal_statement": "theorem dummy (f : M ‚Üí‚Çó‚ÅÖR,L‚ÅÜ N) (m : M) : (-f) m = -f m :=", "nl_statement": "The statement concerns a linear map \\(f\\) from a module \\(M\\) over a ring \\(R\\) to another module \\(N\\), within the context of a Lie algebra \\(L\\). Specifically, it asserts that applying the negation of \\(f\\) to an element \\(m\\) of \\(M\\) is equivalent to applying \\(f\\) to \\(m\\) and then negating the result. This is expressed in mathematical terms as \\((-f) m = -f m\\)."}
{"id": 874, "formal_statement": "theorem dummy (n : ‚Ñï) (m : M) : (‚Üën : Module.End R M) m = n ‚Ä¢ m :=", "nl_statement": "The given statement is a mathematical theorem related to module endomorphisms in the context of ring and module theory, specifically within the Lean4 theorem prover environment. It asserts that casting a natural number `n` to an endomorphism of a module `M` over a ring `R` and applying this endomorphism to an element `m` of `M` is equivalent to scaling `m` by `n` within the module. In simpler terms, it states that if you take a natural number and treat it as an endomorphism (a linear transformation from a module to itself), then applying this transformation to a module element is the same as multiplying the element by the natural number in the module's context."}
{"id": 875, "formal_statement": "theorem dummy (h : IsPushout f g inl inr) : h.cocone.inr = inr :=", "nl_statement": "This problem statement involves a mathematical structure known as a \"pushout\" in category theory, a branch of mathematics that deals with abstract structures and their relationships. Specifically, the theorem named `cocone_inr` is concerned with a property of a pushout. \n\nIn category theory, a pushout is a way to combine two morphisms (functions) that have a common domain, creating a new object along with two new morphisms, ensuring that a certain universal property is satisfied. The pushout itself can be represented as a \"cocone\" over the initial pair of morphisms. \n\nGiven:\n- `f` and `g` are two morphisms with a common domain.\n- `inl` and `inr` are morphisms from the domain of `f` and `g` to another object, which together with this object form a cocone.\n- `h` is a hypothesis stating that this configuration is a pushout, meaning it satisfies the universal property of pushouts with respect to `f`, `g`, `inl`, and `inr`.\n\nThe theorem states that if `h` is indeed a pushout, then the `inr` morphism from the pushout cocone (the specific arrangement of objects and morphisms that satisfies the pushout condition) is exactly `inr`."}
{"id": 876, "formal_statement": "theorem dummy {c} (h : IsLimit c) : IsSuccLimit c :=", "nl_statement": "The statement concerns a property of a mathematical object identified as `c`, within a context that deals with cardinal numbers or similar abstract constructs. Specifically, it claims that if `c` is a limit (as defined by some predicate `IsLimit`), then it also satisfies the condition of being a \"successor limit\" (denoted here as `IsSuccLimit`)."}
{"id": 877, "formal_statement": "theorem dummy (cf cg : Code) (a : ‚Ñï) : eval (prec cf cg) (Nat.pair a 0) = eval cf a :=", "nl_statement": "The statement in question asserts that for any two pieces of code `cf` and `cg`, and any natural number `a`, evaluating the `prec` function (which likely represents a form of primitive recursion in this context) with `cf` and `cg` on the input `(a, 0)` (where `Nat.pair a 0` constructs a pair from `a` and `0`) yields the same result as just evaluating `cf` on `a`. This encapsulates a fundamental property of primitive recursion in the context of the computational model being described: when the recursion counter is zero, the computation should reduce to an initial computation not involving recursion."}
{"id": 878, "formal_statement": "theorem dummy (n : ‚Ñ§) : ((n‚Åª¬π : ‚Ñö) : Œ±) = (n : Œ±)‚Åª¬π :=", "nl_statement": "The statement given is a mathematical theorem that concerns the casting (or conversion) of numbers between different types, specifically from integers (`‚Ñ§`) to rational numbers (`‚Ñö`), and then to an arbitrary numeric type `Œ±`. It asserts that converting the inverse of an integer `n` to type `Œ±` is the same as converting `n` to type `Œ±` and then taking the inverse in `Œ±`."}
{"id": 879, "formal_statement": "theorem dummy : (p - q).eval‚ÇÇ f g = p.eval‚ÇÇ f g - q.eval‚ÇÇ f g :=", "nl_statement": "The statement concerns the evaluation of the subtraction of two polynomials, \\(p - q\\), under a certain evaluation function, `eval‚ÇÇ`. The function `eval‚ÇÇ` takes a polynomial and two parameters, \\(f\\) and \\(g\\), to produce a result. The lemma asserts that evaluating the subtraction of two polynomials \\(p\\) and \\(q\\) with `eval‚ÇÇ` using parameters \\(f\\) and \\(g\\) is equivalent to subtracting the evaluations of \\(p\\) and \\(q\\) individually with the same parameters."}
{"id": 880, "formal_statement": "theorem dummy (hf : Isometry f) : f.NormNoninc :=", "nl_statement": "The theorem states that if a function \\(f\\) is an isometry, then it is also norm non-increasing. This means that for all vectors \\(v\\), the norm (or length) of \\(f(v)\\) is less than or equal to the norm of \\(v\\)."}
{"id": 881, "formal_statement": "theorem dummy {o p : Part Œ±} (H : ‚àÄ a, a ‚àà o ‚Üî a ‚àà p) : o = p :=", "nl_statement": "The theorem we are considering states that for any two parts `o` and `p` of a certain type `Œ±`, if for every element `a` it holds that `a` is an element of `o` if and only if `a` is an element of `p`, then `o` and `p` are equal. This is a statement about the extensionality of parts, which means that the identity of a part is determined entirely by its elements."}
{"id": 882, "formal_statement": "theorem dummy {I : Ideal R} (hI : I.IsMaximal) : I = maximalIdeal R :=", "nl_statement": "The statement concerns a property of ideals in a ring \\(R\\). Specifically, it asserts that if \\(I\\) is an ideal of \\(R\\) that is also maximal, then \\(I\\) is equal to the unique maximal ideal of \\(R\\), assuming \\(R\\) is a ring where such a unique maximal ideal exists."}
{"id": 883, "formal_statement": "theorem dummy (x : Icc (0 : Œ±) 1) : (x : Œ±) ‚â§ 1 :=", "nl_statement": "The statement given is a theorem regarding an element \\(x\\) of the set \\(Icc(0, 1)\\) in some ordered type \\(\\alpha\\). The set \\(Icc(0, 1)\\) represents the closed interval \\([0, 1]\\), meaning it includes all numbers \\(x\\) such that \\(0 \\leq x \\leq 1\\). The theorem states that for any such \\(x\\), when considered as an element of the type \\(\\alpha\\), it holds that \\(x \\leq 1\\)."}
{"id": 884, "formal_statement": "theorem dummy (f : Œ± ‚Üí Œ≤) : Option.map f ‚àò some = some ‚àò f :=", "nl_statement": "The statement concerns the composition of functions in the context of option types in functional programming. Specifically, it states that mapping a function `f` over an `Option` type and then applying `some` to it is equivalent to first applying `f` to the value and then wrapping it in `some`."}
{"id": 885, "formal_statement": "theorem dummy {f : Œ± ‚Üí Œ≤} : Antitone (ContinuousOn f) :=", "nl_statement": "The theorem states that if a function \\(f\\) is continuous on a certain set, and if we have two sets \\(\\_s\\) and \\(\\_t\\) such that \\(\\_s\\) is contained within \\(\\_t\\), then the function \\(f\\) is also continuous on the smaller set \\(\\_s\\). This property is described as the function being \"antitone\" with respect to the property of being continuous on a set."}
{"id": 886, "formal_statement": "theorem dummy : Function.Injective (coe : R ‚Üí ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) :=", "nl_statement": "The theorem named `coe_injective` asserts that the function which casts elements from a real number domain `R` to a quaternion algebra `‚Ñç[R,c‚ÇÅ,c‚ÇÇ]` is injective. Being injective means that if the cast of two elements from `R` into `‚Ñç[R,c‚ÇÅ,c‚ÇÇ]` results in the same quaternion, then those two elements from `R` must be identical."}
{"id": 887, "formal_statement": "theorem dummy {f : Ultrafilter Œ±} {g : Filter Œ±} : NeBot (‚Üëf ‚äì g) ‚Üî ‚Üëf ‚â§ g :=", "nl_statement": "The theorem concerns an ultrafilter `f` over a type `Œ±` and a filter `g` over the same type. It states that the infimum (greatest lower bound) of the ultrafilter `f` and the filter `g`, when treated as principal filters, is not bottom (i.e., not the least element in the lattice of filters, which represents the trivial filter that converges to everything) if and only if the ultrafilter `f` is less than or equal to the filter `g` in the lattice of filters. In more intuitive terms, the intersection of the ultrafilter and another filter is non-trivial (contains more than just the empty set) if and only if the ultrafilter is a \"subfilter\" of the other filter."}
{"id": 888, "formal_statement": "theorem dummy {Œº : YoungDiagram} {i j : ‚Ñï} : (i, j) ‚àà Œº.col j ‚Üî (i, j) ‚àà Œº :=", "nl_statement": "The theorem is concerning a structure called `YoungDiagram`, and it presents a condition about when a pair `(i, j)`, representing coordinates or positions, is considered to be part of a column `j` within this diagram. Specifically, it asserts that a pair `(i, j)` is in the column `j` of a `YoungDiagram` if and only if `(i, j)` is in the `YoungDiagram` itself."}
{"id": 889, "formal_statement": "theorem dummy : s ‚äª {b} = s.image fun a => a ‚äî b :=", "nl_statement": "The statement describes a property related to the supremum (least upper bound) in the context of sets and elements. Specifically, it asserts that the supremum of a set \\(s\\) combined with a singleton set containing an element \\(b\\) is equal to the image of \\(s\\) under a function that maps each element \\(a\\) in \\(s\\) to the supremum of \\(a\\) and \\(b\\)."}
{"id": 890, "formal_statement": "theorem dummy [OrderBot Œ±] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : ‚ä• ‚àà s ‚Üî s = {‚ä•} :=", "nl_statement": "The theorem states that for any set `s` within a partially ordered set (poset) `Œ±` that has a least element (denoted by `‚ä•`), `‚ä•` is a member of `s` if and only if `s` consists solely of the least element, under the condition that `s` is an antichain. An antichain within a poset is a subset where no two distinct elements are comparable."}
{"id": 891, "formal_statement": "theorem dummy (a : Œ±) : upperClosure ({a} : Set Œ±) = UpperSet.Ici a :=", "nl_statement": "The statement in question is a theorem about upper closures in the context of order theory. Specifically, it concerns the upper closure of a singleton set containing an element \\(a\\) in some ordered set \\(\\alpha\\). The theorem asserts that the upper closure of the set \\(\\{a\\}\\) is equal to the set of all elements that are greater than or equal to \\(a\\) (denoted as \\(\\text{Ici}\\ a\\)), where \"Ici\" stands for \"interval closed and infinite to the right,\" implying all elements starting from \\(a\\) upwards without bound."}
{"id": 892, "formal_statement": "theorem dummy {a b c : Ordinal} (h : IsLimit b) : a * b ‚â§ c ‚Üî ‚àÄ b' < b, a * b' ‚â§ c :=", "nl_statement": "The statement concerns a property of multiplication over ordinal numbers, which are a way to generalize the concept of \"size\" beyond the natural numbers, including infinite sizes. Specifically, it asserts that for any three ordinals \\(a\\), \\(b\\), and \\(c\\), if \\(b\\) is a limit ordinal (an ordinal that is not zero or a successor of any ordinal), then the product of \\(a\\) and \\(b\\) is less than or equal to \\(c\\) if and only if for every ordinal \\(b'\\) that is less than \\(b\\), the product of \\(a\\) and \\(b'\\) is less than or equal to \\(c\\)."}
{"id": 893, "formal_statement": "theorem dummy (u : Set Œ±) (h : Disjoint s t) : Disjoint (u ‚à© s) t :=", "nl_statement": "The problem statement is about proving a property related to sets and the concept of disjoint sets. Specifically, it states that if two sets `s` and `t` are disjoint, then the intersection of any set `u` with `s` (denoted as `u ‚à© s`) is also disjoint with `t`."}
{"id": 894, "formal_statement": "theorem dummy : Countable Œ± ‚Üî Nonempty (Œ± ‚Ü™ ‚Ñï) :=", "nl_statement": "The statement in question concerns the relationship between the concepts of \"countability\" of a set and the existence of a certain kind of function (an embedding) from that set to the natural numbers ‚Ñï. Specifically, it claims that a set Œ± is countable if and only if there exists a nonempty embedding from Œ± to ‚Ñï. \n\nAn embedding, in this context, is a function that is injective, meaning no two distinct elements in the set Œ± map to the same element in ‚Ñï. The existence of such a function indicates a way to \"count\" the elements of Œ± using natural numbers, which intuitively supports the concept of Œ± being countable."}
{"id": 895, "formal_statement": "theorem dummy (hf : Monotone f) : Monotone fun x => Iio (f x) :=", "nl_statement": "The statement asserts that if a function `f` is monotone (meaning its output either never decreases or never increases as its input increases), then the function that maps any input `x` to the set of all real numbers less than `f(x)` (denoted as `Iio (f x)`, where `Iio` stands for the interval of all real numbers less than a given number) is also monotone."}
{"id": 896, "formal_statement": "theorem dummy {a : Œ±} {s nd} : a ‚àà @Finset.mk Œ± s nd ‚Üî a ‚àà s :=", "nl_statement": "The theorem stated is about finite sets in the context of the Lean4 theorem prover. It expresses that for a given element `a` of type `Œ±`, and a set `s` with a nodup condition `nd`, the element `a` is a member of the finite set `Finset.mk Œ± s nd` if and only if `a` is a member of the set `s`."}
{"id": 897, "formal_statement": "theorem dummy {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=", "nl_statement": "The statement is about the neighborhood of a point in a certain subset of the real numbers extended with positive infinity (notated as ‚Ñù‚â•0‚àû), specifically focusing on the interval that is greater than a given non-negative real number \\(r\\) (notated as \\(ùìù[>](r : ‚Ñù‚â•0‚àû)\\)). The theorem asserts that this neighborhood does not equal the bottom element in the lattice of topologies, indicating it's not the trivial, empty neighborhood; in essence, it's saying that there are always points arbitrarily close to \\(r\\), but greater than \\(r\\), in this extended real number space."}
{"id": 898, "formal_statement": "theorem dummy : 1 ‚â§ const Œ≤ a ‚Üî 1 ‚â§ a :=", "nl_statement": "The theorem named `one_le_const` states that for any type `Œ≤` and any constant `a`, the statement that \"1 is less than or equal to a constant function of `a`\" is equivalent to saying \"1 is less than or equal to `a`.\""}
{"id": 899, "formal_statement": "theorem dummy (ha : a ‚â§ 0) (h : b ‚â§ 1) : a ‚â§ a * b :=", "nl_statement": "The statement concerns a property of real numbers, specifically, it posits that if `a` is a non-positive number (meaning it is less than or equal to zero) and `b` is a number less than or equal to one, then the product of `a` and `b` is less than or equal to `a`."}
{"id": 900, "formal_statement": "theorem dummy (e : L‚ÇÅ ‚âÉ‚Çó‚ÅÖR‚ÅÜ L‚ÇÇ) : e.symm.symm = e :=", "nl_statement": "The theorem states that for a linear equivalence \\( e \\) between two Lie algebras \\( L_1 \\) and \\( L_2 \\) over a ring \\( R \\), applying the inverse operation (denoted as `.symm`) twice to \\( e \\) yields \\( e \\) itself. In other words, the double inverse of a linear equivalence is the linear equivalence itself."}
{"id": 901, "formal_statement": "theorem dummy {I J : Ideal R} : I ‚à£ J ‚Üí J ‚â§ I | ‚ü®_, h‚ü© => h.symm ‚ñ∏ le_trans mul_le_inf inf_le_left :=", "nl_statement": "Given two ideals \\(I\\) and \\(J\\) of a ring \\(R\\), the statement asserts that if \\(I\\) divides \\(J\\) (denoted \\(I \\mid J\\)), then \\(J\\) is less than or equal to \\(I\\) (denoted \\(J \\leq I\\))."}
{"id": 902, "formal_statement": "theorem dummy [CancelCommMonoidWithZero Œ±] {p q : Œ±} (h : DvdNotUnit p q) : p ‚â† q :=", "nl_statement": "The theorem asserts that in any cancellative commutative monoid with zero, for any elements \\(p\\) and \\(q\\), if \\(p\\) is a non-unit divisor of \\(q\\) (meaning \\(p\\) divides \\(q\\) but \\(p\\) is not a unit, i.e., it does not have a multiplicative inverse), then \\(p\\) is not equal to \\(q\\)."}
{"id": 903, "formal_statement": "theorem dummy : x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y) :=", "nl_statement": "The statement `x ‚Ä¢ (y : ‚Ñç[R,c‚ÇÅ,c‚ÇÇ]) = ‚Üë(x * y)` in the context of quaternion algebra refers to the scalar multiplication of a quaternion by a scalar. Specifically, it asserts that multiplying a quaternion `y` by a scalar `x` (notated as `x ‚Ä¢ y` where `‚Ä¢` denotes scalar multiplication) is equivalent to the multiplication of `x` and `y` first, and then representing the product as a quaternion (notated as `‚Üë(x * y)`)."}
{"id": 904, "formal_statement": "theorem dummy (F : C ‚•§ D) (X : C) : (NatTrans.id F).app X = ùüô (F.obj X) :=", "nl_statement": "The statement describes a theorem in category theory within the context of functors and natural transformations. Specifically, it asserts that for any functor `F` from category `C` to category `D`, and for any object `X` in category `C`, applying the identity natural transformation of `F` to `X` is the same as the identity morphism on the functor `F` applied to object `X`."}
{"id": 905, "formal_statement": "theorem dummy (x : ‚Ñù) : arccos x = œÄ / 2 - arcsin x :=", "nl_statement": "The theorem states that the arccosine of a real number \\(x\\) is equal to \\(\\frac{\\pi}{2}\\) minus the arcsine of \\(x\\)."}
{"id": 906, "formal_statement": "theorem dummy {x : HahnSeries Œì R} : IsUnit x ‚Üî IsUnit (x.coeff x.order) :=", "nl_statement": "The statement concerns the equivalence of two notions of being a \"unit\" (an element that has a multiplicative inverse) within the context of Hahn series. Specifically, it asserts that a Hahn series `x` is a unit if and only if the coefficient of `x` at its order (the least index for which the coefficient is non-zero) is itself a unit in the ring `R`."}
{"id": 907, "formal_statement": "theorem dummy [Preorder Œ±] {a b : Œ±} (h : a < b) : ¬¨b ‚â§ a :=", "nl_statement": "Given a preorder \\( \\alpha \\) and two elements \\( a \\) and \\( b \\) from \\( \\alpha \\), if \\( a \\) is less than \\( b \\) (\\( a < b \\)), then \\( b \\) is not less than or equal to \\( a \\) (\\( \\neg(b \\leq a) \\))."}
{"id": 908, "formal_statement": "theorem dummy (c : R) : derivative ((X + C c) ^ 2) = C 2 * (X + C c) :=", "nl_statement": "The statement concerns the derivative of the square of a polynomial function, specifically \\((X + C)^2\\), where \\(X\\) represents a variable and \\(C\\) is a constant term \\(c\\). The theorem asserts that the derivative of this squared function is equal to \\(2 \\times (X + C)\\)."}
{"id": 909, "formal_statement": "theorem dummy (hy : 0 < y) : x < log y ‚Üî exp x < y :=", "nl_statement": "The statement in question concerns the relationship between two fundamental mathematical functions: the logarithm (`log`) and the exponential function (`exp`). Specifically, it asserts that for any positive number `y`, a number `x` is less than the logarithm of `y` if and only if the exponential of `x` is less than `y`. This can be encapsulated in the statement: \"For all `x` and for all `y` greater than 0, `x < log(y)` if and only if `exp(x) < y`.\""}
{"id": 910, "formal_statement": "theorem dummy : IsLUB {a} a :=", "nl_statement": "The problem statement is to prove that a singleton set (a set containing exactly one element, in this case, `{a}`) has a least upper bound (LUB) that is the element itself (`a`)."}
{"id": 911, "formal_statement": "theorem dummy [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=", "nl_statement": "The statement we're examining asserts that if the product of two numbers, `a` and `b`, is negative, and if `b` is non-negative (meaning `b` is either positive or zero), then `a` must be negative. This leans on the mathematical principle that a positive or zero value cannot, when multiplied by another number, yield a negative product unless the other number is negative."}
{"id": 912, "formal_statement": "theorem dummy {x : ‚Ñ§_[p]} (hx : x ‚â† 0) : ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) :=", "nl_statement": "This theorem states that for a nonzero element \\(x\\) of the \\(p\\)-adic integers (\\(\\mathbb{Z}_p\\)), the norm of \\(x\\) (denoted as \\(\\|x\\|\\)) is equal to the base \\(p\\) raised to the power of the negative valuation of \\(x\\) (i.e., \\(p^{-\\text{valuation of } x}\\))."}
{"id": 913, "formal_statement": "theorem dummy (l : List Œ±) : (l : Cycle Œ±).toFinset = l.toFinset :=", "nl_statement": "The theorem states that converting a list `l` to a cycle and then to a finset (finite set) yields the same result as converting the list directly to a finset. In other words, the operation of converting a list to a cycle does not affect the eventual conversion to a finset."}
{"id": 914, "formal_statement": "theorem dummy : g.denominators 0 = 1 :=", "nl_statement": "The statement concerns a property of a generalized continued fraction, specifically the value of the denominator at the 0th step (initial step) of the fraction's expansion. The lemma states that this denominator equals 1."}
{"id": 915, "formal_statement": "theorem dummy (f : M ‚Üí‚Çó[R] M‚ÇÇ) : map (-f) p = map f p :=", "nl_statement": "The statement we're dealing with asserts a property about the mapping of linear transformations over modules, specifically within the context of a submodule `p`. In natural language, it says that if you apply a negated linear transformation (`-f`) to a submodule `p`, you will get the same result as if you were to apply the original linear transformation (`f`) to `p` and then negate the output. This theorem is about understanding how negation interacts with the linear transformation when applied to elements of a submodule."}
{"id": 916, "formal_statement": "theorem dummy (a : B) : (preinclusion B).obj a = a :=", "nl_statement": "The statement is about the `preinclusion` function in the context of category theory. Specifically, it asserts that for any object `a` in a bicategory `B`, the application of the `preinclusion` function to `a` results in `a` itself. In simpler terms, it states that the `preinclusion` function acts as an identity function on the objects of the bicategory `B`."}
{"id": 917, "formal_statement": "theorem dummy : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat :=", "nl_statement": "The statement you've provided declares a theorem regarding the cardinality (the number of elements) of a closed interval from `a` to `b` in a finite type. Specifically, it asserts that the size of the set containing all elements between `a` and `b`, inclusive, is equal to `b + 1 - a`, converted to a natural number."}
{"id": 918, "formal_statement": "theorem dummy (a : Œ±) (l : List Œ±) : indexOf a (a :: l) = 0 :=", "nl_statement": "The statement we're examining concerns the `indexOf` function, which finds the position of an element within a list. Specifically, the theorem `indexOf_cons_self` asserts that if you prepend an element `a` to a list `l` (resulting in a new list `a :: l`), the index of `a` in this new list is 0. This means that the first element of the list (the one we just added) is at position 0, as list indices start from 0."}
{"id": 919, "formal_statement": "theorem dummy : (prod p q‚ÇÅ : Set (M √ó M')) = (p : Set M) √óÀ¢ (q‚ÇÅ : Set M') :=", "nl_statement": "The theorem `prod_coe` states that the Cartesian product of two sets, `p` and `q‚ÇÅ`, when considered as subsets of the Cartesian product of two mathematical structures `M` and `M'`, is equal to the Cartesian product of `p` as a subset of `M` and `q‚ÇÅ` as a subset of `M'`. In simpler terms, if you have two sets `p` and `q‚ÇÅ` that are subsets of some mathematical structures `M` and `M'` respectively, then taking the Cartesian product of `p` and `q‚ÇÅ` is the same as taking the Cartesian product of these sets as they are considered within their respective structures."}
{"id": 920, "formal_statement": "theorem dummy (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c :=", "nl_statement": "The statement given is about a mathematical property related to transitivity in some relation \\(r\\). Specifically, it asserts that if there exists a transitive generation from \\(a\\) to \\(b\\) (denoted as `TransGen r a b`), and a reflexive transitive generation from \\(b\\) to \\(c` (denoted as `ReflTransGen r b c`), then there is a transitive generation from \\(a\\) to \\(c\\) (denoted as `TransGen r a c`)."}
{"id": 921, "formal_statement": "theorem dummy : factorization (1 : Œ±) = 0 :=", "nl_statement": "The statement we're dealing with is a theorem regarding the factorization of the number 1 in a given algebraic structure, denoted by Œ±. The theorem asserts that the factorization of 1 is equal to 0."}
{"id": 922, "formal_statement": "theorem dummy : (‚Üë(‚ä• : Compacts Œ±) : Set Œ±) = ‚àÖ :=", "nl_statement": "The theorem named `coe_bot` states that the coercion (type conversion) of the bottom element (`‚ä•`) in the type `Compacts Œ±` to a set of type `Œ±` results in the empty set (`‚àÖ`). Here, `Compacts Œ±` refers to a type representing compact subsets of a topological space with elements of type `Œ±`.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 923, "formal_statement": "theorem dummy [Countable Œπ] : (kernel.sum fun _ : Œπ => (0 : kernel Œ± Œ≤)) = 0 :=", "nl_statement": "The statement provided is a theorem concerning the sum of a certain type of function over a countable index set, where the function always returns zero. This theorem is situated within the context of measure theory, a branch of mathematics that deals with the quantification of \"size\" or \"measure\" of mathematical objects, particularly in spaces that allow for the integration of functions.\n\nThe theorem can be expressed in natural language as follows: \n\n\"Given a countable index set Œπ and a function from this set to a kernel (a mathematical construct used in probability theory and measure theory) that always returns zero, the sum of this function over all elements of Œπ is equal to zero.\""}
{"id": 924, "formal_statement": "theorem dummy {a : ‚Ñï} (h : 0 < a) (n : ‚Ñ§) : (a : Œ±) ^ n ‚â† 0 :=", "nl_statement": "The theorem states that for any positive natural number \\(a\\) and any integer \\(n\\), the integer power of \\(a\\) raised to \\(n\\) is never zero."}
{"id": 925, "formal_statement": "theorem dummy (f : R[X]) : f.reverse.natDegree = f.natDegree - f.natTrailingDegree :=", "nl_statement": "The theorem states that for a given polynomial \\(f\\) over some ring \\(R\\), the degree of its reverse polynomial, denoted as \\(f.reverse.natDegree\\), is equal to the natural degree of \\(f\\) (denoted as \\(f.natDegree\\)) minus the natural trailing degree of \\(f\\) (denoted as \\(f.natTrailingDegree\\))."}
{"id": 926, "formal_statement": "theorem dummy {s t : Set Œ±} {a b : Œ±} : b ‚àà doset a s t ‚Üî ‚àÉ x ‚àà s, ‚àÉ y ‚àà t, b = x * a * y :=", "nl_statement": "The theorem concerns elements belonging to a certain set constructed from two other sets, `s` and `t`, and an element `a` from a generic type `Œ±`. Specifically, it states that an element `b` belongs to the \"doset\" of `a`, `s`, and `t` if and only if there exists an element `x` in `s` and an element `y` in `t` such that `b` equals the product of `x`, `a`, and `y` in that order. The \"doset\" here seems to be a specific operation involving the sets `s` and `t`, the element `a`, and the operation of multiplication."}
{"id": 927, "formal_statement": "theorem dummy {X Y : C} (a b c d : X ‚ü∂ Y) : a - c - (b - d) = a - b - (c - d) :=", "nl_statement": "The theorem stated involves objects and morphisms in a category \\(C\\), which is assumed to have some subtraction operation (denoted by \\(-\\)) defined between morphisms. Specifically, for any four morphisms \\(a, b, c, d: X \\to Y\\) between two objects \\(X\\) and \\(Y\\) in \\(C\\), the theorem asserts that the expression \\(a - c - (b - d)\\) is equal to \\(a - b - (c - d)\\)."}
{"id": 928, "formal_statement": "theorem dummy (h : b ‚àà insert a s) : b ‚â† a ‚Üí b ‚àà s :=", "nl_statement": "The theorem `mem_of_mem_insert_of_ne` can be understood as a statement concerning the membership of elements within a set. Specifically, it asserts that if an element `b` is a member of a set formed by inserting an element `a` into another set `s`, and `b` is not equal to `a`, then `b` must be a member of the original set `s`."}
{"id": 929, "formal_statement": "theorem dummy (o) : pred (succ o) = o :=", "nl_statement": "The theorem states that the predecessor of the successor of any ordinal \\(o\\) is equal to \\(o\\) itself."}
{"id": 930, "formal_statement": "theorem dummy : Injective (pure : Œ± ‚Üí Interval Œ±) :=", "nl_statement": "The statement asserts the injectivity of the `pure` function when it is applied to elements of some type `Œ±`, resulting in values within an `Interval Œ±`. Injectivity means that if the `pure` function gives the same result for two different inputs, then those inputs must have been equal."}
{"id": 931, "formal_statement": "theorem dummy : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m Œ± ‚âÉ‚Çê[R] _) :=", "nl_statement": "The theorem named `mapMatrix_refl` states that the function `mapMatrix` applied to the identity algebraic equivalence (`AlgEquiv.refl`) is equal to the identity algebraic equivalence itself when considered as a transformation on square matrices (of type `Matrix m m Œ±`) over some ring `R`. In other words, applying `mapMatrix` to the identity equivalence does not change the matrix."}
{"id": 932, "formal_statement": "theorem dummy [DecidableEq Œ±] (b : Œ±) : (Iic b).erase b = Iio b :=", "nl_statement": "The theorem stated in Lean4's syntax can be translated to a natural language mathematical statement as follows: For any type `Œ±` with a decidable equality, the set obtained by removing the element `b` from the set of all elements less than or equal to `b` (`Iic b`) is exactly the set of all elements strictly less than `b` (`Iio b`)."}
{"id": 933, "formal_statement": "theorem dummy : IntervalIntegrable f Œº a a :=", "nl_statement": "The statement defines a theorem named `refl`, which asserts that a function `f` is interval integrable over an interval from `a` to `a` with respect to a measure `Œº`. Essentially, it states that integrating the function `f` over an interval that starts and ends at the same point `a` is a well-defined operation in the context of the specified measure `Œº`."}
{"id": 934, "formal_statement": "theorem dummy (h : ‚àÄ b, ¬¨r a b) : ReflTransGen r a b ‚Üî b = a :=", "nl_statement": "The theorem `reflTransGen_iff_eq` asserts a relationship between a reflexive transitive closure of a relation `r` on elements `a` and `b`, and the equality of `a` and `b`. Specifically, it states that under the condition that there is no `b` such that the relation `r` holds between `a` and `b`, the reflexive transitive closure of `r` from `a` to `b` holds if and only if `a` is equal to `b`."}
{"id": 935, "formal_statement": "theorem dummy : algebraMap F‚üÆŒ±‚üØ E (AdjoinSimple.gen F Œ±) = Œ± :=", "nl_statement": "The statement we're examining is about a mathematical structure within field theory, a branch of algebra. Specifically, it relates to the concept of field extensions and the process of adjoining an element to a field to create a larger field. In natural language, the theorem states that the image of the generator of the field extension \\(F‚üÆŒ±‚üØ\\) (created by adjoining an element \\(Œ±\\) to a field \\(F\\)) under the algebra map from \\(F‚üÆŒ±‚üØ\\) to \\(E\\) (where \\(E\\) is an extension field containing \\(F\\) and \\(Œ±\\)) is equal to \\(Œ±\\) itself."}
{"id": 936, "formal_statement": "theorem dummy {Œ±} [Primcodable Œ±] : Equivalence (@OneOneEquiv Œ± Œ± _ _) :=", "nl_statement": "The problem states that `OneOneEquiv`, presumably a relation on type `Œ±`, is an equivalence relation. Here, `Œ±` is a type that is `Primcodable`, meaning it has some primary encoding mechanism defined for it."}
{"id": 937, "formal_statement": "theorem dummy {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x :=", "nl_statement": "The theorem stated is about the continuity of the inversion function within a given set. Specifically, it says that if you have a set \\(s\\) and an element \\(x\\) within that set, which are part of a group \\(G\\), then the function that takes any element to its inverse is continuous at \\(x\\) within the set \\(s\\)."}
{"id": 938, "formal_statement": "theorem dummy : map Prod.swap (Œº.prod ŒΩ) = ŒΩ.prod Œº :=", "nl_statement": "The theorem `prod_swap` is concerned with the measure-theoretic concept of the product of two measures, denoted by Œº and ŒΩ, over the Cartesian product of two spaces. It asserts that if you swap the components of the pairs in the product space (a process mathematically represented by `Prod.swap`), the resulting measure is the same as if you had started with ŒΩ as the first measure and Œº as the second. In simpler terms, the theorem states that swapping the order of the measures in the product does not change the measure of the set."}
{"id": 939, "formal_statement": "theorem dummy : ({b} : Set Œ≤) -·µ• {c} = {b -·µ• c} :=", "nl_statement": "The statement concerns a property of sets in a certain mathematical space, denoted by Œ≤. Specifically, it discusses the result of the vector subtraction operation (denoted by \"-·µ•\") between two singleton sets. A singleton set is a set containing exactly one element. The statement claims that the vector subtraction of two singleton sets, each containing elements b and c respectively, results in another singleton set containing the result of the vector subtraction of the elements b and c themselves."}
{"id": 940, "formal_statement": "theorem dummy (h : Irrational x) (m : ‚Ñï) : Irrational (x + m) :=", "nl_statement": "The statement to be translated is about the irrationality of a specific mathematical expression. Specifically, it asserts that if \\(x\\) is an irrational number, then adding an integer \\(m\\) to \\(x\\) results in another irrational number."}
{"id": 941, "formal_statement": "theorem dummy (a : Œ±) (v : Vector3 Œ± m) (w : Vector3 Œ± n) : (a :: v) +-+ w = a :: v +-+ w :=", "nl_statement": "The theorem presented concerns the operation of appending a list (or vector) to another list, specifically in the context of a type `Œ±` and lists of potentially different lengths (`m` and `n`). It states that when you append a single element `a` of type `Œ±` to the front of a list `v` of length `m`, and then append another list `w` of length `n` to the result, it is equivalent to appending the list `w` directly to the list `v` (after having `a` appended to it). This property is crucial in understanding how lists behave under concatenation, especially when elements are added one at a time."}
{"id": 942, "formal_statement": "theorem dummy (s t u : Set Œ±) : s ‚à© t ‚à© u = s ‚à© u ‚à© (t ‚à© u) :=", "nl_statement": "The theorem states that for any three sets \\(s\\), \\(t\\), and \\(u\\) of some type \\(\\alpha\\), the intersection of \\(s\\) and \\(t\\) and then intersecting the result with \\(u\\) is equivalent to intersecting \\(s\\) with \\(u\\) and then intersecting the result with the intersection of \\(t\\) and \\(u\\). In mathematical terms, this can be written as:\n\\[s \\cap (t \\cap u) = (s \\cap u) \\cap (t \\cap u)\\]"}
{"id": 943, "formal_statement": "theorem dummy : SameCycle f x y ‚Üí SameCycle f y x :=", "nl_statement": "The statement concerns the concept of cycles in the context of permutations, specifically within the framework of a function \\(f\\) that permutes elements. The theorem named `SameCycle.symm` asserts that if an element \\(x\\) is in the same cycle as an element \\(y\\) under a permutation \\(f\\), then \\(y\\) is also in the same cycle as \\(x\\) under the same permutation. Essentially, this is about the symmetry property of cycles in permutations: if \\(x\\) can be transformed into \\(y\\) through a series of applications of \\(f\\), then \\(y\\) can be transformed back into \\(x\\) through the same means."}
{"id": 944, "formal_statement": "theorem dummy (a b : R) : abv a - abv b ‚â§ abv (a - b) :=", "nl_statement": "The statement concerns the absolute value of real numbers and expresses that the difference between the absolute values of two real numbers \\(a\\) and \\(b\\) is less than or equal to the absolute value of their difference. Formally, it states that for any two real numbers \\(a\\) and \\(b\\), the inequality \\(|a| - |b| \\leq |a - b|\\) holds."}
{"id": 945, "formal_statement": "theorem dummy {p : Œ± ‚Üí Prop} : (‚àÄ a, p a) ‚Üî p default :=", "nl_statement": "The theorem presented states that for any property \\(p\\) that might apply to elements of a type \\(\\alpha\\), the statement that \\(p\\) holds for all elements of \\(\\alpha\\) is equivalent to \\(p\\) holding for the default element of \\(\\alpha\\). This is expressed formally as: \\((\\forall a, p a) \\leftrightarrow p \\text{ default}\\)."}
{"id": 946, "formal_statement": "theorem dummy (œÄi : ‚àÄ J, Prepartition J) : œÄ.biUnion œÄi ‚â§ œÄ := fun _ hJ => let ‚ü®J', hJ', hJ‚ü© :=", "nl_statement": "The theorem `biUnion_le` concerns the concept of a binary union (`biUnion`) of partitions in a certain mathematical structure (possibly related to box integrals, given the context of `box_integral`). The statement asserts that for any given partition `œÄ` and a function `œÄi` that assigns a prepartition to every element `J` in a certain set, the binary union of `œÄ` with the prepartitions given by `œÄi` is less than or equal to the original partition `œÄ`."}
{"id": 947, "formal_statement": "theorem dummy (m : M) : (m ‚Ä¢ X : R[X]) = X :=", "nl_statement": "The statement given is a theorem related to the operation of scalar multiplication on polynomials over a ring \\(R\\) with a variable \\(X\\), and an element \\(m\\) from a module \\(M\\). The theorem asserts that scalar multiplication of the element \\(m\\) with the polynomial \\(X\\) results in the polynomial \\(X\\) itself."}
{"id": 948, "formal_statement": "theorem dummy (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f :=", "nl_statement": "The theorem named `supIndep_empty` is about a function `f` from a type `Œπ` to another type `Œ±` and deals with the concept of \"supremum independence\" over a finite set (`Finset`) of type `Œπ`. The statement claims that the empty set (denoted as `‚àÖ`) is supremum independent with respect to the function `f`."}
{"id": 949, "formal_statement": "theorem dummy [CommMonoid Œ±] {a : Œ±} (b : Œ±) (hab : a * b = 1) : a ~·µ§ 1 :=", "nl_statement": "Given a commutative monoid \\(\\alpha\\) and elements \\(a\\) and \\(b\\) in \\(\\alpha\\) such that the product of \\(a\\) and \\(b\\) equals the multiplicative identity (1), prove that \\(a\\) is associated to 1. In other words, we need to show that \\(a\\) is in some way equivalent to 1 under multiplication, respecting the structure of the commutative monoid."}
{"id": 950, "formal_statement": "theorem dummy (t : Ordnode Œ±) : size (dual t) = size t :=", "nl_statement": "The theorem states that for any ordered node \\(t\\) of type \\(\\alpha\\), the size of its dual is equal to its own size."}
{"id": 951, "formal_statement": "theorem dummy : ‚àÉ n‚ÇÄ, ‚àÄ k, F.N (n‚ÇÄ + k) = I ^ k ‚Ä¢ F.N n‚ÇÄ :=", "nl_statement": "The theorem \"Stable.exists_pow_smul_eq\" states that there exists a natural number \\( n_0 \\) such that for every \\( k \\), the function \\( F.N \\) evaluated at \\( n_0 + k \\) is equal to \\( I^k \\) (the \\( k \\)-th power of \\( I \\)) times the scalar \\( F.N \\) evaluated at \\( n_0 \\). In simpler terms, after a certain point \\( n_0 \\), the values of the function \\( F.N \\) can be represented as multiples of its value at \\( n_0 \\) by increasing powers of \\( I \\)."}
{"id": 952, "formal_statement": "theorem dummy (x : Œ±) : 1 ‚â§ ‚åäx‚åã‚Çä ‚Üî 1 ‚â§ x :=", "nl_statement": "The theorem `one_le_floor_iff` concerns the relationship between a real number \\(x\\) and its floor value, denoted as \\(\\lfloor x \\rfloor_+\\), where \\(\\lfloor x \\rfloor_+\\) represents the greatest integer less than or equal to \\(x\\). Specifically, it states a condition under which the statement \"1 is less than or equal to the floor of \\(x\\)\" is equivalent to \"1 is less than or equal to \\(x\\)\" itself."}
{"id": 953, "formal_statement": "theorem dummy {n} : ContDiff ‚Ñù n sinh :=", "nl_statement": "The theorem named `contDiff_sinh` states that the hyperbolic sine function (sinh) is continuously differentiable up to \\(n\\) times over the real numbers."}
{"id": 954, "formal_statement": "theorem dummy {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p :=", "nl_statement": "The statement given concerns a mathematical property related to the concept of \"Mem‚Ñìp,\" which is a way of specifying that a function (or sequence) belongs to a certain space characterized by \"p.\" This particular theorem establishes that if two functions (or sequences) `f` and `g`, each mapping from an index set `i` to a space `E i`, are both elements of this \"Mem‚Ñìp\" space (meaning they satisfy certain criteria determined by \"p\"), then the difference between these two functions `(f - g)` is also an element of the \"Mem‚Ñìp\" space."}
{"id": 955, "formal_statement": "theorem dummy (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n := eq_of_forall_le_iff fun b => by rw [le_floor_iff (add_nonneg ha n.cast_nonneg)] obtain hb | hb := le_total n b ¬∑ obtain ‚ü®d, rfl‚ü© := exists_add_of_le hb rw [Nat.cast_add, add_comm n, add_comm (n : Œ±), add_le_add_iff_right, add_le_add_iff_right, le_floor_iff ha] ¬∑ obtain ‚ü®d, rfl‚ü© :=", "nl_statement": "The theorem states that for any non-negative real number \\(a\\) and any natural number \\(n\\), the floor of the sum \\(a + n\\) (denoted as \\(\\lfloor a + n \\rfloor\\)) is equal to the sum of the floor of \\(a\\) and \\(n\\). In mathematical notation, this is expressed as \\(\\lfloor a + n \\rfloor = \\lfloor a \\rfloor + n\\), given that \\(a \\geq 0\\)."}
{"id": 956, "formal_statement": "theorem dummy (x : M) : IsSubmonoid (powers x) := { one_mem := powers.one_mem mul_mem :=", "nl_statement": "The theorem presented states that for any element \\(x\\) in a monoid \\(M\\), the set of powers of \\(x\\) forms a submonoid of \\(M\\)."}
{"id": 957, "formal_statement": "theorem dummy {a : Œ±} (h : a < 0) : ContinuousAt SignType.sign a :=", "nl_statement": "The statement concerns the continuity of a sign function at a particular point `a`, under the condition that `a` is less than zero (i.e., `a < 0`). The sign function typically returns -1 for negative inputs, 0 for zero, and 1 for positive inputs. The theorem asserts that if `a` is negative, then the sign function is continuous at `a`."}
{"id": 958, "formal_statement": "theorem dummy : mk a‚ÇÅ a‚ÇÇ ‚â§ mk b‚ÇÅ b‚ÇÇ ‚Üî ‚Üëb‚ÇÇ * a‚ÇÅ ‚â§ a‚ÇÇ * b‚ÇÅ :=", "nl_statement": "The statement involves a comparison between two constructed entities, denoted as `mk a‚ÇÅ a‚ÇÇ` and `mk b‚ÇÅ b‚ÇÇ`. The comparison is in terms of a less than or equal to (`‚â§`) relationship. The statement asserts that `mk a‚ÇÅ a‚ÇÇ` is less than or equal to `mk b‚ÇÅ b‚ÇÇ` if and only if the product of `b‚ÇÇ` and `a‚ÇÅ` is less than or equal to the product of `a‚ÇÇ` and `b‚ÇÅ`. In essence, it's translating a relationship between constructed entities into a relationship between products of their components."}
{"id": 959, "formal_statement": "theorem dummy (h‚ÇÅ : Antitone f) (h‚ÇÇ : Injective f) : StrictAnti f :=", "nl_statement": "This theorem states that if a function `f` is antitone (meaning if `a ‚â§ b` then `f(a) ‚â• f(b)`) and injective (meaning if `f(a) = f(b)` then `a = b`), then `f` is strictly antitone (meaning if `a < b` then `f(a) > f(b)`)."}
{"id": 960, "formal_statement": "theorem dummy (Œ± : X ‚âÖ Y) : Œ± ‚â™‚â´ Œ±.symm = Iso.refl X :=", "nl_statement": "The statement concerns a property of isomorphisms in category theory, specifically stating that for any isomorphism Œ± between objects X and Y, the composition of Œ± with its inverse (Œ±.symm) is equivalent to the identity isomorphism on X. In more familiar terms, if you have a way to go from object X to object Y (and back) without losing any information, doing this round trip gets you back where you started, just as if you had done nothing."}
{"id": 961, "formal_statement": "theorem dummy (i : m) : diagonal v i ‚¨ù·µ• w = v i * w i :=", "nl_statement": "The theorem named `diagonal_dotProduct` is about computing the dot product of a diagonal matrix created from a vector `v` with another vector `w`. Specifically, it states that for any index `i` within the size of these vectors (and the corresponding square matrix), the dot product of the `i`th row of the diagonal matrix with the entire vector `w` is equal to the product of the `i`th elements of `v` and `w`."}
{"id": 962, "formal_statement": "theorem dummy (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t :=", "nl_statement": "The statement in question asserts that if a set \\(t\\) is open and disjoint from another set \\(s\\), then the frontier of \\(s\\) is also disjoint from \\(t\\). The frontier of a set \\(s\\) refers to the points that are on the boundary of \\(s\\), meaning points that are neither in the interior nor completely outside \\(s\\), but where every neighborhood of these points contains both points in \\(s\\) and not in \\(s\\)."}
{"id": 963, "formal_statement": "theorem dummy {a : Œ±} : Injective (cons a) :=", "nl_statement": "The given statement asserts that the function `cons a`, which prepends an element `a` to a list, is injective for any fixed element `a`. Being injective means that if `cons a` produces the same list when applied to two different inputs, then those inputs must have been the same."}
{"id": 964, "formal_statement": "theorem dummy (e : ‚Ñ§À£) : ‚Äñ(e : ‚Ñ§)‚Äñ = 1 :=", "nl_statement": "The theorem `norm_coe_units` concerns the norm (or absolute value) of any unit integer `e`. A unit integer in this context is an integer that is either 1 or -1, meaning it is an element of the group of units in the ring of integers. The statement asserts that the norm of any such unit integer, when it is considered as an integer, is equal to 1."}
{"id": 965, "formal_statement": "theorem dummy (n : ‚Ñï) : (PInfty.f n : X _[n] ‚ü∂ _) + QInfty.f n = ùüô _ :=", "nl_statement": "The statement to be translated and explained is about the sum of two specific morphisms (functions between objects in a category, in this context likely within the realm of algebraic topology) within an infinite sequence or system (denoted by `PInfty` and `QInfty`) related to a certain object `X` indexed by natural numbers `n`. Specifically, it claims that the sum of the morphism associated with `PInfty` at index `n` and the morphism associated with `QInfty` at index `n`, when considered as morphisms in a certain Homological Complex (a structure in algebraic topology that generalizes the notion of a chain complex), is equal to the identity morphism on a certain object (denoted by the identity morphism symbol `ùüô` with an underscore, indicating the object on which it acts might be inferred from context).\n\nThe statement in natural language implies that in the context of algebraic topology, specifically within the study of homological complexes, the combination (via addition) of certain morphisms from two infinite sequences or systems associated with an object `X`, at any given index `n` within the natural numbers, results in a morphism that acts identically on the object at that index. This identity morphism essentially leaves the object unchanged, signifying that the sum of these two morphisms has no net effect on the object in the context of their action within the Homological Complex. \n\nThe use of `set_option linter.uppercaseLean3 false` is a configuration setting that affects the Lean4 proof assistant's behavior, likely related to naming conventions, but it does not contribute directly to the mathematical content of the proof.\n\nTranslate the statement and proof in natural language to Lean:"}
{"id": 966, "formal_statement": "theorem dummy : content (0 : R[X]) = 0 :=", "nl_statement": "The statement we're looking at asserts that the content of the zero polynomial in a ring \\(R[X]\\) is zero. Here, \"content\" refers to a certain measure or characteristic of polynomials, specifically, it often relates to the greatest common divisor (gcd) of the polynomial's coefficients in some contexts."}
{"id": 967, "formal_statement": "theorem dummy (hp1 : degree p = 1) : Irreducible p :=", "nl_statement": "The statement to be proven is that a polynomial \\(p\\) is irreducible if its degree is equal to one."}
{"id": 968, "formal_statement": "theorem dummy : ‚àû * ‚àû = ‚àû :=", "nl_statement": "The statement expresses a mathematical property regarding the multiplication of two infinite values, denoted by \"‚àû\". It asserts that the product of two infinities is equal to infinity."}
{"id": 969, "formal_statement": "theorem dummy [AddGroupWithOne Œ±] [CharZero Œ±] : Function.Injective (Int.cast : ‚Ñ§ ‚Üí Œ±) | _, _ => cast_inj.1 :=", "nl_statement": "The statement is about proving that the function which casts integers (`‚Ñ§`) to another type `Œ±`, under certain conditions, is injective. An injective function, or injection, is one that preserves distinctness; that is, if `f(a) = f(b)`, then `a = b`. The specific conditions required for this theorem to hold are that `Œ±` must be an additive group with a multiplicative identity (denoted by `AddGroupWithOne Œ±`), and it must have a characteristic of zero (`CharZero Œ±`). The characteristic of a ring is the smallest positive number `n` such that `n` times the multiplicative identity equals zero; if no such `n` exists, the characteristic is zero, indicating an infinite characteristic. In simpler terms, `CharZero Œ±` ensures that `Œ±` behaves like the rational, real, or complex numbers in terms of addition and multiplication."}
