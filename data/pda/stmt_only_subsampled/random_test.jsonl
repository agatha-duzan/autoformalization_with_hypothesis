{"id": 537, "formal_statement": "theorem dummy {p : Œ±} (hp : Prime p) : Prime (-p) :=", "nl_statement": "The statement to be translated is about prime numbers in a given mathematical structure. The theorem states that if a number \\( p \\) is prime, then its negation \\( -p \\) is also prime."}
{"id": 11, "formal_statement": "theorem dummy (a : Œ±) : ùìù[‚â†] a ‚äî pure a = ùìù a :=", "nl_statement": "The theorem named `nhdsWithin_compl_singleton_sup_pure` states that for any element `a` in a topological space `Œ±`, the neighborhood within the set excluding `a` (denoted as `ùìù[‚â†] a`), when combined with the singleton set containing `a` (denoted as `pure a`), is equivalent to the neighborhood of `a` (denoted as `ùìù a`)."}
{"id": 655, "formal_statement": "theorem dummy {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú :=", "nl_statement": "The problem states a theorem regarding elements and their relation within a set and its complement in the context of a partially ordered set (P). Specifically, the theorem involves two elements, x and y, of a partially ordered set P, an ideal I of P, and it relates the ordering of x and y (x ‚â§ y) to their membership in the complement of I (denoted as I·∂ú).\n\nThe theorem can be expressed as follows: Given two elements x and y in a partially ordered set P, if x is less than or equal to y (x ‚â§ y) and x is not in the ideal I (x ‚àà I·∂ú), then y is also not in the ideal I (y ‚àà I·∂ú)."}
{"id": 39, "formal_statement": "theorem dummy (a : SignType) : -a = a ‚Üî a = 0 :=", "nl_statement": "The theorem states that for a given element \\(a\\) of some type `SignType`, the equation \\(-a = a\\) holds if and only if \\(a = 0\\)."}
{"id": 52, "formal_statement": "theorem dummy : lowerBounds (‚àÖ : Set Œ±) = univ :=", "nl_statement": "The theorem named `lowerBounds_empty` states that the set of all lower bounds of the empty set, within any given type `Œ±`, is equal to the universal set. In simpler terms, it tells us that if you consider the empty set (a set with no elements) and look for all the elements that could be considered as lower bounds (elements that are less than or equal to every element in the set) to this empty set, you will find that every possible element can serve as a lower bound. This is because there are no elements in the empty set to contradict this claim, making every element in the universe a valid lower bound."}
{"id": 721, "formal_statement": "theorem dummy {p : Œ≤ ‚Üí Prop} : (‚àÄ y ‚àà e.target, p y) ‚Üî ‚àÄ x ‚àà e.source, p (e x) :=", "nl_statement": "The statement provided essentially says that for a certain property `p` that applies to elements of type `Œ≤`, the property holds for all elements in the set `e.target` if and only if it holds for all elements in `e.source` after being transformed by `e`. In more intuitive terms, consider `e` as a function or transformation from a set called `source` to another set called `target`. The theorem is stating that a property `p` is true for every element in `target` if and only if that property is also true for every element in `source` once it has been transformed by `e`."}
{"id": 910, "formal_statement": "theorem dummy : IsLUB {a} a :=", "nl_statement": "The problem statement is to prove that a singleton set (a set containing exactly one element, in this case, `{a}`) has a least upper bound (LUB) that is the element itself (`a`)."}
{"id": 77, "formal_statement": "theorem dummy : (inl R A B : A ‚Üí A √ó B) = fun x => (x, 0) :=", "nl_statement": "The given statement is a theorem in the context of mathematical or computer science logic, using the Lean4 theorem prover syntax. The theorem states that the function `inl` (which stands for \"inject left\") from a type `A` to the product type `A √ó B` is identical to a function that takes an element `x` of type `A` and returns a pair `(x, 0)`, where `0` is an element of type `B`. This assumes an appropriate definition of `0` in the context of `B`, such as a neutral element or a default value."}
{"id": 325, "formal_statement": "theorem dummy (x : F) : sqrt (normSqF x) = ‚Äñx‚Äñ :=", "nl_statement": "The theorem states that for any element \\(x\\) in a field \\(F\\), the square root of the norm squared of \\(x\\) is equal to the norm of \\(x\\). In mathematical notation, this can be written as \\(\\sqrt{\\|x\\|^2} = \\|x\\|\\), where \\(\\|x\\|\\) denotes the norm of \\(x\\), and \\(\\|x\\|^2\\) denotes the norm of \\(x\\) squared."}
{"id": 73, "formal_statement": "theorem dummy (G : Filter Œ¥) : comap œÜ (comap œà G) = comap Œ∏ (comap œÅ G) :=", "nl_statement": "The given theorem states that composing two comap (preimage filter) operations on a filter \\(G\\) with functions \\(\\phi\\) and \\(\\psi\\) is equivalent to another composition of comap operations on the same filter \\(G\\) but with different functions \\(\\theta\\) and \\(\\rho\\). In formula terms, it says \\(\\text{comap}\\ \\phi (\\text{comap}\\ \\psi G) = \\text{comap}\\ \\theta (\\text{comap}\\ \\rho G)\\)."}
{"id": 680, "formal_statement": "theorem dummy (hg : x ^ p = 1) (hg1 : x ‚â† 1) : orderOf x = p :=", "nl_statement": "The statement we're looking at is about the order of an element \\(x\\) in a group under multiplication. Specifically, it says that if \\(x\\) raised to the power of \\(p\\) equals 1, and \\(x\\) is not equal to 1 itself, then the order of \\(x\\) is \\(p\\). The order of an element \\(x\\) in this context refers to the smallest positive integer \\(p\\) such that \\(x^p = 1\\), where 1 represents the identity element of the group."}
{"id": 530, "formal_statement": "theorem dummy (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x :=", "nl_statement": "The theorem named `IsBaseChange.lift_eq` is concerned with a scenario in a linear algebra context over a ring \\(R\\). Given a linear map \\(g: M \\rightarrow Q\\), where \\(M\\) and \\(Q\\) are modules over \\(R\\), and another map \\(f: M \\rightarrow S\\), where \\(S\\) is presumably another \\(R\\)-module, the theorem states that for any element \\(x\\) in \\(M\\), applying \\(g\\) directly to \\(x\\) is equivalent to first applying \\(f\\) to \\(x\\), then lifting the result through a certain function \\(h.lift\\), which seems to construct a new linear map based on \\(g\\) and the action of \\(f\\)."}
{"id": 911, "formal_statement": "theorem dummy [MulPosMono Œ±] (h : a * b < 0) (h1 : 0 ‚â§ b) : a < 0 :=", "nl_statement": "The statement we're examining asserts that if the product of two numbers, `a` and `b`, is negative, and if `b` is non-negative (meaning `b` is either positive or zero), then `a` must be negative. This leans on the mathematical principle that a positive or zero value cannot, when multiplied by another number, yield a negative product unless the other number is negative."}
{"id": 682, "formal_statement": "theorem dummy {Œº : FiniteMeasure Œ©} : (Œº.mass : ‚Ñù‚â•0‚àû) = (Œº : Measure Œ©) univ :=", "nl_statement": "The theorem named `ennreal_mass` concerns a finite measure `\\mu` over a space `Œ©`. It states that the total mass of `\\mu` when considered as an extended non-negative real number (notated as `‚Ñù‚â•0‚àû`) is equal to the measure of the entire space `Œ©` (`univ` stands for the universal set, meaning the whole space in this context)."}
{"id": 613, "formal_statement": "theorem dummy (hp : p 1 ‚â§ 1) : p 1 = 1 ‚Üî p ‚â† 0 :=", "nl_statement": "The theorem named `seminorm_one_eq_one_iff_ne_zero` is concerned with a property of a seminorm \\(p\\) applied to the number 1. It states that \\(p(1) = 1\\) if and only if \\(p\\) is not the zero function. This is a significant property because it connects the value of a seminorm at a specific point (in this case, 1) with the general behavior of the seminorm (being non-zero)."}
{"id": 476, "formal_statement": "theorem dummy (f : A' ‚Üí+[M] B') (x y : A') : f (x - y) = f x - f y :=", "nl_statement": "The statement involves a function `f` that is a homomorphism between two additive groups `A'` and `B'`. A homomorphism in this context is a function that preserves the structure of the groups, specifically, it respects the addition operation. The theorem states that for any two elements `x` and `y` in `A'`, applying the function `f` to the difference `x - y` yields the same result as subtracting `f(y)` from `f(x)` in `B'`. In simpler terms, if you subtract two elements and then apply the function, it's the same as applying the function to each element separately and then subtracting the results."}
{"id": 822, "formal_statement": "theorem dummy : toLex x < toLex (update x i a) ‚Üî x i < a :=", "nl_statement": "The statement concerns a function `toLex` that, given some context about `x`, `i`, and `a`, compares `x` with a version of itself where the `i`-th element has been updated to `a`. Specifically, it claims that `toLex x` is less than `toLex (update x i a)` if and only if the `i`-th element of `x` is less than `a`."}
{"id": 762, "formal_statement": "theorem dummy (s t : Set R) : closure (s ‚à™ t) = closure s ‚äî closure t :=", "nl_statement": "The statement you're asking about asserts that the closure of the union of two sets, \\(s\\) and \\(t\\), within a certain context (likely a ring \\(R\\) given the use of `Set R`), is equal to the supremum (least upper bound) of the closures of \\(s\\) and \\(t\\) individually. In simpler terms, if you take two sets within a ring, unite them, and then find the smallest closed set that contains this union, this will be the same as finding the closure of each set individually and then finding the smallest closed set that contains both closures."}
{"id": 814, "formal_statement": "theorem dummy (p : Œ± ‚Üí Prop) : IsEmpty (Subtype p) ‚Üî ‚àÄ x, ¬¨p x :=", "nl_statement": "The theorem in question states that a subtype defined by a property \\(p\\) over a type \\(\\alpha\\) is empty if and only if, for every element \\(x\\) of type \\(\\alpha\\), the property \\(p(x)\\) does not hold. In other words, there are no elements \\(x\\) in \\(\\alpha\\) for which \\(p(x)\\) is true."}
{"id": 851, "formal_statement": "theorem dummy (h : orderOf x = 0) {n m : ‚Ñï} : x ^ n = x ^ m ‚Üî n = m :=", "nl_statement": "The statement concerns a mathematical property related to the powers of an element \\(x\\) in a group. Specifically, it addresses the scenario where the order of \\(x\\) is zero. The theorem states that for any natural numbers \\(n\\) and \\(m\\), \\(x\\) raised to the power of \\(n\\) equals \\(x\\) raised to the power of \\(m\\) if and only if \\(n\\) equals \\(m\\), given that the order of \\(x\\) is zero."}
{"id": 273, "formal_statement": "theorem dummy : f (lfp (g.comp f)) = lfp (f.comp g) :=", "nl_statement": "The statement essentially says that if you map the least fixed point (lfp) of a composition of two functions \\(g\\) after \\(f\\) through \\(f\\), it is equal to the least fixed point of the composition of \\(f\\) after \\(g\\). In simpler terms, it's about the interchangeability of the order of function composition when applied to the concept of least fixed points under certain conditions."}
{"id": 862, "formal_statement": "theorem dummy : f.comp id = f :=", "nl_statement": "The theorem states that the composition of a function \\(f\\) with the identity function (\\(id\\)) is equal to the function \\(f\\) itself. In mathematical terms, for any function \\(f\\), applying \\(f\\) after applying the identity function to any argument gives the same result as just applying \\(f\\) to that argument."}
{"id": 363, "formal_statement": "theorem dummy (x : ‚Ñù) (n : ‚Ñ§) : tan (x + n * œÄ) = tan x :=", "nl_statement": "The statement to be proven is that the tangent of an angle (x) added to an integer multiple of œÄ (where œÄ represents the constant pi, approximately equal to 3.14159) is equal to the tangent of that angle (x) itself. Mathematically, this can be written as tan(x + nœÄ) = tan(x), where x is a real number and n is an integer."}
{"id": 568, "formal_statement": "theorem dummy : 0 < a * a := le_trans (le_of_lt a1) (by have :=", "nl_statement": "The statement is asserting that for a positive integer \\(a\\), the square of \\(a\\) (\\(a * a\\)) is also positive."}
{"id": 200, "formal_statement": "theorem dummy {p q : Œ± √ó Œ≤} : swap p = swap q ‚Üî p = q :=", "nl_statement": "The problem presents a theorem involving pairs (also known as tuples) of elements, where `Œ±` and `Œ≤` represent types of the elements in these pairs. Specifically, it involves the `swap` operation on pairs, which exchanges the positions of the elements in a pair. For example, if you have a pair `(a, b)`, applying `swap` to it would yield `(b, a)`. The theorem states that swapping the elements of two pairs `p` and `q` results in equality (i.e., `swap p = swap q`) if and only if the original pairs `p` and `q` were equal to begin with."}
{"id": 749, "formal_statement": "theorem dummy {f : Œ± ‚Üí F} : Œº { y | snormEssSup f Œº < ‚Äñf y‚Äñ‚Çä } = 0 :=", "nl_statement": "The theorem `meas_snormEssSup_lt` concerns a function `f` from some domain `Œ±` to a Banach space `F`, and a measure `Œº`. It states that the measure of the set of points `y` in `Œ±` where the essential supremum norm of `f` with respect to `Œº`, denoted as `snormEssSup f Œº`, is less than the non-negative norm of `f(y)`, is equal to zero. In simpler terms, almost everywhere in the domain of `f` (according to the measure `Œº`), the value of `f` at any point does not exceed the essential supremum norm of `f`."}
{"id": 782, "formal_statement": "theorem dummy (x : P) : (AffineIsometry.id : P ‚Üí·µÉ‚Å±[ùïú] P) x = x :=", "nl_statement": "The theorem named `id_apply` concerns a mathematical structure in a geometric context, specifically dealing with affine isometries. It states that applying the identity affine isometry to any point `x` in a space `P` results in the same point `x`. In simpler terms, if you have a transformation that does absolutely nothing to the points in a space (that is, it's the identity transformation), then applying this transformation to any point `x` doesn't change that point at all."}
{"id": 458, "formal_statement": "theorem dummy : DifferentiableAt ùïú Œ¶ x ‚Üî ‚àÄ i, DifferentiableAt ùïú (fun x => Œ¶ x i) x :=", "nl_statement": "The theorem states that a function Œ¶ is differentiable at a point x in the space ùïú if and only if each component function of Œ¶, denoted as Œ¶(x)i (where i indexes the components of the output of Œ¶), is differentiable at x. This theorem essentially bridges the differentiability of a vector-valued function with the differentiability of its component functions."}
{"id": 276, "formal_statement": "theorem dummy (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f :=", "nl_statement": "The theorem named `sup_liminf` concerns the relationship between the supremum (least upper bound) of a set and the limit inferior (liminf) of a function over a filter. Specifically, it states that for any element `a` in a set `Œ±` and a function `u` from some index set to `Œ±`, the supremum of `a` and the liminf of `u` over a filter `f` is equal to the liminf of the function that takes each element `x` to the supremum of `a` and `u(x)`, over the same filter `f`."}
{"id": 242, "formal_statement": "theorem dummy {Œ±} [OrderedRing Œ±] {a b : Œ±} (ha : a ‚â§ 0) (hb : 0 < b) : b * a ‚â§ 0 := have : (-b)*a ‚â• 0 :=", "nl_statement": "The theorem states that for any ordered ring \\(\\alpha\\), given two elements \\(a\\) and \\(b\\) of \\(\\alpha\\), if \\(a\\) is less than or equal to zero (\\(a \\leq 0\\)) and \\(b\\) is greater than zero (\\(0 < b\\)), then the product of \\(b\\) and \\(a\\) (\\(b \\cdot a\\)) is less than or equal to zero (\\(b \\cdot a \\leq 0\\))."}
{"id": 517, "formal_statement": "theorem dummy (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y) :=", "nl_statement": "The problem states that if `x` and `y` are nilpotent elements, then their sum `x + y` is also a nilpotent element. An element is considered nilpotent if there exists a positive integer `n` such that the element raised to the power of `n` equals zero."}
{"id": 544, "formal_statement": "theorem dummy : Disjoint s t ‚Üî ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a ‚â† b :=", "nl_statement": "The statement to be proven is that two sets, `s` and `t`, are disjoint if and only if for every element `a` in set `s` and every element `b` in set `t`, `a` is not equal to `b`."}
{"id": 137, "formal_statement": "theorem dummy : orderOf (1 : G) = 1 :=", "nl_statement": "The theorem `orderOf_one` states that the order of the element 1 in a group G is 1."}
{"id": 248, "formal_statement": "theorem dummy (hh : Monotone h) : ‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h } = ‚ãÇ s ‚àà f, h s :=", "nl_statement": "The statement provided involves the concept of intersections over sets in a specific mathematical context, using the Lean4 theorem prover syntax. It asserts that the intersection over all sets obtained by applying a function `h` to the elements of a family of sets `f` (denoted as `‚ãÇ‚ÇÄ { s | s ‚àà f.lift' h }`) is equal to the intersection of applying the function `h` directly to each set in the family `f` (denoted as `‚ãÇ s ‚àà f, h s`). This is under the condition that `h` is a monotone function, meaning `h` preserves the order (if `a ‚â§ b`, then `h(a) ‚â§ h(b)`)."}
{"id": 41, "formal_statement": "theorem dummy {Œ≤} (f : Œ± ‚Üí Œ≤) (m m' : OuterMeasure Œ±) : map f (m ‚äî m') = map f m ‚äî map f m' :=", "nl_statement": "The theorem states that for any function `f` from a set `Œ±` to a set `Œ≤`, and for any two outer measures `m` and `m'` on `Œ±`, the outer measure of the supremum (least upper bound) of `m` and `m'` mapped through `f` is equal to the supremum of the outer measures of `m` and `m'` individually mapped through `f`. \n\nThis can be intuitively understood as saying that if you have two ways of measuring things in one space (`Œ±`), and then you map those measurements into another space (`Œ≤`), taking the \"bigger\" measurement at each point in `Œ±` before or after the mapping gives the same result."}
{"id": 747, "formal_statement": "theorem dummy {x : L} : x ‚àà lieSpan R L s ‚Üî ‚àÄ K : LieSubalgebra R L, s ‚äÜ K ‚Üí x ‚àà K :=", "nl_statement": "The problem presents a theorem about an element \\(x\\) of a Lie algebra \\(L\\) over a ring \\(R\\), concerning its membership in the Lie span of a subset \\(s\\) of \\(L\\). The theorem states that \\(x\\) is in the Lie span of \\(s\\) if and only if, for every Lie subalgebra \\(K\\) of \\(L\\) that contains \\(s\\), \\(x\\) is also in \\(K\\)."}
{"id": 494, "formal_statement": "theorem dummy : functor r ‚ãô lift r F H = F :=", "nl_statement": "The theorem named `lift_spec` states that composing the `functor` \\(r\\) with the `lift` of \\(r\\) over a functor \\(F\\) with a property \\(H\\) results in the functor \\(F\\) itself. In simpler terms, if you take a functor, lift it according to some rules (defined by \\(r\\) and \\(H\\)), and then compose it with \\(r\\), you end up with the original functor you started with. This is a property related to category theory, specifically dealing with functors, natural transformations, and constructions like lifting which are fundamental in understanding how different categories relate to each other."}
{"id": 270, "formal_statement": "theorem dummy (D : Derivation R A M) : ‚Üë(-D) = (-D : A ‚Üí‚Çó[R] M) :=", "nl_statement": "The theorem `coe_neg_linearMap` concerns a derivation `D` from a ring `R` to a module `M` over `R`, with coefficients in an algebra `A`. It states that the coercion of the negation of `D` (written as `‚Üë(-D)`) to a linear map from `A` to `M` is equal to the negation of `D` considered as a linear map from `A` to `M`."}
{"id": 783, "formal_statement": "theorem dummy {t t' : TopologicalSpace Œ±} (h : t ‚â§ t') : Continuous[t, t'] id :=", "nl_statement": "The theorem states that for any two topological spaces \\(t\\) and \\(t'\\) over the same set \\(\\alpha\\), if \\(t\\) is less than or equal to \\(t'\\) (denoted by \\(t \\leq t'\\)), then the identity function (denoted by \\(id\\)) is continuous from \\(t\\) to \\(t'\\)."}
{"id": 287, "formal_statement": "theorem dummy (a : R) : natTrailingDegree (C a) = 0 :=", "nl_statement": "The statement we're discussing concerns the natural trailing degree of a certain type of polynomial. Specifically, it addresses the polynomial that results from taking a constant `a` in the ring `R` and creating a constant polynomial `C a` from it. The statement claims that the natural trailing degree of this constant polynomial is `0`."}
{"id": 163, "formal_statement": "theorem dummy (h : n ‚â† 0) : (Finset.range n.succ).filter (¬∑ ‚à£ n) = n.divisors :=", "nl_statement": "The statement to be proved is about finding the divisors of a nonzero natural number \\(n\\). It asserts that when you filter all natural numbers up to \\(n\\) (inclusive) by whether they divide \\(n\\), the result is the same as the set of divisors of \\(n\\)."}
{"id": 429, "formal_statement": "theorem dummy : Disjoint s (t \\ s) :=", "nl_statement": "The theorem named `disjoint_sdiff` states that a set `s` and the set resulting from subtracting `s` from another set `t` (denoted as `t \\ s` or \"t sdiff s\") are disjoint. In other words, the set `s` and the set obtained by removing all elements of `s` from `t` have no elements in common."}
{"id": 720, "formal_statement": "theorem dummy (p : R[X]) (hq : ¬¨Monic q) : p %‚Çò q = p :=", "nl_statement": "The statement concerns polynomials over a ring \\(R\\) and involves the operation of taking the remainder of one polynomial when divided by another, denoted as \\(p \\%‚Çò q\\), where \\(p\\) and \\(q\\) are polynomials in \\(R[X]\\). The theorem asserts that if \\(q\\) is not a monic polynomial (meaning its leading coefficient is not 1), then the remainder of \\(p\\) when divided by \\(q\\) is simply \\(p\\) itself."}
{"id": 42, "formal_statement": "theorem dummy (a : A) (m n : ‚Ñï) : (m + n) ‚Ä¢ a = m ‚Ä¢ a + n ‚Ä¢ a :=", "nl_statement": "The theorem states that for any element `a` of a certain type `A` and natural numbers `m` and `n`, the operation of scaling `a` by the sum of `m` and `n` (denoted as `(m + n) ‚Ä¢ a`) is equivalent to the sum of scaling `a` by `m` and then by `n` (denoted as `m ‚Ä¢ a + n ‚Ä¢ a`)."}
{"id": 127, "formal_statement": "theorem dummy (b : Œ≤‚ÇÅ) : prodExtendRight a e (a, b) = (a, e b) :=", "nl_statement": "The theorem named `prodExtendRight_apply_eq` asserts that when a certain function, denoted `prodExtendRight`, is applied to a pair consisting of elements `a` (of some type) and `b` (of type Œ≤‚ÇÅ), the result is a new pair. The first element of this new pair is the same `a`, and the second element is the result of applying some function `e` to `b`. In other words, this theorem is about transforming the second element of a given pair `(a, b)` by applying a function `e` to it, while keeping the first element `a` unchanged."}
{"id": 351, "formal_statement": "theorem dummy {n : ‚Ñï} {r : R} : r * (-1) ^ n = 0 ‚Üî r = 0 :=", "nl_statement": "The theorem states that for any natural number \\(n\\) and any element \\(r\\) from a ring \\(R\\), the equation \\(r \\cdot (-1)^n = 0\\) holds if and only if \\(r = 0\\)."}
{"id": 474, "formal_statement": "theorem dummy : LinearIndependent R (fun x => x : (‚àÖ : Set M) ‚Üí M) :=", "nl_statement": "The statement asserts that the empty set is linearly independent in the context of a vector space over a field R with elements of type M. In simpler terms, it means that no vector in the empty set can be represented as a linear combination of the others, which is trivially true since there are no vectors in the empty set to begin with."}
{"id": 955, "formal_statement": "theorem dummy (ha : 0 ‚â§ a) (n : ‚Ñï) : ‚åäa + n‚åã‚Çä = ‚åäa‚åã‚Çä + n := eq_of_forall_le_iff fun b => by rw [le_floor_iff (add_nonneg ha n.cast_nonneg)] obtain hb | hb := le_total n b ¬∑ obtain ‚ü®d, rfl‚ü© := exists_add_of_le hb rw [Nat.cast_add, add_comm n, add_comm (n : Œ±), add_le_add_iff_right, add_le_add_iff_right, le_floor_iff ha] ¬∑ obtain ‚ü®d, rfl‚ü© :=", "nl_statement": "The theorem states that for any non-negative real number \\(a\\) and any natural number \\(n\\), the floor of the sum \\(a + n\\) (denoted as \\(\\lfloor a + n \\rfloor\\)) is equal to the sum of the floor of \\(a\\) and \\(n\\). In mathematical notation, this is expressed as \\(\\lfloor a + n \\rfloor = \\lfloor a \\rfloor + n\\), given that \\(a \\geq 0\\)."}
{"id": 628, "formal_statement": "theorem dummy : StrictConvex ùïú (‚àÖ : Set E) :=", "nl_statement": "Strict Convexity of an Empty Set\n\nThe theorem states that an empty set is strictly convex in a vector space over a field ùïú.\n\nIn mathematical terms, a set \\(S\\) in a vector space is strictly convex if, for any two distinct points \\(x\\) and \\(y\\) in \\(S\\), and for any \\(t\\) in the open interval (0, 1), the point \\(tx + (1-t)y\\) is in the interior of \\(S\\). The concept of strict convexity is important in optimization and analysis, as it ensures uniqueness of solutions to optimization problems and has implications for the behavior of functions on the set."}
{"id": 852, "formal_statement": "theorem dummy {X Y : C·µí·µñ} (f : X ‚âÖ Y) : f.unop.op = f :=", "nl_statement": "The statement involves category theory within the context of the Lean4 theorem prover. The theorem asserts that for any two objects \\(X\\) and \\(Y\\) in the opposite category \\(C^{op}\\), given an isomorphism \\(f: X \\to Y\\), the operation of first taking the opposite (unop) of \\(f\\) and then taking the opposite (op) of that result yields \\(f\\) itself. In simpler terms, if you reverse the direction of an isomorphism in the opposite category and then reverse it back, you end up with the original isomorphism."}
